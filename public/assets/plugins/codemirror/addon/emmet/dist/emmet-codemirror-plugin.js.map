{"version":3,"file":"emmet-codemirror-plugin.js","sources":["../node_modules/@emmetio/stream-reader-utils/dist/stream-reader-utils.es.js","../node_modules/@emmetio/node/dist/node.es.js","../node_modules/@emmetio/stream-reader/dist/stream-reader.es.js","../node_modules/@emmetio/abbreviation/dist/abbreviation.es.js","../node_modules/@emmetio/html-snippets-resolver/dist/html-snippets-resolver.es.js","../node_modules/@emmetio/implicit-tag/dist/implicit-tag.es.js","../node_modules/@emmetio/html-transform/dist/html-transform.es.js","../node_modules/@emmetio/variable-resolver/dist/variable-resolver.es.js","../node_modules/@emmetio/field-parser/dist/field-parser.es.js","../node_modules/@emmetio/output-renderer/dist/output-renderer.es.js","../node_modules/@emmetio/markup-formatters/dist/markup-formatters.es.js","../node_modules/@emmetio/css-abbreviation/dist/css-abbreviation.es.js","../node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/css-snippets-resolver/dist/css-snippets-resolver.es.js","../node_modules/@emmetio/stylesheet-formatters/dist/stylesheet-formatters.es.js","../node_modules/@emmetio/snippets/dist/snippets.es.js","../node_modules/@emmetio/lorem/dist/lorem.es.js","../node_modules/@emmetio/snippets-registry/dist/snippets-registry.es.js","../node_modules/@emmetio/output-profile/dist/output-profile.es.js","../node_modules/@emmetio/expand-abbreviation/dist/expand.es.js","../node_modules/@emmetio/extract-abbreviation/dist/extract-abbreviation.es.js","../node_modules/@emmetio/config/dist/config.es.js","../lib/config.js","../lib/stream-reader.js","../lib/utils.js","../lib/snippet.js","../lib/abbreviation.js","../lib/extract-abbreviation.js","../lib/commands/expand-abbreviation.js","../lib/commands/formatted-line-break.js","../lib/commands/wrap-with-abbreviation.js","../node_modules/@emmetio/css-snippets-resolver/dist/css-snippets-resolver.es.js","../lib/autocomplete.js","../node_modules/@emmetio/html-matcher/dist/html-matcher.es.js","../lib/model/syntax-model.js","../lib/model/html.js","../lib/model/index.js","../lib/match-tag.js","../lib/rename-tag.js","../browser.js","../extension.js","../lib/abbreviation-marker.js"],"sourcesContent":["/**\n * Methods for consuming quoted values\n */\n\nconst SINGLE_QUOTE = 39; // '\nconst DOUBLE_QUOTE = 34; // \"\n\nconst defaultOptions = {\n\tescape: 92,   // \\ character\n\tthrows: false\n};\n\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @param  {StreamReader} stream\n * @param  {Number}  options.escape A character code of quote-escape symbol\n * @param  {Boolean} options.throws Throw error if quotes string can’t be properly consumed\n * @return {Boolean} `true` if quoted string was consumed. The contents\n *                   of quoted string will be availabe as `stream.current()`\n */\nvar eatQuoted = function(stream, options) {\n\toptions = options ? Object.assign({}, defaultOptions, options) : defaultOptions;\n\tconst start = stream.pos;\n\tconst quote = stream.peek();\n\n\tif (stream.eat(isQuote)) {\n\t\twhile (!stream.eof()) {\n\t\t\tswitch (stream.next()) {\n\t\t\t\tcase quote:\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn true;\n\n\t\t\t\tcase options.escape:\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If we’re here then stream wasn’t properly consumed.\n\t\t// Revert stream and decide what to do\n\t\tstream.pos = start;\n\n\t\tif (options.throws) {\n\t\t\tthrow stream.error('Unable to consume quoted string');\n\t\t}\n\t}\n\n\treturn false;\n};\n\nfunction isQuote(code) {\n\treturn code === SINGLE_QUOTE || code === DOUBLE_QUOTE;\n}\n\n/**\n * Check if given code is a number\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isNumber(code) {\n\treturn code > 47 && code < 58;\n}\n\n/**\n * Check if given character code is alpha code (letter through A to Z)\n * @param  {Number}  code\n * @param  {Number}  [from]\n * @param  {Number}  [to]\n * @return {Boolean}\n */\nfunction isAlpha(code, from, to) {\n\tfrom = from || 65; // A\n\tto   = to   || 90; // Z\n\tcode &= ~32; // quick hack to convert any char code to uppercase char code\n\n\treturn code >= from && code <= to;\n}\n\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaNumeric(code) {\n\treturn isNumber(code) || isAlpha(code);\n}\n\nfunction isWhiteSpace(code) {\n\treturn code === 32   /* space */\n\t\t|| code === 9    /* tab */\n\t\t|| code === 160; /* non-breaking space */\n}\n\n/**\n * Check if given character code is a space\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isSpace(code) {\n\treturn isWhiteSpace(code)\n\t\t|| code === 10  /* LF */\n\t\t|| code === 13; /* CR */\n}\n\nconst defaultOptions$1 = {\n\tescape: 92,   // \\ character\n\tthrows: false\n};\n\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param  {StreamReader} stream\n * @param  {Number} open      Character code of pair openinig\n * @param  {Number} close     Character code of pair closing\n * @param  {Object} [options]\n * @return {Boolean}       Returns `true` if chacarter pair was successfully\n *                         consumed, it’s content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n\toptions = options ? Object.assign({}, defaultOptions$1, options) : defaultOptions$1;\n\tconst start = stream.pos;\n\n\tif (stream.eat(open)) {\n\t\tlet stack = 1, ch;\n\n\t\twhile (!stream.eof()) {\n\t\t\tif (eatQuoted(stream, options)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tch = stream.next();\n\t\t\tif (ch === open) {\n\t\t\t\tstack++;\n\t\t\t} else if (ch === close) {\n\t\t\t\tstack--;\n\t\t\t\tif (!stack) {\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (ch === options.escape) {\n\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\n\t\t// If we’re here then paired character can’t be consumed\n\t\tstream.pos = start;\n\n\t\tif (options.throws) {\n\t\t\tthrow stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport { eatQuoted, isQuote, isAlpha, isNumber, isAlphaNumeric, isSpace, isWhiteSpace, eatPair };\n","/**\n * Attribute descriptor of parsed abbreviation node\n * @param {String} name Attribute name\n * @param {String} value Attribute value\n * @param {Object} options Additional custom attribute options\n * @param {Boolean} options.boolean Attribute is boolean (e.g. name equals value)\n * @param {Boolean} options.implied Attribute is implied (e.g. must be outputted\n * only if contains non-null value)\n */\nclass Attribute {\n\tconstructor(name, value, options) {\n\t\tthis.name = name;\n\t\tthis.value = value != null ? value : null;\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * Create a copy of current attribute\n\t * @return {Attribute}\n\t */\n\tclone() {\n\t\treturn new Attribute(this.name, this.value, Object.assign({}, this.options));\n\t}\n\n\t/**\n\t * A string representation of current node\n\t */\n\tvalueOf() {\n\t\treturn `${this.name}=\"${this.value}\"`;\n\t}\n}\n\n/**\n * A parsed abbreviation AST node. Nodes build up an abbreviation AST tree\n */\nclass Node {\n\t/**\n\t * Creates a new node\n\t * @param {String} [name] Node name\n\t * @param {Array} [attributes] Array of attributes to add\n\t */\n\tconstructor(name, attributes) {\n\t\t// own properties\n\t\tthis.name = name || null;\n\t\tthis.value = null;\n\t\tthis.repeat = null;\n\t\tthis.selfClosing = false;\n\n\t\tthis.children = [];\n\n\t\t/** @type {Node} Pointer to parent node */\n\t\tthis.parent = null;\n\n\t\t/** @type {Node} Pointer to next sibling */\n\t\tthis.next = null;\n\n\t\t/** @type {Node} Pointer to previous sibling */\n\t\tthis.previous = null;\n\n\t\tthis._attributes = [];\n\n\t\tif (Array.isArray(attributes)) {\n\t\t\tattributes.forEach(attr => this.setAttribute(attr));\n\t\t}\n\t}\n\n\t/**\n\t * Array of current node attributes\n\t * @return {Attribute[]} Array of attributes\n\t */\n\tget attributes() {\n\t\treturn this._attributes;\n\t}\n\n\t/**\n\t * A shorthand to retreive node attributes as map\n\t * @return {Object}\n\t */\n\tget attributesMap() {\n\t\treturn this.attributes.reduce((out, attr) => {\n\t\t\tout[attr.name] = attr.options.boolean ? attr.name : attr.value;\n\t\t\treturn out;\n\t\t}, {});\n\t}\n\n\t/**\n\t * Check if current node is a grouping one, e.g. has no actual representation\n\t * and is used for grouping subsequent nodes only\n\t * @return {Boolean}\n\t */\n\tget isGroup() {\n\t\treturn !this.name && !this.value && !this._attributes.length;\n\t}\n\n\t/**\n\t * Check if given node is a text-only node, e.g. contains only value\n\t * @return {Boolean}\n\t */\n\tget isTextOnly() {\n\t\treturn !this.name && !!this.value && !this._attributes.length;\n\t}\n\n\t/**\n\t * Returns first child node\n\t * @return {Node}\n\t */\n\tget firstChild() {\n\t\treturn this.children[0];\n\t}\n\n\t/**\n\t * Returns last child of current node\n\t * @return {Node}\n\t */\n\tget lastChild() {\n\t\treturn this.children[this.children.length - 1];\n\t}\n\n\t/**\n\t * Return index of current node in its parent child list\n\t * @return {Number} Returns -1 if current node is a root one\n\t */\n\tget childIndex() {\n\t\treturn this.parent ? this.parent.children.indexOf(this) : -1;\n\t}\n\n\t/**\n\t * Returns next sibling of current node\n\t * @return {Node}\n\t */\n\tget nextSibling() {\n\t\treturn this.next;\n\t}\n\n\t/**\n\t * Returns previous sibling of current node\n\t * @return {Node}\n\t */\n\tget previousSibling() {\n\t\treturn this.previous;\n\t}\n\n\t/**\n\t * Returns array of unique class names in current node\n\t * @return {String[]}\n\t */\n\tget classList() {\n\t\tconst attr = this.getAttribute('class');\n\t\treturn attr && attr.value\n\t\t\t? attr.value.split(/\\s+/g).filter(uniqueClass)\n\t\t\t: [];\n\t}\n\n\t/**\n\t * Convenient alias to create a new node instance\n\t * @param {String} [name] Node name\n\t * @param {Object} [attributes] Attributes hash\n\t * @return {Node}\n\t */\n\tcreate(name, attributes) {\n\t\treturn new Node(name, attributes);\n\t}\n\n\t/**\n\t * Sets given attribute for current node\n\t * @param {String|Object|Attribute} name Attribute name or attribute object\n\t * @param {String} [value] Attribute value\n\t */\n\tsetAttribute(name, value) {\n\t\tconst attr = createAttribute(name, value);\n\t\tconst curAttr = this.getAttribute(name);\n\t\tif (curAttr) {\n\t\t\tthis.replaceAttribute(curAttr, attr);\n\t\t} else {\n\t\t\tthis._attributes.push(attr);\n\t\t}\n\t}\n\n\t/**\n\t * Check if attribute with given name exists in node\n\t * @param  {String} name\n\t * @return {Boolean}\n\t */\n\thasAttribute(name) {\n\t\treturn !!this.getAttribute(name);\n\t}\n\n\t/**\n\t * Returns attribute object by given name\n\t * @param  {String} name\n\t * @return {Attribute}\n\t */\n\tgetAttribute(name) {\n\t\tif (typeof name === 'object') {\n\t\t\tname = name.name;\n\t\t}\n\n\t\tfor (var i = 0; i < this._attributes.length; i++) {\n\t\t\tconst attr = this._attributes[i];\n\t\t\tif (attr.name === name) {\n\t\t\t\treturn attr;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Replaces attribute with new instance\n\t * @param {String|Attribute} curAttribute Current attribute name or instance\n\t * to replace\n\t * @param {String|Object|Attribute} newName New attribute name or attribute object\n\t * @param {String} [newValue] New attribute value\n\t */\n\treplaceAttribute(curAttribute, newName, newValue) {\n\t\tif (typeof curAttribute === 'string') {\n\t\t\tcurAttribute = this.getAttribute(curAttribute);\n\t\t}\n\n\t\tconst ix = this._attributes.indexOf(curAttribute);\n\t\tif (ix !== -1) {\n\t\t\tthis._attributes.splice(ix, 1, createAttribute(newName, newValue));\n\t\t}\n\t}\n\n\t/**\n\t * Removes attribute with given name\n\t * @param  {String|Attribute} attr Atrtibute name or instance\n\t */\n\tremoveAttribute(attr) {\n\t\tif (typeof attr === 'string') {\n\t\t\tattr = this.getAttribute(attr);\n\t\t}\n\n\t\tconst ix = this._attributes.indexOf(attr);\n\t\tif (ix !== -1) {\n\t\t\tthis._attributes.splice(ix, 1);\n\t\t}\n\t}\n\n\t/**\n\t * Removes all attributes from current node\n\t */\n\tclearAttributes() {\n\t\tthis._attributes.length = 0;\n\t}\n\n\t/**\n\t * Adds given class name to class attribute\n\t * @param {String} token Class name token\n\t */\n\taddClass(token) {\n\t\ttoken = normalize(token);\n\n\t\tif (!this.hasAttribute('class')) {\n\t\t\tthis.setAttribute('class', token);\n\t\t} else if (token && !this.hasClass(token)) {\n\t\t\tthis.setAttribute('class', this.classList.concat(token).join(' '));\n\t\t}\n\t}\n\n\t/**\n\t * Check if current node contains given class name\n\t * @param {String} token Class name token\n\t * @return {Boolean}\n\t */\n\thasClass(token) {\n\t\treturn this.classList.indexOf(normalize(token)) !== -1;\n\t}\n\n\t/**\n\t * Removes given class name from class attribute\n\t * @param {String} token Class name token\n\t */\n\tremoveClass(token) {\n\t\ttoken = normalize(token);\n\t\tif (this.hasClass(token)) {\n\t\t\tthis.setAttribute('class', this.classList.filter(name => name !== token).join(' '));\n\t\t}\n\t}\n\n\t/**\n\t * Appends child to current node\n\t * @param {Node} node\n\t */\n\tappendChild(node) {\n\t\tthis.insertAt(node, this.children.length);\n\t}\n\n\t/**\n\t * Inserts given `newNode` before `refNode` child node\n\t * @param {Node} newNode\n\t * @param {Node} refNode\n\t */\n\tinsertBefore(newNode, refNode) {\n\t\tthis.insertAt(newNode, this.children.indexOf(refNode));\n\t}\n\n\t/**\n\t * Insert given `node` at `pos` position of child list\n\t * @param {Node} node\n\t * @param {Number} pos\n\t */\n\tinsertAt(node, pos) {\n\t\tif (pos < 0 || pos > this.children.length) {\n\t\t\tthrow new Error('Unable to insert node: position is out of child list range');\n\t\t}\n\n\t\tconst prev = this.children[pos - 1];\n\t\tconst next = this.children[pos];\n\n\t\tnode.remove();\n\t\tnode.parent = this;\n\t\tthis.children.splice(pos, 0, node);\n\n\t\tif (prev) {\n\t\t\tnode.previous = prev;\n\t\t\tprev.next = node;\n\t\t}\n\n\t\tif (next) {\n\t\t\tnode.next = next;\n\t\t\tnext.previous = node;\n\t\t}\n\t}\n\n\t/**\n\t * Removes given child from current node\n\t * @param {Node} node\n\t */\n\tremoveChild(node) {\n\t\tconst ix = this.children.indexOf(node);\n\t\tif (ix !== -1) {\n\t\t\tthis.children.splice(ix, 1);\n\t\t\tif (node.previous) {\n\t\t\t\tnode.previous.next = node.next;\n\t\t\t}\n\n\t\t\tif (node.next) {\n\t\t\t\tnode.next.previous = node.previous;\n\t\t\t}\n\n\t\t\tnode.parent = node.next = node.previous = null;\n\t\t}\n\t}\n\n\t/**\n\t * Removes current node from its parent\n\t */\n\tremove() {\n\t\tif (this.parent) {\n\t\t\tthis.parent.removeChild(this);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a detached copy of current node\n\t * @param {Boolean} deep Clone node contents as well\n\t * @return {Node}\n\t */\n\tclone(deep) {\n\t\tconst clone = new Node(this.name);\n\t\tclone.value = this.value;\n\t\tclone.selfClosing = this.selfClosing;\n\t\tif (this.repeat) {\n\t\t\tclone.repeat = Object.assign({}, this.repeat);\n\t\t}\n\n\t\tthis._attributes.forEach(attr => clone.setAttribute(attr.clone()));\n\n\t\tif (deep) {\n\t\t\tthis.children.forEach(child => clone.appendChild(child.clone(true)));\n\t\t}\n\n\t\treturn clone;\n\t}\n\n\t/**\n\t * Walks on each descendant node and invokes given `fn` function on it.\n\t * The function receives two arguments: the node itself and its depth level\n\t * from current node. If function returns `false`, it stops walking\n\t * @param {Function} fn\n\t */\n\twalk(fn, _level) {\n\t\t_level = _level || 0;\n\t\tlet ctx = this.firstChild;\n\n\t\twhile (ctx) {\n\t\t\t// in case if context node will be detached during `fn` call\n\t\t\tconst next = ctx.next;\n\n\t\t\tif (fn(ctx, _level) === false || ctx.walk(fn, _level + 1) === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tctx = next;\n\t\t}\n\t}\n\n\t/**\n\t * A helper method for transformation chaining: runs given `fn` function on\n\t * current node and returns the same node\n\t */\n\tuse(fn) {\n\t\tconst args = [this];\n\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\targs.push(arguments[i]);\n\t\t}\n\n\t\tfn.apply(null, args);\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst attrs = this.attributes.map(attr => {\n\t\t\tattr = this.getAttribute(attr.name);\n\t\t\tconst opt = attr.options;\n\t\t\tlet out = `${opt && opt.implied ? '!' : ''}${attr.name || ''}`;\n\t\t\tif (opt && opt.boolean) {\n\t\t\t\tout += '.';\n\t\t\t} else if (attr.value != null) {\n\t\t\t\tout += `=\"${attr.value}\"`;\n\t\t\t}\n\t\t\treturn out;\n\t\t});\n\n\t\tlet out = `${this.name || ''}`;\n\t\tif (attrs.length) {\n\t\t\tout += `[${attrs.join(' ')}]`;\n\t\t}\n\n\t\tif (this.value != null) {\n\t\t\tout += `{${this.value}}`;\n\t\t}\n\n\t\tif (this.selfClosing) {\n\t\t\tout += '/';\n\t\t}\n\n\t\tif (this.repeat) {\n\t\t\tout += `*${this.repeat.count ? this.repeat.count : ''}`;\n\t\t\tif (this.repeat.value != null) {\n\t\t\t\tout += `@${this.repeat.value}`;\n\t\t\t}\n\t\t}\n\n\t\treturn out;\n\t}\n}\n\n/**\n * Attribute factory\n * @param  {String|Attribute|Object} name  Attribute name or attribute descriptor\n * @param  {*} value Attribute value\n * @return {Attribute}\n */\nfunction createAttribute(name, value) {\n\tif (name instanceof Attribute) {\n\t\treturn name;\n\t}\n\n\tif (typeof name === 'string') {\n\t\treturn new Attribute(name, value);\n\t}\n\n\tif (name && typeof name === 'object') {\n\t\treturn new Attribute(name.name, name.value, name.options);\n\t}\n}\n\n/**\n * @param  {String} str\n * @return {String}\n */\nfunction normalize(str) {\n\treturn String(str).trim();\n}\n\nfunction uniqueClass(item, i, arr) {\n\treturn item && arr.indexOf(item) === i;\n}\n\nexport default Node;\n","/**\n * A streaming, character code-based string reader\n */\nclass StreamReader {\n\tconstructor(string, start, end) {\n\t\tif (end == null && typeof string === 'string') {\n\t\t\tend = string.length;\n\t\t}\n\n\t\tthis.string = string;\n\t\tthis.pos = this.start = start || 0;\n\t\tthis.end = end;\n\t}\n\n\t/**\n\t * Returns true only if the stream is at the end of the file.\n\t * @returns {Boolean}\n\t */\n\teof() {\n\t\treturn this.pos >= this.end;\n\t}\n\n\t/**\n\t * Creates a new stream instance which is limited to given `start` and `end`\n\t * range. E.g. its `eof()` method will look at `end` property, not actual\n\t * stream end\n\t * @param  {Point} start\n\t * @param  {Point} end\n\t * @return {StreamReader}\n\t */\n\tlimit(start, end) {\n\t\treturn new this.constructor(this.string, start, end);\n\t}\n\n\t/**\n\t * Returns the next character code in the stream without advancing it.\n\t * Will return NaN at the end of the file.\n\t * @returns {Number}\n\t */\n\tpeek() {\n\t\treturn this.string.charCodeAt(this.pos);\n\t}\n\n\t/**\n\t * Returns the next character in the stream and advances it.\n\t * Also returns <code>undefined</code> when no more characters are available.\n\t * @returns {Number}\n\t */\n\tnext() {\n\t\tif (this.pos < this.string.length) {\n\t\t\treturn this.string.charCodeAt(this.pos++);\n\t\t}\n\t}\n\n\t/**\n\t * `match` can be a character code or a function that takes a character code\n\t * and returns a boolean. If the next character in the stream 'matches'\n\t * the given argument, it is consumed and returned.\n\t * Otherwise, `false` is returned.\n\t * @param {Number|Function} match\n\t * @returns {Boolean}\n\t */\n\teat(match) {\n\t\tconst ch = this.peek();\n\t\tconst ok = typeof match === 'function' ? match(ch) : ch === match;\n\n\t\tif (ok) {\n\t\t\tthis.next();\n\t\t}\n\n\t\treturn ok;\n\t}\n\n\t/**\n\t * Repeatedly calls <code>eat</code> with the given argument, until it\n\t * fails. Returns <code>true</code> if any characters were eaten.\n\t * @param {Object} match\n\t * @returns {Boolean}\n\t */\n\teatWhile(match) {\n\t\tconst start = this.pos;\n\t\twhile (!this.eof() && this.eat(match)) {}\n\t\treturn this.pos !== start;\n\t}\n\n\t/**\n\t * Backs up the stream n characters. Backing it up further than the\n\t * start of the current token will cause things to break, so be careful.\n\t * @param {Number} n\n\t */\n\tbackUp(n) {\n\t\tthis.pos -= (n || 1);\n\t}\n\n\t/**\n\t * Get the string between the start of the current token and the\n\t * current stream position.\n\t * @returns {String}\n\t */\n\tcurrent() {\n\t\treturn this.substring(this.start, this.pos);\n\t}\n\n\t/**\n\t * Returns substring for given range\n\t * @param  {Number} start\n\t * @param  {Number} [end]\n\t * @return {String}\n\t */\n\tsubstring(start, end) {\n\t\treturn this.string.slice(start, end);\n\t}\n\n\t/**\n\t * Creates error object with current stream state\n\t * @param {String} message\n\t * @return {Error}\n\t */\n\terror(message) {\n\t\tconst err = new Error(`${message} at char ${this.pos + 1}`);\n\t\terr.originalMessage = message;\n\t\terr.pos = this.pos;\n\t\terr.string = this.string;\n\t\treturn err;\n\t}\n}\n\nexport default StreamReader;\n","import { isNumber, eatQuoted, isWhiteSpace, isSpace, isQuote, isAlphaNumeric } from '@emmetio/stream-reader-utils';\nimport Node from '@emmetio/node';\nimport StreamReader from '@emmetio/stream-reader';\n\nconst ASTERISK = 42; // *\n\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n * @param  {StringReader} stream\n * @return {Object}\n */\nfunction consumeRepeat(stream) {\n\tif (stream.eat(ASTERISK)) {\n\t\tstream.start = stream.pos;\n\n\t\t// XXX think about extending repeat syntax with through numbering\n\t\treturn { count: stream.eatWhile(isNumber) ? +stream.current() : null };\n\t}\n}\n\nconst opt = { throws: true };\n\n/**\n * Consumes quoted literal from current stream position and returns it’s inner,\n * unquoted, value\n * @param  {StringReader} stream\n * @return {String} Returns `null` if unable to consume quoted value from current\n * position\n */\nfunction consumeQuoted(stream) {\n\tif (eatQuoted(stream, opt)) {\n\t\treturn stream.current().slice(1, -1);\n\t}\n}\n\nconst TEXT_START = 123; // {\nconst TEXT_END = 125; // }\nconst ESCAPE =  92; // \\ character\n\n/**\n * Consumes text node `{...}` from stream\n * @param  {StreamReader} stream\n * @return {String} Returns consumed text value (without surrounding braces) or\n * `null` if there’s no text at starting position\n */\nfunction consumeText(stream) {\n\t// NB using own implementation instead of `eatPair()` from @emmetio/stream-reader-utils\n\t// to disable quoted value consuming\n\tconst start = stream.pos;\n\n\tif (stream.eat(TEXT_START)) {\n\t\tlet stack = 1, ch;\n\t\tlet result = '';\n\t\tlet offset = stream.pos;\n\n\t\twhile (!stream.eof()) {\n\t\t\tch = stream.next();\n\t\t\tif (ch === TEXT_START) {\n\t\t\t\tstack++;\n\t\t\t} else if (ch === TEXT_END) {\n\t\t\t\tstack--;\n\t\t\t\tif (!stack) {\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn result + stream.substring(offset, stream.pos - 1);\n\t\t\t\t}\n\t\t\t} else if (ch === ESCAPE) {\n\t\t\t\tch = stream.next();\n\t\t\t\tif (ch === TEXT_START || ch === TEXT_END) {\n\t\t\t\t\tresult += stream.substring(offset, stream.pos - 2) + String.fromCharCode(ch);\n\t\t\t\t\toffset = stream.pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we’re here then paired character can’t be consumed\n\t\tstream.pos = start;\n\t\tthrow stream.error(`Unable to find closing ${String.fromCharCode(TEXT_END)} for text start`);\n\t}\n\n\treturn null;\n}\n\nconst EXCL       = 33; // .\nconst DOT        = 46; // .\nconst EQUALS     = 61; // =\nconst ATTR_OPEN  = 91; // [\nconst ATTR_CLOSE = 93; // ]\n\nconst reAttributeName = /^\\!?[\\w\\-:\\$@]+\\.?$/;\n\n/**\n * Consumes attributes defined in square braces from given stream.\n * Example:\n * [attr col=3 title=\"Quoted string\" selected. support={react}]\n * @param {StringReader} stream\n * @returns {Array} Array of consumed attributes\n */\nfunction consumeAttributes(stream) {\n\tif (!stream.eat(ATTR_OPEN)) {\n\t\treturn null;\n\t}\n\n\tconst result = [];\n\tlet token, attr;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isWhiteSpace);\n\n\t\tif (stream.eat(ATTR_CLOSE)) {\n\t\t\treturn result; // End of attribute set\n\t\t} else if ((token = consumeQuoted(stream)) != null) {\n\t\t\t// Consumed quoted value: anonymous attribute\n\t\t\tresult.push({\n\t\t\t\tname: null,\n\t\t\t\tvalue: token\n\t\t\t});\n\t\t} else if (eatUnquoted(stream)) {\n\t\t\t// Consumed next word: could be either attribute name or unquoted default value\n\t\t\ttoken = stream.current();\n\t\t\tif (!reAttributeName.test(token)) {\n\t\t\t\t// anonymous attribute\n\t\t\t\tresult.push({ name: null, value: token });\n\t\t\t} else {\n\t\t\t\t// Looks like a regular attribute\n\t\t\t\tattr = parseAttributeName(token);\n\t\t\t\tresult.push(attr);\n\n\t\t\t\tif (stream.eat(EQUALS)) {\n\t\t\t\t\t// Explicitly defined value. Could be a word, a quoted string\n\t\t\t\t\t// or React-like expression\n\t\t\t\t\tif ((token = consumeQuoted(stream)) != null) {\n\t\t\t\t\t\tattr.value = token;\n\t\t\t\t\t} else if ((token = consumeText(stream)) != null) {\n\t\t\t\t\t\tattr.value = token;\n\t\t\t\t\t\tattr.options = {\n\t\t\t\t\t\t\tbefore: '{',\n\t\t\t\t\t\t\tafter: '}'\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (eatUnquoted(stream)) {\n\t\t\t\t\t\tattr.value = stream.current();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow stream.error('Expected attribute name');\n\t\t}\n\t}\n\n\tthrow stream.error('Expected closing \"]\" brace');\n}\n\nfunction parseAttributeName(name) {\n\tconst options = {};\n\n\t// If a first character in attribute name is `!` — it’s an implied\n\t// default attribute\n\tif (name.charCodeAt(0) === EXCL) {\n\t\tname = name.slice(1);\n\t\toptions.implied = true;\n\t}\n\n\t// Check for last character: if it’s a `.`, user wants boolean attribute\n\tif (name.charCodeAt(name.length - 1) === DOT) {\n\t\tname = name.slice(0, name.length - 1);\n\t\toptions.boolean = true;\n\t}\n\n\tconst attr = { name };\n\tif (Object.keys(options).length) {\n\t\tattr.options = options;\n\t}\n\n\treturn attr;\n}\n\n/**\n * Eats token that can be an unquoted value from given stream\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatUnquoted(stream) {\n\tconst start = stream.pos;\n\tif (stream.eatWhile(isUnquoted)) {\n\t\tstream.start = start;\n\t\treturn true;\n\t}\n}\n\nfunction isUnquoted(code) {\n\treturn !isSpace(code) && !isQuote(code)\n\t\t&& code !== ATTR_OPEN && code !== ATTR_CLOSE && code !== EQUALS;\n}\n\nconst HASH    = 35; // #\nconst DOT$1     = 46; // .\nconst SLASH   = 47; // /\n\n/**\n * Consumes a single element node from current abbreviation stream\n * @param  {StringReader} stream\n * @return {Node}\n */\nfunction consumeElement(stream) {\n\t// consume element name, if provided\n\tconst start = stream.pos;\n\tconst node = new Node(eatName(stream));\n\tlet next;\n\n\twhile (!stream.eof()) {\n\t\tif (stream.eat(DOT$1)) {\n\t\t\tnode.addClass(eatName(stream));\n\t\t} else if (stream.eat(HASH)) {\n\t\t\tnode.setAttribute('id', eatName(stream));\n\t\t} else if (stream.eat(SLASH)) {\n\t\t\t// A self-closing indicator must be at the end of non-grouping node\n\t\t\tif (node.isGroup) {\n\t\t\t\tstream.backUp(1);\n\t\t\t\tthrow stream.error('Unexpected self-closing indicator');\n\t\t\t}\n\t\t\tnode.selfClosing = true;\n\t\t\tif (next = consumeRepeat(stream)) {\n\t\t\t\tnode.repeat = next;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (next = consumeAttributes(stream)) {\n\t\t\tfor (let i = 0, il = next.length; i < il; i++) {\n\t\t\t\tnode.setAttribute(next[i]);\n\t\t\t}\n\t\t} else if ((next = consumeText(stream)) !== null) {\n\t\t\tnode.value = next;\n\t\t} else if (next = consumeRepeat(stream)) {\n\t\t\tnode.repeat = next;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === stream.pos) {\n\t\tthrow stream.error(`Unable to consume abbreviation node, unexpected ${stream.peek()}`);\n\t}\n\n\treturn node;\n}\n\nfunction eatName(stream) {\n\tstream.start = stream.pos;\n\tstream.eatWhile(isName);\n\treturn stream.current();\n}\n\nfunction isName(code) {\n\treturn isAlphaNumeric(code)\n\t\t|| code === 45 /* - */\n\t\t|| code === 58 /* : */\n\t\t|| code === 36 /* $ */\n\t\t|| code === 64 /* @ */\n\t\t|| code === 33 /* ! */\n\t\t|| code === 95 /* _ */\n\t\t|| code === 37 /* % */;\n}\n\nconst GROUP_START = 40; // (\nconst GROUP_END   = 41; // )\nconst OP_SIBLING  = 43; // +\nconst OP_CHILD    = 62; // >\nconst OP_CLIMB    = 94; // ^\n\n/**\n * Parses given string into a node tree\n * @param  {String} str Abbreviation to parse\n * @return {Node}\n */\nfunction parse(str) {\n\tconst stream = new StreamReader(str.trim());\n\tconst root = new Node();\n\tlet ctx = root, groupStack = [], ch;\n\n\twhile (!stream.eof()) {\n\t\tch = stream.peek();\n\n\t\tif (ch === GROUP_START) { // start of group\n\t\t\t// The grouping node should be detached to properly handle\n\t\t\t// out-of-bounds `^` operator. Node will be attached right on group end\n\t\t\tconst node = new Node();\n\t\t\tgroupStack.push([node, ctx, stream.pos]);\n\t\t\tctx = node;\n\t\t\tstream.next();\n\t\t\tcontinue;\n\t\t} else if (ch === GROUP_END) { // end of group\n\t\t\tconst lastGroup = groupStack.pop();\n\t\t\tif (!lastGroup) {\n\t\t\t\tthrow stream.error('Unexpected \")\" group end');\n\t\t\t}\n\n\t\t\tconst node = lastGroup[0];\n\t\t\tctx = lastGroup[1];\n\t\t\tstream.next();\n\n\t\t\t// a group can have a repeater\n\t\t\tif (node.repeat = consumeRepeat(stream)) {\n\t\t\t\tctx.appendChild(node);\n\t\t\t} else {\n\t\t\t\t// move all children of group into parent node\n\t\t\t\twhile (node.firstChild) {\n\t\t\t\t\tctx.appendChild(node.firstChild);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// for convenience, groups can be joined with optional `+` operator\n\t\t\tstream.eat(OP_SIBLING);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst node = consumeElement(stream);\n\t\tctx.appendChild(node);\n\n\t\tif (stream.eof()) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (stream.peek()) {\n\t\t\tcase OP_SIBLING:\n\t\t\t\tstream.next();\n\t\t\t\tcontinue;\n\n\t\t\tcase OP_CHILD:\n\t\t\t\tstream.next();\n\t\t\t\tctx = node;\n\t\t\t\tcontinue;\n\n\t\t\tcase OP_CLIMB:\n\t\t\t\t// it’s perfectly valid to have multiple `^` operators\n\t\t\t\twhile (stream.eat(OP_CLIMB)) {\n\t\t\t\t\tctx = ctx.parent || ctx;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (groupStack.length) {\n\t\tstream.pos = groupStack.pop()[2];\n\t\tthrow stream.error('Expected group close');\n\t}\n\n\treturn root;\n}\n\n/**\n * Parses given abbreviation and un-rolls it into a full tree: recursively\n * replaces repeated elements with actual nodes\n * @param  {String} abbr\n * @return {Node}\n */\nfunction index(abbr) {\n\tconst tree = parse(abbr);\n\ttree.walk(unroll);\n\treturn tree;\n}\n\nfunction unroll(node) {\n\tif (!node.repeat || !node.repeat.count) {\n\t\treturn;\n\t}\n\n\tconst parent = node.parent;\n\tlet ix = parent.children.indexOf(node);\n\n\tfor (let i = 0; i < node.repeat.count; i++) {\n\t\tconst clone = node.clone(true);\n\t\tclone.repeat.value = i + 1;\n\t\tclone.walk(unroll);\n\n\t\tif (clone.isGroup) {\n\t\t\twhile (clone.children.length > 0) {\n\t\t\t\tclone.firstChild.repeat = clone.repeat;\n\t\t\t\tparent.insertAt(clone.firstChild, ix++);\n\t\t\t}\n\t\t} else {\n\t\t\tparent.insertAt(clone, ix++);\n\t\t}\n\t}\n\n\tnode.parent.removeChild(node);\n}\n\nexport default index;\n//# sourceMappingURL=abbreviation.es.js.map\n","import parse from '@emmetio/abbreviation';\n\n/**\n * For every node in given `tree`, finds matching snippet from `registry` and\n * resolves it into a parsed abbreviation. Resolved node is then updated or\n * replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attribues and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n *\n * @param  {Node} tree                 Parsed Emmet abbreviation\n * @param  {SnippetsRegistry} registry Registry with all available snippets\n * @return {Node} Updated tree\n */\n\nvar index = function(tree, registry) {\n    tree.walk(node => resolveNode(node, registry));\n    return tree;\n};\n\nfunction resolveNode(node, registry) {\n    const stack = new Set();\n    const resolve = node => {\n        const snippet = registry.resolve(node.name);\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.has(snippet)) {\n            return;\n        }\n\n        // In case if matched snippet is a function, pass control into it\n        if (typeof snippet.value === 'function') {\n            return snippet.value(node, registry, resolve);\n        }\n\n        const tree = parse(snippet.value);\n\n        stack.add(snippet);\n        tree.walk(resolve);\n        stack.delete(snippet);\n\n        // move current node contents into new tree\n        const childTarget = findDeepestNode(tree);\n        merge(childTarget, node);\n\n        while (tree.firstChild) {\n            node.parent.insertBefore(tree.firstChild, node);\n        }\n\n        childTarget.parent.insertBefore(node, childTarget);\n        childTarget.remove();\n    };\n\n    resolve(node);\n}\n\n/**\n * Adds data from first node into second node and returns it\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction merge(from, to) {\n    to.name = from.name;\n\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n\n    if (from.value != null) {\n        to.value = from.value;\n    }\n\n    if (from.repeat) {\n        to.repeat = Object.assign({}, from.repeat);\n    }\n\n    return mergeAttributes(from, to);\n}\n\n/**\n * Transfer attributes from first element to second one and preserve first\n * element’s attributes order\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction mergeAttributes(from, to) {\n    mergeClassNames(from, to);\n\n    // It’s important to preserve attributes order: ones in `from` have higher\n    // pripority than in `to`. Collect attributes in map in order they should\n    // appear in `to`\n    const attrMap = new Map();\n\n    let attrs = from.attributes;\n    for (let i = 0; i < attrs.length; i++) {\n        attrMap.set(attrs[i].name, attrs[i].clone());\n    }\n\n    attrs = to.attributes.slice();\n    for (let i = 0, attr, a; i < attrs.length; i++) {\n        attr = attrs[i];\n        if (attrMap.has(attr.name)) {\n            a = attrMap.get(attr.name);\n            a.value = attr.value;\n\n            // If user explicitly wrote attribute in abbreviation, it’s no longer\n            // implied and should be outputted even if value is empty\n            if (a.options.implied) {\n                a.options.implied = false;\n            }\n        } else {\n            attrMap.set(attr.name, attr);\n        }\n\n        to.removeAttribute(attr);\n    }\n\n    const newAttrs = Array.from(attrMap.values());\n    for (let i = 0; i < newAttrs.length; i++) {\n        to.setAttribute(newAttrs[i]);\n    }\n\n    return to;\n}\n\n/**\n * Adds class names from first node to second one\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction mergeClassNames(from, to) {\n    const classNames = from.classList;\n    for (let i = 0; i < classNames.length; i++) {\n        to.addClass(classNames[i]);\n    }\n\n    return to;\n}\n\n/**\n * Finds node which is the deepest for in current node or node iteself.\n * @param  {Node} node\n * @return {Node}\n */\nfunction findDeepestNode(node) {\n\twhile (node.children.length) {\n\t\tnode = node.children[node.children.length - 1];\n\t}\n\n\treturn node;\n}\n\nexport default index;\n","const inlineElements = new Set('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(','));\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\n\n/**\n * Returns best child node name for given parent node name\n * @param  {String} parentName Name of parent node\n * @return {String}\n */\nfunction resolveImplicitName(parentName) {\n    parentName = (parentName || '').toLowerCase();\n    return elementMap[parentName]\n        || (inlineElements.has(parentName) ? 'span' : 'div');\n}\n\nexport default resolveImplicitName;\n","import resolveImplicitTag from '@emmetio/implicit-tag';\n\n/**\n * Adds missing tag names for given tree depending on node’s parent name\n */\nvar implicitTags = function(tree) {\n    tree.walk(node => {\n        // resolve only nameless nodes without content\n        if (node.name == null && node.attributes.length) {\n            node.name = resolveImplicitTag(node.parent.name);\n        }\n    });\n    return tree;\n};\n\n/**\n * Locates all occurances of given `token` which are not escaped (e.g. are not\n * preceded with `\\`) given in `str`\n * @param  {String} str\n * @return {Array}  Array of token ranges\n */\nfunction findUnescapedTokens(str, token) {\n    const result = new Set();\n    const tlen = token.length;\n\n    // 1. Find all occurances of tokens\n    let pos = 0;\n    while ((pos = str.indexOf(token, pos)) !== -1) {\n        result.add(pos);\n        pos += tlen;\n    }\n\n    if (result.size) {\n        // 2. Remove ones that escaped\n        let pos = 0;\n        const len = str.length;\n\n        while (pos < len) {\n            if (str[pos++] === '\\\\') {\n                result.delete(pos++);\n            }\n        }\n    }\n\n    return Array.from(result).map(ix => range(ix, tlen));\n}\n\n/**\n * Replaces `ranges`, generated by `range()` function, with given `value` in `str`\n * @param  {String} str    Where to replace ranges\n * @param  {Array} ranges Ranes, created by `range()` function\n * @param  {String|Function} value  Replacement value. If it’s a function, it\n * will take a range value as argument and should return a new string\n * @return {String}\n */\nfunction replaceRanges(str, ranges, value) {\n\t// should walk from the end of array to keep ranges valid after replacement\n\tfor (let i = ranges.length - 1; i >= 0; i--) {\n\t\tconst r = ranges[i];\n\n        let offset = 0;\n        let offsetLength = 0;\n        let descendingOrder = false;\n\n        if (str.substr(r[0] + r[1], 1) === '@'){\n            if (str.substr(r[0] + r[1] + 1, 1) === '-') {\n                descendingOrder = true;\n            } \n            const matches = str.substr(r[0] + r[1] + 1 + Number(descendingOrder)).match(/^(\\d+)/);\n            if (matches) {\n                offsetLength = matches[1].length + 1 + Number(descendingOrder);\n                offset = parseInt(matches[1]) - 1;\n            } else {\n                offsetLength = 2;\n            }\n        }\n\n\t\tstr = str.substring(0, r[0])\n\t\t\t+ (typeof value === 'function' ? value(str.substr(r[0], r[1]), offset, descendingOrder) : value)\n\t\t\t+ str.substring(r[0] + r[1] + offsetLength);\n\t}\n\n\treturn str;\n}\n\nfunction range(start, length) {\n    return [start, length];\n}\n\nconst numberingToken = '$';\n\n/**\n * Numbering of expanded abbreviation: finds all nodes with `$` in value\n * or attributes and replaces its occurances with repeater value\n */\nvar applyNumbering = function(tree) {\n    tree.walk(applyNumbering$1);\n    return tree;\n};\n\n/**\n * Applies numbering for given node: replaces occurances of numbering token\n * in node’s name, content and attributes\n * @param  {Node} node\n * @return {Node}\n */\nfunction applyNumbering$1(node) {\n    const repeater = findRepeater(node);\n\n    if (repeater && repeater.value != null) {\n        // NB replace numbering in nodes with explicit repeater only:\n        // it solves issues with abbreviations like `xsl:if[test=$foo]` where\n        // `$foo` is preferred output\n        const value = repeater.value;\n        const count = repeater.count;\n\n        node.name = replaceNumbering(node.name, value, count);\n        node.value = replaceNumbering(node.value, value, count);\n        node.attributes.forEach(attr => {\n            const copy = node.getAttribute(attr.name).clone();\n            copy.name = replaceNumbering(attr.name, value, count);\n            copy.value = replaceNumbering(attr.value, value, count);\n            node.replaceAttribute(attr.name, copy);\n        });\n    }\n\n    return node;\n}\n\n/**\n * Returns repeater object for given node\n * @param  {Node} node\n * @return {Object}\n */\nfunction findRepeater(node) {\n    while (node) {\n        if (node.repeat) {\n            return node.repeat;\n        }\n\n        node = node.parent;\n    }\n}\n\n/**\n * Replaces numbering in given string\n * @param  {String} str\n * @param  {Number} value\n * @return {String}\n */\nfunction replaceNumbering(str, value, count) {\n    // replace numbering in strings only: skip explicit wrappers that could\n    // contain unescaped numbering tokens\n    if (typeof str === 'string') {\n        const ranges = getNumberingRanges(str);\n        return replaceNumberingRanges(str, ranges, value, count);\n    }\n\n    return str;\n}\n\n/**\n * Returns numbering ranges, e.g. ranges of `$` occurances, in given string.\n * Multiple adjacent ranges are combined\n * @param  {String} str\n * @return {Array}\n */\nfunction getNumberingRanges(str) {\n    return findUnescapedTokens(str || '', numberingToken)\n    .reduce((out, range$$1) => {\n        // skip ranges that actually belongs to output placeholder or tabstops\n        if (!/[#{]/.test(str[range$$1[0] + 1] || '')) {\n            const lastRange = out[out.length - 1];\n            if (lastRange && lastRange[0] + lastRange[1] === range$$1[0]) {\n                lastRange[1] += range$$1[1];\n            } else {\n                out.push(range$$1);\n            }\n        }\n\n        return out;\n    }, []);\n}\n\n/**\n * @param  {String} str\n * @param  {Array} ranges\n * @param  {Number} value\n * @return {String}\n */\nfunction replaceNumberingRanges(str, ranges, value, count) {\n    const replaced = replaceRanges(str, ranges, (token, offset, descendingOrder) => {\n    let _value = descendingOrder ? String(offset + count - value + 1) : String(value + offset);\n        // pad values for multiple numbering tokens, e.g. 3 for $$$ becomes 003\n        while (_value.length < token.length) {\n            _value = '0' + _value;\n        }\n        return _value;\n    });\n\n    // unescape screened numbering tokens\n    return unescapeString(replaced);\n}\n\n/**\n * Unescapes characters, screened with `\\`, in given string\n * @param  {String} str\n * @return {String}\n */\nfunction unescapeString(str) {\n    let i = 0, result = '';\n    const len = str.length;\n\n    while (i < len) {\n        const ch = str[i++];\n        result += (ch === '\\\\') ? (str[i++] || '') : ch;\n    }\n\n    return result;\n}\n\n/** Placeholder for inserted content */\nconst placeholder = '$#';\n\n/** Placeholder for caret */\nconst caret = '|';\n\nconst reUrl = /^((?:https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/;\nconst reEmail = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/;\nconst reProto = /^([a-z]+:)?\\/\\//i;\n\n/**\n * Inserts content into node with implicit repeat count: this node is then\n * duplicated for each content item and content itself is inserted either into\n * deepest child or instead of a special token.\n *\n * This method uses two distinct steps: `prepare()` and `insert()` since most\n * likely these steps will be used separately to properly insert content\n * with unescaped `$` numbering markers.\n *\n * @param {Node} tree Parsed abbreviation\n * @param {String[]} content Array of content items to insert\n * @return {Node}\n */\n/**\n * Finds nodes with implicit repeat and creates `amount` copies of it in tree\n * @param  {Node} tree\n * @param  {Number} amount\n * @return {Node}\n */\nfunction prepare(tree, amount) {\n    amount = amount || 1;\n    tree.walk(node => {\n        if (node.repeat && node.repeat.count === null) {\n            for (let i = 0; i < amount; i++) {\n                const clone = node.clone(true);\n                clone.repeat.implicit = true;\n                clone.repeat.count = amount;\n                clone.repeat.value = i + 1;\n                clone.repeat.index = i;\n                node.parent.insertBefore(clone, node);\n            }\n\n            node.remove();\n        }\n    });\n\n    return tree;\n}\n\n/**\n * Inserts content into implicitly repeated nodes, created by `prepare()` method\n * @param  {Node} tree\n * @param  {String[]} content\n * @return {Node}\n */\nfunction insert(tree, content) {\n    if (Array.isArray(content) && content.length) {\n        let updated = false;\n        tree.walk(node => {\n            if (node.repeat && node.repeat.implicit) {\n                updated = true;\n                insertContent(node, content[node.repeat.index]);\n            }\n        });\n\n        if (!updated) {\n            // no node with implicit repeat was found, insert content as\n            // deepest child\n            setNodeContent(findDeepestNode(tree), content.join('\\n'));\n        }\n    }\n\n    return tree;\n}\n\n/**\n * Inserts `content` into given `node`: either replaces output placeholders\n * or inserts it into deepest child node\n * @param  {Node} node\n * @param  {String} content\n * @return {Node}\n */\nfunction insertContent(node, content) {\n\tlet inserted = insertContentIntoPlaceholder(node, content);\n\tnode.walk(child => inserted |= insertContentIntoPlaceholder(child, content));\n\n\tif (!inserted) {\n\t\t// no placeholders were found in node, insert content into deepest child\n\t\tsetNodeContent(findDeepestNode(node), content);\n\t}\n\n\treturn node;\n}\n\n/**\n * Inserts given `content` into placeholders for given `node`. Placeholders\n * might be available in attribute values and node content\n * @param  {Node} node\n * @param  {String} content\n * @return {Boolean} Returns `true` if placeholders were found and replaced in node\n */\nfunction insertContentIntoPlaceholder(node, content) {\n\tconst state = {replaced: false};\n\n\tnode.value = replacePlaceholder(node.value, content, state);\n\tnode.attributes.forEach(attr => {\n\t\tif (attr.value) {\n\t\t\tnode.setAttribute(attr.name, replacePlaceholder(attr.value, content, state));\n\t\t}\n\t});\n\n\treturn state.replaced;\n}\n\n/**\n * Replaces all placeholder occurances in given `str` with `value`\n * @param  {String} str\n * @param  {String} value\n * @param  {Object} [_state] If provided, set `replaced` property of given\n * object to `true` if placeholder was found and replaced\n * @return {String}\n */\nfunction replacePlaceholder(str, value, _state) {\n\tif (typeof str === 'string') {\n\t\tconst ranges = findUnescapedTokens(str, placeholder);\n\t\tif (ranges.length) {\n\t\t\tif (_state) {\n\t\t\t\t_state.replaced = true;\n\t\t\t}\n\n\t\t\tstr = replaceRanges(str, ranges, value);\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/**\n * Finds node which is the deepest for in current node or node iteself.\n * @param  {Node} node\n * @return {Node}\n */\nfunction findDeepestNode(node) {\n\twhile (node.children.length) {\n\t\tnode = node.children[node.children.length - 1];\n\t}\n\n\treturn node;\n}\n\n/**\n * Updates content of given node\n * @param {Node} node\n * @param {String} content\n */\nfunction setNodeContent(node, content) {\n\t// find caret position and replace it with content, if possible\n\tif (node.value) {\n\t\tconst ranges = findUnescapedTokens(node.value, caret);\n\t\tif (ranges.length) {\n\t\t\tnode.value = replaceRanges(node.value, ranges, content);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (node.name.toLowerCase() === 'a' || node.hasAttribute('href')) {\n\t\t// special case: inserting content into `<a>` tag\n\t\tif (reUrl.test(content)) {\n\t\t\tnode.setAttribute('href', (reProto.test(content) ? '' : 'http://') + content);\n\t\t} else if (reEmail.test(content)) {\n\t\t\tnode.setAttribute('href', 'mailto:' + content);\n\t\t}\n\t}\n\n\tnode.value = content;\n}\n\nconst defaultOptions = {\n\telement: '__',\n\tmodifier: '_'\n};\n\nconst reElement  = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = className => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = className => /^[a-z]/i.test(className);\n\n/**\n * BEM transformer: updates class names written as `-element` and\n * `_modifier` into full class names as described in BEM specs. Also adds missing\n * class names: fir example, if node contains `.block_modifier` class, ensures\n * that element contains `.block` class as well\n */\nvar bem = function(tree, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\n\ttree.walk(node => expandClassNames(node, options));\n\n\tconst lookup = createBlockLookup(tree);\n\ttree.walk(node => expandShortNotation(node, lookup, options));\n\n\treturn tree;\n};\n\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n * @param  {Node} node\n * @param  {Object} options\n * @return {Set}\n */\nfunction expandClassNames(node, options) {\n\tconst classNames = node.classList.reduce((out, cl) => {\n\t\t// remove all modifiers and element prefixes from class name to get a base element name\n\t\tconst ix = cl.indexOf('_');\n\t\tif (ix > 0 && !cl.startsWith('-')) {\n\t\t\tout.add(cl.slice(0, ix));\n\t\t    out.add(cl.slice(ix));\n\t\t\treturn out;\n\t\t}\n\n\t\treturn out.add(cl);\n\t}, new Set());\n\n\tif (classNames.size) {\n\t\tnode.setAttribute('class', Array.from(classNames).join(' '));\n\t}\n}\n\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n * @param  {Node} node      Parsed Emmet abbreviation node\n * @param  {Map} lookup     BEM block name lookup\n * @param  {Object} options\n */\nfunction expandShortNotation(node, lookup, options) {\n\tconst classNames = node.classList.reduce((out, cl) => {\n\t\tlet prefix, m;\n\t\tconst originalClass = cl;\n\n\t\t// parse element definition (could be only one)\n\t\tif (m = cl.match(reElement)) {\n\t\t\tprefix = getBlockName(node, lookup, m[1]) + options.element + m[2];\n\t\t\tout.add(prefix);\n\t\t\tcl = cl.slice(m[0].length);\n\t\t}\n\n\t\t// parse modifiers definitions \n\t\tif (m = cl.match(reModifier)) {\n\t\t\tif (!prefix) {\n\t\t\t\tprefix = getBlockName(node, lookup, m[1]);\n\t\t\t\tout.add(prefix);\n\t\t\t}\n\n\t\t\tout.add(`${prefix}${options.modifier}${m[2]}`);\n\t\t\tcl = cl.slice(m[0].length);\n\t\t}\n\n\t\tif (cl === originalClass) {\n\t\t\t// class name wasn’t modified: it’s not a BEM-specific class,\n\t\t\t// add it as-is into output\n\t\t\tout.add(originalClass);\n\t\t}\n\n\t\treturn out;\n\t}, new Set());\n\n\tconst arrClassNames = Array.from(classNames).filter(Boolean);\n\tif (arrClassNames.length) {\n\t\tnode.setAttribute('class', arrClassNames.join(' '));\n\t}\n}\n\n/**\n * Creates block name lookup for each node in given tree, e.g. finds block\n * name explicitly for each node\n * @param  {Node} tree\n * @return {Map}\n */\nfunction createBlockLookup(tree) {\n\tconst lookup = new Map();\n\n\ttree.walk(node => {\n\t\tconst classNames = node.classList;\n\t\tif (classNames.length) {\n\t\t\t// guess best block name from class or use parent’s block name\n\t\t\tlookup.set(node,\n\t\t\t\tfind(classNames, blockCandidates1)\n\t\t\t\t|| find(classNames, blockCandidates2)\n\t\t\t\t|| lookup.get(node.parent)\n\t\t\t);\n\t\t}\n\t});\n\n\treturn lookup;\n}\n\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n * @param  {Node} node\n * @param  {Map} lookup\n * @param  {String} prefix\n * @return {String}\n */\nfunction getBlockName(node, lookup, prefix) {\n\tlet depth = prefix.length > 1 ? prefix.length : 0;\n\n\t// NB don’t walk up to root node, stay at first root child in case of\n\t// too deep prefix\n\twhile (node.parent && node.parent.parent && depth--) {\n\t\tnode = node.parent;\n\t}\n\n\treturn lookup.get(node) || '';\n}\n\nfunction find(arr, filter) {\n\tfor(let i = 0; i < arr.length; i++){\n\t\tif (reElement.test(arr[i]) || reModifier.test(arr[i])) {\n\t\t\tbreak;\n\t\t}\n\t\tif (filter(arr[i])) {\n\t\t\treturn arr[i];\n\t\t}\n\t}\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nvar jsx = function(tree) {\n\ttree.walk(node => {\n\t\treplace(node, 'class', 'className');\n\t\treplace(node, 'for', 'htmlFor');\n\t});\n\treturn tree;\n};\n\nfunction replace(node, oldName, newName) {\n\tlet attr = node.getAttribute(oldName);\n\tif (attr) {\n\t\tattr.name = newName;\n\t}\n}\n\nconst reSupporterNames = /^xsl:(variable|with\\-param)$/i;\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nvar xsl = function(tree) {\n\ttree.walk(node => {\n\t\tif (reSupporterNames.test(node.name || '') && (node.children.length || node.value)) {\n\t\t\tnode.removeAttribute('select');\n\t\t}\n\t});\n\treturn tree;\n};\n\nconst supportedAddons = { bem, jsx, xsl };\n\n/**\n * Runs additional transforms on given tree.\n * These transforms may introduce side-effects and unexpected result\n * so they are not applied by default, authors must specify which addons\n * in `addons` argument as `{addonName: addonOptions}`\n * @param {Node} tree Parsed Emmet abbreviation\n * @param {Object} addons Add-ons to apply and their options\n */\nvar addons = function(tree, addons) {\n    Object.keys(addons || {}).forEach(key => {\n        if (key in supportedAddons) {\n            const addonOpt = typeof addons[key] === 'object' ? addons[key] : null;\n            tree = tree.use(supportedAddons[key], addonOpt);\n        }\n    });\n\n    return tree;\n};\n\n/**\n * Applies basic HTML-specific transformations for given parsed abbreviation:\n * – resolve implied tag names\n * – insert repeated content\n * – resolve node numbering\n */\nvar index = function(tree, content, appliedAddons) {\n    if (typeof content === 'string') {\n        content = [content];\n    } else if (content && typeof content === 'object' && !Array.isArray(content)) {\n        appliedAddons = content;\n        content = null;\n    }\n\n    return tree\n    .use(implicitTags)\n    .use(prepare, Array.isArray(content) ? content.length : null)\n    .use(applyNumbering)\n    .use(insert, content)\n    .use(addons, appliedAddons);\n};\n\nexport default index;\n","/**\n * Replaces all unescaped ${variable} occurances in given parsed abbreviation\n * `tree` with values provided in `variables` hash. Precede `$` with `\\` to\n * escape it and skip replacement\n * @param {Node} tree Parsed abbreviation tree\n * @param {Object} variables Variables values\n * @return {Node}\n */\nfunction replaceVariables(tree, variables) {\n\tvariables = variables || {};\n    tree.walk(node => replaceInNode(node, variables));\n    return tree;\n}\n\nfunction replaceInNode(node, variables) {\n    // Replace variables in attributes.\n    const attrs = node.attributes;\n\n    for (let i = 0, il = attrs.length; i < il; i++) {\n        const attr = attrs[i];\n        if (typeof attr.value === 'string') {\n            node.setAttribute(attr.name, replaceInString(attr.value, variables));\n        }\n    }\n\n    if (node.value != null) {\n        node.value = replaceInString(node.value, variables);\n    }\n\n    return node;\n}\n\n/**\n * Replaces all unescaped `${variable}` occurances in given string with values\n * from `variables` object\n * @param  {String} string\n * @param  {Object} variables\n * @return {String}\n */\nfunction replaceInString(string, variables) {\n    const model = createModel(string);\n    let offset = 0;\n    let output = '';\n\n    for (let i = 0, il = model.variables.length; i < il; i++) {\n        const v = model.variables[i];\n        let value = v.name in variables ? variables[v.name] : v.name;\n        if (typeof value === 'function') {\n            value = value(model.string, v, offset + v.location);\n        }\n\n        output += model.string.slice(offset, v.location) + value;\n        offset = v.location + v.length;\n    }\n\n    return output + model.string.slice(offset);\n}\n\n/**\n * Creates variable model from given string. The model contains a `string` with\n * all escaped variable tokens written without escape symbol and `variables`\n * property with all unescaped variables and their ranges\n * @param  {String} string\n * @return {Object}\n */\nfunction createModel(string) {\n    const reVariable = /\\$\\{([a-z][\\w\\-]*)\\}/ig;\n    const escapeCharCode = 92; // `\\` symbol\n    const variables = [];\n\n    // We have to replace unescaped (e.g. not preceded with `\\`) tokens.\n    // Instead of writing a stream parser, we’ll cut some edges here:\n    // 1. Find all tokens\n    // 2. Walk string char-by-char and resolve only tokens that are not escaped\n    const tokens = new Map();\n    let m;\n    while (m = reVariable.exec(string)) {\n        tokens.set(m.index, m);\n    }\n\n    if (tokens.size) {\n        let start = 0, pos = 0, len = string.length;\n        let output = '';\n        while (pos < len) {\n            if (string.charCodeAt(pos) === escapeCharCode && tokens.has(pos + 1)) {\n                // Found escape symbol that escapes variable: we should\n                // omit this symbol in output string and skip variable\n                const token = tokens.get(pos + 1);\n                output += string.slice(start, pos) + token[0];\n                start = pos = token.index + token[0].length;\n                tokens.delete(pos + 1);\n                continue;\n            }\n\n            pos++;\n        }\n\n        string = output + string.slice(start);\n\n        // Not using `.map()` here to reduce memory allocations\n        const validMatches = Array.from(tokens.values());\n        for (let i = 0, il = validMatches.length; i < il; i++) {\n            const token = validMatches[i];\n            variables.push({\n                name: token[1],\n                location: token.index,\n                length: token[0].length\n            });\n        }\n    }\n\n    return {string, variables};\n}\n\nexport default replaceVariables;\n","import StreamReader from '@emmetio/stream-reader';\nimport { isNumber } from '@emmetio/stream-reader-utils';\n\nconst DOLLAR      = 36;  // $\nconst COLON       = 58;  // :\nconst ESCAPE      = 92;  // \\\nconst OPEN_BRACE  = 123; // {\nconst CLOSE_BRACE = 125; // }\n\n/**\n * Finds fields in given string and returns object with field-less string\n * and array of fields found\n * @param  {String} string\n * @return {Object}\n */\nfunction parse(string) {\n\tconst stream = new StreamReader(string);\n\tconst fields = [];\n\tlet cleanString = '', offset = 0, pos = 0;\n\tlet code, field;\n\n\twhile (!stream.eof()) {\n\t\tcode = stream.peek();\n\t\tpos = stream.pos;\n\n\t\tif (code === ESCAPE) {\n\t\t\tstream.next();\n\t\t\tstream.next();\n\t\t} else if (field = consumeField(stream, cleanString.length + pos - offset)) {\n\t\t\tfields.push(field);\n\t\t\tcleanString += stream.string.slice(offset, pos) + field.placeholder;\n\t\t\toffset = stream.pos;\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t}\n\n\treturn new FieldString(cleanString + stream.string.slice(offset), fields);\n}\n\n/**\n * Marks given `string` with `fields`: wraps each field range with\n * `${index:placeholder}` (by default) or any other token produced by `token`\n * function, if provided\n * @param  {String} string String to mark\n * @param  {Array} fields Array of field descriptor. A field descriptor is a\n * `{index, location, length}` array. It is important that fields in array\n * must be ordered by their location in string: some fields my refer the same\n * location so they must appear in order that user expects.\n * @param  {Function} [token] Function that generates field token. This function\n * received two arguments: `index` and `placeholder` and should return string\n * @return {String}  String with marked fields\n */\nfunction mark(string, fields, token) {\n\ttoken = token || createToken;\n\n\t// order fields by their location and appearence\n\t// NB field ranges should not overlap! (not supported yet)\n\tconst ordered = fields\n\t.map((field, order) => ({order, field, end: field.location + field.length}))\n\t.sort((a, b) => (a.end - b.end) || (a.order - b.order));\n\n\t// mark ranges in string\n\tlet offset = 0;\n\tconst result = ordered.map(item => {\n\t\tconst placeholder = string.substr(item.field.location, item.field.length);\n\t\tconst prefix = string.slice(offset, item.field.location);\n\t\toffset = item.end;\n\t\treturn prefix + token(item.field.index, placeholder);\n\t});\n\n\treturn result.join('') + string.slice(offset);\n}\n\n/**\n * Creates field token for string\n * @param  {Number} index       Field index\n * @param  {String} placeholder Field placeholder, could be empty string\n * @return {String}\n */\nfunction createToken(index, placeholder) {\n\treturn placeholder ? `\\${${index}:${placeholder}}` : `\\${${index}}`;\n}\n\n/**\n * Consumes field from current stream position: it can be an `$index` or\n * or `${index}` or `${index:placeholder}`\n * @param  {StreamReader} stream\n * @param  {Number}       location Field location in *clean* string\n * @return {Field} Object with `index` and `placeholder` properties if\n * field was successfully consumed, `null` otherwise\n */\nfunction consumeField(stream, location) {\n\tconst start = stream.pos;\n\n\tif (stream.eat(DOLLAR)) {\n\t\t// Possible start of field\n\t\tlet index = consumeIndex(stream);\n\t\tlet placeholder = '';\n\n\t\t// consumed $index placeholder\n\t\tif (index != null) {\n\t\t\treturn new Field(index, placeholder, location);\n\t\t}\n\n\t\tif (stream.eat(OPEN_BRACE)) {\n\t\t\tindex = consumeIndex(stream);\n\t\t\tif (index != null) {\n\t\t\t\tif (stream.eat(COLON)) {\n\t\t\t\t\tplaceholder = consumePlaceholder(stream);\n\t\t\t\t}\n\n\t\t\t\tif (stream.eat(CLOSE_BRACE)) {\n\t\t\t\t\treturn new Field(index, placeholder, location);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we reached here then there’s no valid field here, revert\n\t// back to starting position\n\tstream.pos = start;\n}\n\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n * @param  {StreamReader} stream\n * @return {String}\n */\nfunction consumePlaceholder(stream) {\n\tlet code;\n\tconst stack = [];\n\tstream.start = stream.pos;\n\n\twhile (!stream.eof()) {\n\t\tcode = stream.peek();\n\n\t\tif (code === OPEN_BRACE) {\n\t\t\tstack.push(stream.pos);\n\t\t} else if (code === CLOSE_BRACE) {\n\t\t\tif (!stack.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstack.pop();\n\t\t}\n\t\tstream.next();\n\t}\n\n\tif (stack.length) {\n\t\tthrow stream.error('Unable to find matching \"}\" for curly brace at ' + stack.pop());\n\t}\n\n\treturn stream.current();\n}\n\n/**\n * Consumes integer from current stream position\n * @param  {StreamReader} stream\n * @return {Number}\n */\nfunction consumeIndex(stream) {\n\tstream.start = stream.pos;\n\tif (stream.eatWhile(isNumber)) {\n\t\treturn Number(stream.current());\n\t}\n}\n\nclass Field {\n\tconstructor(index, placeholder, location) {\n\t\tthis.index = index;\n\t\tthis.placeholder = placeholder;\n\t\tthis.location = location;\n\t\tthis.length = this.placeholder.length;\n\t}\n}\n\nclass FieldString {\n\t/**\n\t * @param {String} string\n\t * @param {Field[]} fields\n\t */\n\tconstructor(string, fields) {\n\t\tthis.string = string;\n\t\tthis.fields = fields;\n\t}\n\n\tmark(token) {\n\t\treturn mark(this.string, this.fields, token);\n\t}\n\n\ttoString() {\n\t\treturn this.string;\n\t}\n}\n\nexport default parse;\nexport { mark, createToken };\n//# sourceMappingURL=field-parser.es.js.map\n","import parseFields from '@emmetio/field-parser';\n\nconst defaultFieldsRenderer = text => text;\n\n/**\n * Output node is an object containing generated output for given Emmet\n * abbreviation node. Output node can be passed to various processors that\n * may shape-up final node output. The final output is simply a concatenation\n * of `.open`, `.text` and `.close` properties and its `.before*` and `.after*`\n * satellites\n * @param {Node}     node           Parsed Emmet abbreviation node\n * @param {Function} fieldsRenderer A function for rendering fielded text (text with\n * tabstops) for current node. @see ./render.js for details\n */\nclass OutputNode {\n\tconstructor(node, fieldsRenderer, options) {\n\t\tif (typeof fieldsRenderer === 'object') {\n\t\t\toptions = fieldsRenderer;\n\t\t\tfieldsRenderer = null;\n\t\t}\n\n\t\tthis.node = node;\n\t\tthis._fieldsRenderer = fieldsRenderer || defaultFieldsRenderer;\n\n\t\tthis.open = null;\n\t\tthis.beforeOpen = '';\n\t\tthis.afterOpen = '';\n\n\t\tthis.close = null;\n\t\tthis.beforeClose = '';\n\t\tthis.afterClose = '';\n\n\t\tthis.text = null;\n\t\tthis.beforeText = '';\n\t\tthis.afterText = '';\n\n\t\tthis.indent = '';\n\t\tthis.newline = '';\n\n\t\tif (options) {\n            Object.assign(this, options);\n        }\n\t}\n\n\tclone() {\n\t\treturn new this.constructor(this.node, this);\n\t}\n\n\t/**\n\t * Properly indents given multiline text\n\t * @param {String} text\n\t */\n\tindentText(text) {\n\t\tconst lines = splitByLines(text);\n        if (lines.length === 1) {\n            // no newlines, nothing to indent\n            return text;\n        }\n\n        // No newline and no indent means no formatting at all:\n        // in this case we should replace newlines with spaces\n        const nl = (!this.newline && !this.indent) ? ' ' : this.newline;\n        return lines.map((line, i) => i ? this.indent + line : line).join(nl);\n\t}\n\n\t/**\n\t * Renders given text with fields\n\t * @param {String} text\n\t * @return {String}\n\t */\n\trenderFields(text) {\n\t\treturn this._fieldsRenderer(text);\n\t}\n\n\ttoString(children) {\n\t\tconst open = this._wrap(this.open, this.beforeOpen, this.afterOpen);\n\t\tconst close = this._wrap(this.close, this.beforeClose, this.afterClose);\n\t\tconst text = this._wrap(this.text, this.beforeText, this.afterText);\n\n\t\treturn open + text + (children != null ? children : '') + close;\n\t}\n\n\t_wrap(str, before, after) {\n\t\tbefore = before != null ? before : '';\n\t\tafter = after != null ? after : '';\n\n        // automatically trim whitespace for non-empty wraps\n        if (str != null) {\n            str = before ? str.replace(/^\\s+/, '') : str;\n            str = after ? str.replace(/\\s+$/, '') : str;\n            return before + this.indentText(str) + after;\n        }\n\n        return '';\n\t}\n}\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]}\n */\nfunction splitByLines(text) {\n\treturn (text || '').split(/\\r\\n|\\r|\\n/g);\n}\n\n/**\n * Default output of field (tabstop)\n * @param  {Number} index       Field index\n * @param  {String} placeholder Field placeholder, can be null\n * @return {String}\n */\nconst defaultField = (index, placeholder) => (placeholder || '');\n\n/**\n * Renders given parsed abbreviation `tree` via `formatter` function.\n\n * @param {Node}     tree      Parsed Emmet abbreviation\n * @param {Function} [field]   Optional function to format field/tabstop (@see `defaultField`)\n * @param {Function} formatter Output formatter function. It takes an output node—\n * a special wrapper for parsed node that holds formatting and output properties—\n * and updates its output properties to shape-up node’s output.\n * Function arguments:\n * \t– `outNode`: OutputNode\n * \t– `renderFields`: a helper function that parses fields/tabstops from given\n * \t   text and replaces them with `field` function output.\n * \t   It also takes care about field indicies and ensures that the same indicies\n * \t   from different nodes won’t collide\n */\nfunction render(tree, field, formatter) {\n    if (typeof formatter === 'undefined') {\n        formatter = field;\n        field = null;\n    }\n\n    field = field || defaultField;\n\n    // Each node may contain fields like `${1:placeholder}`.\n\t// Since most modern editors will link all fields with the same\n\t// index, we have to ensure that different nodes has their own indicies.\n\t// We’ll use this `fieldState` object to globally increment field indices\n\t// during output\n\tconst fieldState = { index: 1 };\n\n    const fieldsRenderer = text => text == null\n        ? field(fieldState.index++)\n        : getFieldsModel(text, fieldState).mark(field);\n\n\treturn run(tree.children, formatter, fieldsRenderer);\n}\n\nfunction run(nodes, formatter, fieldsRenderer) {\n\treturn nodes.map(node => {\n\t\tconst outNode = formatter(new OutputNode(node, fieldsRenderer));\n\t\treturn outNode ? outNode.toString(run(node.children, formatter, fieldsRenderer)) : '';\n\t}).join('');\n}\n\n/**\n * Returns fields (tab-stops) model with properly updated indices that won’t\n * collide with fields in other nodes of foprmatted tree\n * @param  {String|Object} text Text to get fields model from or model itself\n * @param  {Object} fieldState Abbreviation tree-wide field state reference\n * @return {Object} Field model\n */\nfunction getFieldsModel(text, fieldState) {\n\tconst model = typeof text === 'object' ? text : parseFields(text);\n    let largestIndex = -1;\n\n    model.fields.forEach(field => {\n\t\tfield.index += fieldState.index;\n\t\tif (field.index > largestIndex) {\n\t\t\tlargestIndex = field.index;\n\t\t}\n\t});\n\n\tif (largestIndex !== -1) {\n\t\tfieldState.index = largestIndex + 1;\n\t}\n\n    return model;\n}\n\nexport default render;\n","import parseFields from '@emmetio/field-parser';\nimport render from '@emmetio/output-renderer';\n\nconst TOKEN       = /^(.*?)([A-Z_]+)(.*?)$/;\nconst TOKEN_OPEN  = 91; // [\nconst TOKEN_CLOSE = 93; // ]\n\n/**\n * A basic templating engine.\n * Takes every `[TOKEN]` from given string and replaces it with\n * `TOKEN` value from given `data` attribute. The token itself may contain\n * various characters between `[`, token name and `]`. Contents of `[...]` will\n * be outputted only if `TOKEN` value is not empty. Also, only `TOKEN` name will\n * be replaced with actual value, all other characters will remain as is.\n *\n * Example:\n * ```\n * template('[<NAME>]', {NAME: 'foo'}) -> \"<foo>\"\n * template('[<NAME>]', {}) -> \"\"\n * ```\n */\nfunction template(str, data) {\n\tif (str == null) {\n\t\treturn str;\n\t}\n\n\t// NB since token may contain inner `[` and `]`, we can’t just use regexp\n\t// for replacement, should manually parse string instead\n\tconst stack = [];\n\tconst replacer = (str, left, token, right) =>\n\t\tdata[token] != null ? left + data[token] + right : '';\n\n\tlet output = '';\n\tlet offset = 0, i = 0;\n\tlet code, lastPos;\n\n\twhile (i < str.length) {\n\t\tcode = str.charCodeAt(i);\n\t\tif (code === TOKEN_OPEN) {\n\t\t\tstack.push(i);\n\t\t} else if (code === TOKEN_CLOSE) {\n\t\t\tlastPos = stack.pop();\n\t\t\tif (!stack.length) {\n\t\t\t\toutput += str.slice(offset, lastPos) +\n\t\t\t\t\tstr.slice(lastPos + 1, i).replace(TOKEN, replacer);\n\t\t\t\toffset = i + 1;\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn output + str.slice(offset);\n}\n\n/**\n * Various utility methods used by formatters\n */\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]}\n */\nfunction splitByLines(text) {\n\treturn (text || '').split(/\\r\\n|\\r|\\n/g);\n}\n\n/**\n * Check if given node is a first child in its parent\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isFirstChild(node) {\n\treturn node.parent.firstChild === node;\n}\n\n/**\n * Check if given node is a root node\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isRoot(node) {\n\treturn node && !node.parent;\n}\n\n/**\n * Check if given node is a pseudo-snippet: a text-only node with explicitly\n * defined children\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isPseudoSnippet(node) {\n\treturn node.isTextOnly && !!node.children.length;\n}\n\n/**\n * Handles pseudo-snippet node.\n * A pseudo-snippet is a text-only node with explicitly defined children.\n * For such case, we have to figure out if pseudo-snippet contains fields\n * (tab-stops) in node value and “split” it: make contents before field with\n * lowest index node’s “open” part and contents after lowest index — “close”\n * part. With this trick a final output will look like node’s children\n * are nested inside node value\n * @param  {OutputNode} outNode\n * @return {Boolean} Returns “true” if given node is a pseudo-snippets,\n * `false` otherwise\n */\nfunction handlePseudoSnippet(outNode) {\n\tconst node = outNode.node; // original abbreviaiton node\n\n\tif (isPseudoSnippet(node)) {\n\t\tconst fieldsModel = parseFields(node.value);\n\t\tconst field = findLowestIndexField(fieldsModel);\n\t\tif (field) {\n\t\t\tconst parts = splitFieldsModel(fieldsModel, field);\n\t\t\toutNode.open = outNode.renderFields(parts[0]);\n\t\t\toutNode.close = outNode.renderFields(parts[1]);\n\t\t} else {\n\t\t\toutNode.text = outNode.renderFields(fieldsModel);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Finds field with lowest index in given text\n * @param  {Object} model\n * @return {Object}\n */\nfunction findLowestIndexField(model) {\n\treturn model.fields.reduce((result, field) =>\n\t\t!result || field.index < result.index ? field : result\n\t\t, null);\n}\n\n/**\n * Splits given fields model in two parts by given field\n * @param  {Object} model\n * @param  {Object} field\n * @return {Array} Two-items array\n */\nfunction splitFieldsModel(model, field) {\n\tconst ix = model.fields.indexOf(field);\n\n\tconst left = new model.constructor(\n\t\tmodel.string.slice(0, field.location),\n\t\tmodel.fields.slice(0, ix)\n\t);\n\n\tconst right = new model.constructor(\n\t\tmodel.string.slice(field.location + field.length),\n\t\tmodel.fields.slice(ix + 1)\n\t);\n\n\treturn [left, right];\n}\n\nconst commentOptions = {\n\t// enable node commenting\n\tenabled: false,\n\n\t// attributes that should trigger node commenting on specific node,\n\t// if commenting is enabled\n\ttrigger: ['id', 'class'],\n\n\t// comment before opening tag\n\tbefore: '',\n\n\t// comment after closing tag\n\tafter: '\\n<!-- /[#ID][.CLASS] -->'\n};\n\n/**\n * Renders given parsed Emmet abbreviation as HTML, formatted according to\n * `profile` options\n * @param  {Node}     tree    Parsed Emmet abbreviation\n * @param  {Profile}  profile Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction html(tree, profile, options) {\n\toptions = Object.assign({}, options);\n\tconst format = getFormatOptions(options);\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = setFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\tif (node.name) {\n\t\t\t\tconst name = profile.name(node.name);\n\t\t\t\tconst attrs = formatAttributes(outNode, profile);\n\n\t\t\t\toutNode.open = `<${name}${attrs}${node.selfClosing ? profile.selfClose() : ''}>`;\n\t\t\t\tif (!node.selfClosing) {\n\t\t\t\t\toutNode.close = `</${name}>`;\n\t\t\t\t}\n\n\t\t\t\tcommentNode(outNode, format.comment);\n\t\t\t}\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(node.value);\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction setFormatting(outNode, profile) {\n\tconst node = outNode.node;\n\n\tif (shouldFormatNode(node, profile)) {\n\t\toutNode.indent = profile.indent(getIndentLevel(node, profile));\n\t\toutNode.newline = '\\n';\n\t\tconst prefix = outNode.newline + outNode.indent;\n\n\t\t// do not format the very first node in output\n\t\tif (!isRoot(node.parent) || !isFirstChild(node)) {\n\t\t\toutNode.beforeOpen = prefix;\n\t\t\tif (node.isTextOnly) {\n\t\t\t\toutNode.beforeText = prefix;\n\t\t\t}\n\t\t}\n\n\t\tif (hasInnerFormatting(node, profile)) {\n\t\t\tif (!node.isTextOnly) {\n\t\t\t\toutNode.beforeText = prefix + profile.indent(1);\n\t\t\t}\n\t\t\toutNode.beforeClose = prefix;\n\t\t}\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Check if given node should be formatted\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction shouldFormatNode(node, profile) {\n\tif (!profile.get('format')) {\n\t\treturn false;\n\t}\n\n\tif (node.parent.isTextOnly\n\t\t&& node.parent.children.length === 1\n\t\t&& parseFields(node.parent.value).fields.length) {\n\t\t// Edge case: do not format the only child of text-only node,\n\t\t// but only if parent contains fields\n\t\treturn false;\n\t}\n\n\treturn isInline(node, profile) ? shouldFormatInline(node, profile) : true;\n}\n\n/**\n * Check if given inline node should be formatted as well, e.g. it contains\n * enough adjacent siblings that should force formatting\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction shouldFormatInline(node, profile) {\n\tif (!isInline(node, profile)) {\n\t\treturn false;\n\t}\n\n\tif (isPseudoSnippet(node)) {\n\t\treturn true;\n\t}\n\n\t// check if inline node is the next sibling of block-level node\n\tif (node.childIndex === 0) {\n\t\t// first node in parent: format if it’s followed by a block-level element\n\t\tlet next = node;\n\t\twhile (next = next.nextSibling) {\n\t\t\tif (!isInline(next, profile)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t} else if (!isInline(node.previousSibling, profile)) {\n\t\t// node is right after block-level element\n\t\treturn true;\n\t}\n\n\tif (profile.get('inlineBreak')) {\n\t\t// check for adjacent inline elements before and after current element\n\t\tlet adjacentInline = 1;\n\t\tlet before = node, after = node;\n\n\t\twhile (isInlineElement((before = before.previousSibling), profile)) {\n\t\t\tadjacentInline++;\n\t\t}\n\n\t\twhile (isInlineElement((after = after.nextSibling), profile)) {\n\t\t\tadjacentInline++;\n\t\t}\n\n\t\tif (adjacentInline >= profile.get('inlineBreak')) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Another edge case: inline node contains node that should receive foramtting\n\tfor (let i = 0, il = node.children.length; i < il; i++) {\n\t\tif (shouldFormatNode(node.children[i], profile)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Check if given node contains inner formatting, e.g. any of its children should\n * be formatted\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction hasInnerFormatting(node, profile) {\n\t// check if node if forced for inner formatting\n\tconst nodeName = (node.name || '').toLowerCase();\n\tif (profile.get('formatForce').indexOf(nodeName) !== -1) {\n\t\treturn true;\n\t}\n\n\t// check if any of children should receive formatting\n\t// NB don’t use `childrent.some()` to reduce memory allocations\n\tfor (let i = 0; i < node.children.length; i++) {\n\t\tif (shouldFormatNode(node.children[i], profile)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Outputs attributes of given abbreviation node as HTML attributes\n * @param  {OutputNode} outNode\n * @param  {Profile}    profile\n * @return {String}\n */\nfunction formatAttributes(outNode, profile) {\n\tconst node = outNode.node;\n\n\treturn node.attributes.map(attr => {\n\t\tif (attr.options.implied && attr.value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst attrName = profile.attribute(attr.name);\n\t\tlet attrValue = null;\n\n\t\t// handle boolean attributes\n\t\tif (attr.options.boolean || profile.get('booleanAttributes').indexOf(attrName.toLowerCase()) !== -1) {\n\t\t\tif (profile.get('compactBooleanAttributes') && attr.value == null) {\n\t\t\t\treturn ` ${attrName}`;\n\t\t\t} else if (attr.value == null) {\n\t\t\t\tattrValue = attrName;\n\t\t\t}\n\t\t}\n\n\t\tif (attrValue == null) {\n\t\t\tattrValue = outNode.renderFields(attr.value);\n\t\t}\n\n\t\treturn ` ${attrName}=${profile.quote(attrValue)}`;\n\t}).join('');\n}\n\n/**\n * Check if given node is inline-level\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInline(node, profile) {\n\treturn (node && node.isTextOnly) || isInlineElement(node, profile);\n}\n\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInlineElement(node, profile) {\n\treturn node && profile.isInline(node);\n}\n\n/**\n * Computes indent level for given node\n * @param  {Node} node\n * @param  {Profile} profile\n * @param  {Number} level\n * @return {Number}\n */\nfunction getIndentLevel(node, profile) {\n\t// Increase indent level IF NOT:\n\t// * parent is text-only node\n\t// * there’s a parent node with a name that is explicitly set to decrease level\n\tconst skip = profile.get('formatSkip') || [];\n\tlet level = node.parent.isTextOnly ? -2 : -1;\n\tlet ctx = node;\n\twhile (ctx = ctx.parent) {\n\t\tif (skip.indexOf( (ctx.name || '').toLowerCase() ) === -1) {\n\t\t\tlevel++;\n\t\t}\n\t}\n\n\treturn level < 0 ? 0 : level;\n}\n\n/**\n * Comments given output node, if required\n * @param  {OutputNode} outNode\n * @param  {Object} options\n */\nfunction commentNode(outNode, options) {\n\tconst node = outNode.node;\n\n\tif (!options.enabled || !options.trigger || !node.name) {\n\t\treturn;\n\t}\n\n\tconst attrs = outNode.node.attributes.reduce((out, attr) => {\n\t\tif (attr.name && attr.value != null) {\n\t\t\tout[attr.name.toUpperCase().replace(/-/g, '_')] = attr.value;\n\t\t}\n\n\t\treturn out;\n\t}, {});\n\n\t// add comment only if attribute trigger is present\n\tfor (let i = 0, il = options.trigger.length; i < il; i++) {\n\t\tif (options.trigger[i].toUpperCase() in attrs) {\n\t\t\toutNode.open = template(options.before, attrs) + outNode.open;\n\t\t\tif (outNode.close) {\n\t\t\t\toutNode.close += template(options.after, attrs);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction getFormatOptions(options) {\n\tconst format = Object.assign({}, options && options.format);\n\tformat.comment = Object.assign({}, commentOptions, format.comment);\n\treturn format;\n}\n\nconst reId = /^id$/i;\nconst reClass = /^class$/i;\nconst defaultAttrOptions = {\n\tprimary: attrs => attrs.join(''),\n\tsecondary: attrs => attrs.map(attr => attr.isBoolean ? attr.name : `${attr.name}=${attr.value}`).join(', ')\n};\n\nconst defaultNodeOptions = {\n\topen: null,\n\tclose: null,\n\tomitName: /^div$/i,\n\tattributes: defaultAttrOptions\n};\n\nfunction indentFormat(outNode, profile, options) {\n\toptions = Object.assign({}, defaultNodeOptions, options);\n\tconst node = outNode.node;\n\n\toutNode.indent = profile.indent(getIndentLevel$1(node, profile));\n\toutNode.newline = '\\n';\n\n\t// Do not format the very first node in output\n\tif (!isRoot(node.parent) || !isFirstChild(node)) {\n\t\toutNode.beforeOpen = outNode.newline + outNode.indent;\n\t}\n\n\tif (node.name) {\n\t\tconst data = Object.assign({\n\t\t\tNAME: profile.name(node.name),\n\t\t\tSELF_CLOSE: node.selfClosing ? options.selfClose : null\n\t\t}, getAttributes(outNode, profile, options.attributes));\n\n\t\t// omit tag name if node has primary attributes\n\t\tif (options.omitName && options.omitName.test(data.NAME) && data.PRIMARY_ATTRS) {\n\t\t\tdata.NAME = null;\n\t\t}\n\n\t\tif (options.open != null) {\n\t\t\toutNode.open = template(options.open, data);\n\t\t}\n\n\t\tif (options.close != null) {\n\t\t\toutNode.close = template(options.close, data);\n\t\t}\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Formats attributes of given node into a string.\n * @param  {OutputNode} node          Output node wrapper\n * @param  {Profile}    profile       Output profile\n * @param  {Object}     options       Additional formatting options\n * @return {String}\n */\nfunction getAttributes(outNode, profile, options) {\n\toptions = Object.assign({}, defaultAttrOptions, options);\n\tconst primary = [], secondary = [];\n\tconst node = outNode.node;\n\n\tnode.attributes.forEach(attr => {\n\t\tif (attr.options.implied && attr.value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst name = profile.attribute(attr.name);\n\t\tconst value = outNode.renderFields(attr.value);\n\n\t\tif (reId.test(name)) {\n\t\t\tvalue && primary.push(`#${value}`);\n\t\t} else if (reClass.test(name)) {\n\t\t\tvalue && primary.push(`.${value.replace(/\\s+/g, '.')}`);\n\t\t} else {\n\t\t\tconst isBoolean = attr.value == null\n\t\t\t\t&& (attr.options.boolean || profile.get('booleanAttributes').indexOf(name.toLowerCase()) !== -1);\n\n\t\t\tsecondary.push({ name, value, isBoolean });\n\t\t}\n\t});\n\n\treturn {\n\t\tPRIMARY_ATTRS: options.primary(primary) || null,\n\t\tSECONDARY_ATTRS: options.secondary(secondary) || null\n\t};\n}\n\n/**\n * Computes indent level for given node\n * @param  {Node} node\n * @return {Number}\n */\nfunction getIndentLevel$1(node) {\n\tlet level = node.parent.isTextOnly ? -2 : -1;\n\tlet ctx = node;\n\twhile (ctx = ctx.parent) {\n\t\tlevel++;\n\t}\n\n\treturn level < 0 ? 0 : level;\n}\n\nconst reNl = /\\n|\\r/;\n\n/**\n * Renders given parsed Emmet abbreviation as HAML, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction haml(tree, profile, options) {\n\toptions = options || {};\n\tconst nodeOptions = {\n\t\topen: '[%NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)][SELF_CLOSE]',\n\t\tselfClose: '/',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean\n\t\t\t\t\t? `${attr.name}${profile.get('compactBooleanAttributes') ? '' : '=true'}`\n\t\t\t\t\t: `${attr.name}=${profile.quote(attr.value)}`\n\t\t\t\t).join(' ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue(node, profile));\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, HAML is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting(outNode, profile) {\n\tconst node = outNode.node;\n\n\tif (!node.isTextOnly && node.value) {\n\t\t// node with text: put a space before single-line text\n\t\toutNode.beforeText = reNl.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n\t}\n\n\treturn outNode;\n}\n/**\n * Formats value of given node: for multiline text we should add a ` |` suffix\n * at the end of each line. Also ensure that text is perfectly aligned.\n * @param  {Node}    node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue(node, profile) {\n\tif (node.value != null && reNl.test(node.value)) {\n\t\tconst lines = splitByLines(node.value);\n\t\tconst indent = profile.indent(1);\n\t\tconst maxLength = lines.reduce((prev, line) => Math.max(prev, line.length), 0);\n\n\t\treturn lines.map((line, i) => `${i ? indent : ''}${pad(line, maxLength)} |`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\nfunction pad(text, len) {\n\twhile (text.length < len) {\n\t\ttext += ' ';\n\t}\n\n\treturn text;\n}\n\nconst reNl$1 = /\\n|\\r/;\nconst secondaryAttrs = {\n\tnone:   '[ SECONDARY_ATTRS]',\n\tround:  '[(SECONDARY_ATTRS)]',\n\tcurly:  '[{SECONDARY_ATTRS}]',\n\tsquare: '[[SECONDARY_ATTRS]'\n};\n\n/**\n * Renders given parsed Emmet abbreviation as Slim, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction slim(tree, profile, options) {\n\toptions = options || {};\n\tconst SECONDARY_ATTRS = options.attributeWrap\n\t\t&& secondaryAttrs[options.attributeWrap]\n\t\t|| secondaryAttrs.none;\n\n\tconst booleanAttr = SECONDARY_ATTRS === secondaryAttrs.none\n\t\t? attr => `${attr.name}=true`\n\t\t: attr => attr.name;\n\n\tconst nodeOptions = {\n\t\topen: `[NAME][PRIMARY_ATTRS]${SECONDARY_ATTRS}[SELF_CLOSE]`,\n\t\tselfClose: '/',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean\n\t\t\t\t\t? booleanAttr(attr)\n\t\t\t\t\t: `${attr.name}=${profile.quote(attr.value)}`\n\t\t\t\t).join(' ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting$1(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue$1(node, profile));\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, Slim is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting$1(outNode, profile) {\n\tconst node = outNode.node;\n\tconst parent = node.parent;\n\n\t// Edge case: a single inline-level child inside node without text:\n\t// allow it to be inlined\n\tif (profile.get('inlineBreak') === 0 && isInline$1(node, profile)\n\t\t&& !isRoot(parent) && parent.value == null && parent.children.length === 1) {\n\t\toutNode.beforeOpen = ': ';\n\t}\n\n\tif (!node.isTextOnly && node.value) {\n\t\t// node with text: put a space before single-line text\n\t\toutNode.beforeText = reNl$1.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Formats value of given node: for multiline text we should precede each\n * line with `| ` with one-level deep indent\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue$1(node, profile) {\n\tif (node.value != null && reNl$1.test(node.value)) {\n\t\tconst indent = profile.indent(1);\n\t\treturn splitByLines(node.value).map((line, i) => `${indent}${i ? ' ' : '|'} ${line}`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\n/**\n * Check if given node is inline-level\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInline$1(node, profile) {\n\treturn node && (node.isTextOnly || profile.isInline(node));\n}\n\nconst reNl$2 = /\\n|\\r/;\n\n/**\n * Renders given parsed Emmet abbreviation as Pug, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction pug(tree, profile, options) {\n\toptions = options || {};\n\tconst nodeOptions = {\n\t\topen: '[NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)]',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean ? attr.name : `${attr.name}=${profile.quote(attr.value)}`).join(', ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting$2(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue$2(node, profile));\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, Pug is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting$2(outNode, profile) {\n\tconst node = outNode.node;\n\n\tif (!node.isTextOnly && node.value) {\n\t\t// node with text: put a space before single-line text\n\t\toutNode.beforeText = reNl$2.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Formats value of given node: for multiline text we should precede each\n * line with `| ` with one-level deep indent\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue$2(node, profile) {\n\tif (node.value != null && reNl$2.test(node.value)) {\n\t\tconst indent = profile.indent(1);\n\t\treturn splitByLines(node.value).map(line => `${indent}| ${line}`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\nconst supportedSyntaxes = { html, haml, slim, pug };\n\n/**\n * Outputs given parsed abbreviation in specified syntax\n * @param {Node}     tree     Parsed abbreviation tree\n * @param {Profile}  profile  Output profile\n * @param {String}   [syntax] Output syntax. If not given, `html` syntax is used\n * @param {Function} options.field A function to output field/tabstop for\n * host editor. This function takes two arguments: `index` and `placeholder` and\n * should return a string that represents tabstop in host editor. By default\n * only a placeholder is returned\n * @example\n * {\n * \tfield(index, placeholder) {\n * \t\t// return field in TextMate-style, e.g. ${1} or ${2:foo}\n * \t\treturn `\\${${index}${placeholder ? ':' + placeholder : ''}}`;\n *  }\n * }\n * @return {String}\n */\nfunction index(tree, profile, syntax, options) {\n\tif (typeof syntax === 'object') {\n\t\toptions = syntax;\n\t\tsyntax = null;\n\t}\n\n\tif (!supports(syntax)) {\n\t\t// fallback to HTML if given syntax is not supported\n\t\tsyntax = 'html';\n\t}\n\n\treturn supportedSyntaxes[syntax](tree, profile, options);\n}\n\n/**\n * Check if given syntax is supported\n * @param {String} syntax\n * @return {Boolean}\n */\nfunction supports(syntax) {\n\treturn !!syntax && syntax in supportedSyntaxes;\n}\n\nexport default index;\nexport { supports, template };\n//# sourceMappingURL=markup-formatters.es.js.map\n","import { isNumber, isAlpha, eatQuoted, isWhiteSpace } from '@emmetio/stream-reader-utils';\nimport Node from '@emmetio/node';\nimport StreamReader from '@emmetio/stream-reader';\n\n/**\n * A wrapper for holding CSS value\n */\nclass CSSValue {\n\tconstructor() {\n\t\tthis.type = 'css-value';\n\t\tthis.value = [];\n\t}\n\n\tget size() {\n\t\treturn this.value.length;\n\t}\n\n\tadd(value) {\n\t\tthis.value.push(value);\n\t}\n\n\thas(value) {\n\t\treturn this.value.indexOf(value) !== -1;\n\t}\n\n\ttoString() {\n\t\treturn this.value.join(' ');\n\t}\n}\n\nconst HASH = 35; // #\nconst DOT  = 46; // .\n\n/**\n * Consumes a color token from given string\n * @param  {StreamReader} stream\n * @return {Color} Returns consumend color object, `undefined` otherwise\n */\nfunction consumeColor(stream) {\n\t// supported color variations:\n\t// #abc   → #aabbccc\n\t// #0     → #000000\n\t// #fff.5 → rgba(255, 255, 255, 0.5)\n\t// #t     → transparent\n\tif (stream.peek() === HASH) {\n\t\tstream.start = stream.pos;\n\t\tstream.next();\n\n\t\tstream.eat(116) /* t */ || stream.eatWhile(isHex);\n\t\tconst base = stream.current();\n\n\t\t// a hex color can be followed by `.num` alpha value\n\t\tstream.start = stream.pos;\n\t\tif (stream.eat(DOT) && !stream.eatWhile(isNumber)) {\n\t\t\tthrow stream.error('Unexpected character for alpha value of color');\n\t\t}\n\n\t\treturn new Color(base, stream.current());\n\t}\n}\n\nclass Color {\n\tconstructor(value, alpha) {\n\t\tthis.type = 'color';\n\t\tthis.raw = value;\n\t\tthis.alpha = Number(alpha != null && alpha !== '' ? alpha : 1);\n\t\tvalue = value.slice(1); // remove #\n\n\t\tlet r = 0, g = 0, b = 0;\n\n\t\tif (value === 't') {\n\t\t\tthis.alpha = 0;\n\t\t} else {\n\t\t\tswitch (value.length) {\n\t\t\t\tcase 0:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tr = g = b = value + value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tr = g = b = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\tr = value[0] + value[0];\n\t\t\t\t\tg = value[1] + value[1];\n\t\t\t\t\tb = value[2] + value[2];\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tvalue += value;\n\t\t\t\t\tr = value.slice(0, 2);\n\t\t\t\t\tg = value.slice(2, 4);\n\t\t\t\t\tb = value.slice(4, 6);\n\t\t\t}\n\t\t}\n\n\t\tthis.r = parseInt(r, 16);\n\t\tthis.g = parseInt(g, 16);\n\t\tthis.b = parseInt(b, 16);\n\t}\n\n\t/**\n\t * Output current color as hex value\n\t * @param {Boolean} shor Produce short value (e.g. #fff instead of #ffffff), if possible\n\t * @return {String}\n\t */\n\ttoHex(short) {\n\t\tconst fn = (short && isShortHex(this.r) && isShortHex(this.g) && isShortHex(this.b))\n\t\t\t? toShortHex : toHex;\n\n\t\treturn '#' + fn(this.r)  + fn(this.g) + fn(this.b);\n\t}\n\n\t/**\n\t * Output current color as `rgba?(...)` CSS color\n\t * @return {String}\n\t */\n\ttoRGB() {\n\t\tconst values = [this.r, this.g, this.b];\n\t\tif (this.alpha !== 1) {\n\t\t\tvalues.push(this.alpha.toFixed(8).replace(/\\.?0+$/, ''));\n\t\t}\n\n\t\treturn `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n\t}\n\n\ttoString(short) {\n\t\tif (!this.r && !this.g && !this.b && !this.alpha) {\n\t\t\treturn 'transparent';\n\t\t}\n\t\treturn this.alpha === 1 ? this.toHex(short) : this.toRGB();\n\t}\n}\n\n/**\n * Check if given code is a hex value (/0-9a-f/)\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isHex(code) {\n\treturn isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\n\nfunction isShortHex(hex) {\n\treturn !(hex % 17);\n}\n\nfunction toShortHex(num) {\n\treturn (num >> 4).toString(16);\n}\n\nfunction toHex(num) {\n\treturn pad(num.toString(16), 2);\n}\n\nfunction pad(value, len) {\n\twhile (value.length < len) {\n\t\tvalue = '0' + value;\n\t}\n\treturn value;\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaNumericWord(code) {\n\treturn isNumber(code) || isAlphaWord(code);\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaWord(code) {\n\treturn code === 95 /* _ */ || isAlpha(code);\n}\n\nconst PERCENT = 37; // %\nconst DOT$1     = 46; // .\nconst DASH    = 45; // -\n\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n * @param  {StreamReader} stream\n * @return {NumericValue}\n */\nfunction consumeNumericValue(stream) {\n\tstream.start = stream.pos;\n\tif (eatNumber(stream)) {\n\t\tconst num = stream.current();\n\t\tstream.start = stream.pos;\n\n\t\t// eat unit, which can be a % or alpha word\n\t\tstream.eat(PERCENT) || stream.eatWhile(isAlphaWord);\n\t\treturn new NumericValue(num, stream.current());\n\t}\n}\n\n/**\n * A numeric CSS value with optional unit\n */\nclass NumericValue {\n\tconstructor(value, unit) {\n\t\tthis.type = 'numeric';\n\t\tthis.value = Number(value);\n\t\tthis.unit = unit || '';\n\t}\n\n\ttoString() {\n\t\treturn `${this.value}${this.unit}`;\n\t}\n}\n\n/**\n * Eats number value from given stream\n * @param  {StreamReader} stream\n * @return {Boolean} Returns `true` if number was consumed\n */\nfunction eatNumber(stream) {\n\tconst start = stream.pos;\n\tconst negative = stream.eat(DASH);\n\tconst afterNegative = stream.pos;\n\n\tstream.eatWhile(isNumber);\n\t\n\tconst prevPos = stream.pos;\n\tif (stream.eat(DOT$1) && !stream.eatWhile(isNumber)) {\n\t\t// Number followed by a dot, but then no number\n\t\tstream.pos = prevPos;\n\t}\n\n\t// Edge case: consumed dash only: not a number, bail-out\n\tif (stream.pos === afterNegative) {\n\t\tstream.pos = start;\n\t}\n\n\treturn stream.pos !== start;\n}\n\nconst DOLLAR = 36; // $\nconst DASH$1   = 45; // -\nconst AT     = 64; // @\n\n/**\n * Consumes a keyword: either a variable (a word that starts with $ or @) or CSS\n * keyword or shorthand\n * @param  {StreamReader} stream\n * @param  {Boolean} [short] Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n * @return {String} Consumed variable\n */\nfunction consumeKeyword(stream, short) {\n\tstream.start = stream.pos;\n\n\tif (stream.eat(DOLLAR) || stream.eat(AT)) {\n\t\t// SCSS or LESS variable\n\t\tstream.eatWhile(isVariableName);\n\t} else if (short) {\n\t\tstream.eatWhile(isAlphaWord);\n\t} else {\n\t\tstream.eatWhile(isKeyword);\n\t}\n\n\treturn stream.start !== stream.pos ? new Keyword(stream.current()) : null;\n}\n\nclass Keyword {\n\tconstructor(value) {\n\t\tthis.type = 'keyword';\n\t\tthis.value = value;\n\t}\n\n\ttoString() {\n\t\treturn this.value;\n\t}\n}\n\nfunction isKeyword(code) {\n\treturn isAlphaNumericWord(code) || code === DASH$1;\n}\n\nfunction isVariableName(code) {\n\treturn code === 45 /* - */ || isAlphaNumericWord(code);\n}\n\nconst opt = { throws: true };\n\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @param  {StreamReader} stream\n * @return {String}\n */\nfunction consumeQuoted(stream) {\n\tif (eatQuoted(stream, opt)) {\n\t\treturn new QuotedString(stream.current());\n\t}\n}\n\nclass QuotedString {\n\tconstructor(value) {\n\t\tthis.type = 'string';\n\t\tthis.value = value;\n\t}\n\n\ttoString() {\n\t\treturn this.value;\n\t}\n}\n\nconst LBRACE = 40; // (\nconst RBRACE = 41; // )\nconst COMMA  = 44; // ,\n\n/**\n * Consumes arguments from given string.\n * Arguments are comma-separated list of CSS values inside round braces, e.g.\n * `(1, a2, 'a3')`. Nested lists and quoted strings are supported\n * @param  {StreamReader} stream\n * @return {Array}        Array of arguments, `null` if arguments cannot be consumed\n */\nfunction consumeArgumentList(stream) {\n\tif (!stream.eat(LBRACE)) {\n\t\t// not an argument list\n\t\treturn null;\n\t}\n\n\tlet arg;\n\tconst argsList = [];\n\n\twhile (!stream.eof()) {\n\t\tif (arg = consumeArgument(stream)) {\n\t\t\targsList.push(arg);\n\t\t} else {\n\t\t\t// didn’t consumed argument, expect argument separator or end-of-arguments\n\t\t\tstream.eatWhile(isWhiteSpace);\n\n\t\t\tif (stream.eat(RBRACE)) {\n\t\t\t\t// end of arguments list\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!stream.eat(COMMA)) {\n\t\t\t\tthrow stream.error('Expected , or )');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn argsList;\n}\n\n/**\n * Consumes a single argument. An argument is a `CSSValue`, e.g. it could be\n * a space-separated string of value\n * @param  {StreamReader} stream\n * @return {CSSValue}\n */\nfunction consumeArgument(stream) {\n\tconst result = new CSSValue();\n\tlet value;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isWhiteSpace);\n\t\tvalue = consumeNumericValue(stream) || consumeColor(stream)\n\t\t\t|| consumeQuoted(stream) || consumeKeywordOrFunction(stream);\n\n\t\tif (!value) {\n\t\t\tbreak;\n\t\t}\n\n\t\tresult.add(value);\n\t}\n\n\treturn result.size ? result : null;\n}\n\n/**\n * Consumes either function call like `foo()` or keyword like `foo`\n * @param  {StreamReader} stream\n * @return {Keyword|FunctionCall}\n */\nfunction consumeKeywordOrFunction(stream) {\n\tconst kw = consumeKeyword(stream);\n\tif (kw) {\n\t\tconst args = consumeArgumentList(stream);\n\t\treturn args ? new FunctionCall(kw.toString(), args) : kw;\n\t}\n}\n\nclass FunctionCall {\n\t/**\n\t * @param {String} name Function name\n\t * @param {Array}  args Function arguments\n\t */\n\tconstructor(name, args) {\n\t\tthis.type = 'function';\n\t\tthis.name = name;\n\t\tthis.args = args || [];\n\t}\n\n\ttoString() {\n\t\treturn `${this.name}(${this.args.join(', ')})`;\n\t}\n}\n\nconst EXCL   = 33; // !\nconst DOLLAR$1 = 36; // $\nconst PLUS   = 43; // +\nconst DASH$2   = 45; // -\nconst COLON  = 58; // :\nconst AT$1     = 64; // @\n\n/**\n * Parses given Emmet CSS abbreviation and returns it as parsed Node tree\n * @param {String} abbr\n * @return {Node}\n */\nfunction index(abbr) {\n\tconst root = new Node();\n\tconst stream = new StreamReader(abbr);\n\n\twhile (!stream.eof()) {\n\t\tlet node = new Node(consumeIdent(stream));\n\t\tnode.value = consumeValue(stream);\n\n\t\tconst args = consumeArgumentList(stream);\n\t\tif (args) {\n\t\t\t// technically, arguments in CSS are anonymous Emmet Node attributes,\n\t\t\t// but since Emmet can support only one anonymous, `null`-name\n\t\t\t// attribute (for good reasons), we’ll use argument index as name\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tnode.setAttribute(String(i), args[i]);\n\t\t\t}\n\t\t}\n\n\t\t// Consume `!important` modifier at the end of expression\n\t\tif (stream.eat(EXCL)) {\n\t\t\tnode.value.add('!');\n\t\t}\n\n\t\troot.appendChild(node);\n\n\t\t// CSS abbreviations cannot be nested, only listed\n\t\tif (!stream.eat(PLUS)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!stream.eof()) {\n\t\tthrow stream.error('Unexpected character');\n\t}\n\n\treturn root;\n}\n\n/**\n * Consumes CSS property identifier from given stream\n * @param  {StreamReader} stream\n * @return {String}\n */\nfunction consumeIdent(stream) {\n\tstream.start = stream.pos;\n\tstream.eatWhile(isIdentPrefix);\n\tstream.eatWhile(isIdent);\n\treturn stream.start !== stream.pos ? stream.current() : null;\n}\n\n/**\n * Consumes embedded value from Emmet CSS abbreviation stream\n * @param  {StreamReader} stream\n * @return {CSSValue}\n */\nfunction consumeValue(stream) {\n\tconst values = new CSSValue();\n\tlet value;\n\n\twhile (!stream.eof()) {\n\t\t// use colon as value separator\n\t\tstream.eat(COLON);\n\t\tif (value = consumeNumericValue(stream) || consumeColor(stream)) {\n\t\t\t// edge case: a dash after unit-less numeric value or color should\n\t\t\t// be treated as value separator, not negative sign\n\t\t\tif (!value.unit) {\n\t\t\t\tstream.eat(DASH$2);\n\t\t\t}\n\t\t} else {\n\t\t\tstream.eat(DASH$2);\n\t\t\tvalue = consumeKeyword(stream, true);\n\t\t}\n\n\t\tif (!value) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvalues.add(value);\n\t}\n\n\treturn values;\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isIdent(code) {\n\treturn isAlphaWord(code);\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isIdentPrefix(code) {\n\treturn code === AT$1 || code === DOLLAR$1 || code === EXCL;\n}\n\nexport default index;\n","const DASH = 45; // -\n\n/**\n * Calculates fuzzy match score of how close `abbr` matches given `string`.\n * @param  {String} abbr        Abbreviation to score\n * @param  {String} string      String to match\n * @param  {Number} [fuzziness] Fuzzy factor\n * @return {Number}             Match score\n */\nfunction stringScore(abbr, string) {\n\tabbr = abbr.toLowerCase();\n\tstring = string.toLowerCase();\n\n\tif (abbr === string) {\n\t\treturn 1;\n\t}\n\n\t// a string MUST start with the same character as abbreviation\n\tif (!string || abbr.charCodeAt(0) !== string.charCodeAt(0)) {\n\t\treturn 0;\n\t}\n\n\tconst abbrLength = abbr.length;\n\tconst stringLength = string.length;\n\tlet i = 1, j = 1, score = stringLength;\n\tlet ch1, ch2, found, acronym;\n\n\twhile (i < abbrLength) {\n\t\tch1 = abbr.charCodeAt(i);\n\t\tfound = false;\n\t\tacronym = false;\n\n\t\twhile (j < stringLength) {\n\t\t\tch2 = string.charCodeAt(j);\n\n\t\t\tif (ch1 === ch2) {\n\t\t\t\tfound = true;\n\t\t\t\tscore += (stringLength - j) * (acronym ? 2 : 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// add acronym bonus for exactly next match after unmatched `-`\n\t\t\tacronym = ch2 === DASH;\n\t\t\tj++;\n\t\t}\n\n\t\tif (!found) {\n\t\t\tbreak;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn score && score * (i / abbrLength) / sum(stringLength);\n}\n\n/**\n * Calculates sum of first `n` natural numbers, e.g. 1+2+3+...n\n * @param  {Number} n\n * @return {Number}\n */\nfunction sum(n) {\n\treturn n * (n + 1) / 2;\n}\n\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r]+))?$/;\nconst DASH$1 = 45; // -\n\n/**\n * Creates a special structure for resolving CSS properties from plain CSS\n * snippets.\n * Almost all CSS snippets are aliases for real CSS properties with available\n * value variants, optionally separated by `|`. Most values are keywords that\n * can be fuzzy-resolved as well. Some CSS properties are shorthands for other,\n * more specific properties, like `border` and `border-style`. For such cases\n * keywords from more specific properties should be available in shorthands too.\n * @param {Snippet[]} snippets\n * @return {CSSSnippet[]}\n */\nfunction cssSnippets(snippets) {\n\treturn nest( snippets.map(snippet => new CSSSnippet(snippet.key, snippet.value)) );\n}\n\nclass CSSSnippet {\n\tconstructor(key, value) {\n\t\tthis.key = key;\n\t\tthis.value = value;\n\t\tthis.property = null;\n\n\t\t// detect if given snippet is a property\n\t\tconst m = value && value.match(reProperty);\n\t\tif (m) {\n\t\t\tthis.property = m[1];\n\t\t\tthis.value = m[2];\n\t\t}\n\n\t\tthis.dependencies = [];\n\t}\n\n\taddDependency(dep) {\n\t\tthis.dependencies.push(dep);\n\t}\n\n\tget defaultValue() {\n\t\treturn this.value != null ? splitValue(this.value)[0] : null;\n\t}\n\n\t/**\n\t * Returns list of unique keywords for current CSS snippet and its dependencies\n\t * @return {String[]}\n\t */\n\tkeywords() {\n\t\tconst stack = [];\n\t\tconst keywords = new Set();\n\t\tlet i = 0, item, candidates;\n\n\t\tif (this.property) {\n\t\t\t// scan valid CSS-properties only\n\t\t\tstack.push(this);\n\t\t}\n\n\t\twhile (i < stack.length) {\n\t\t\t// NB Keep items in stack instead of push/pop to avoid possible\n\t\t\t// circular references\n\t\t\titem = stack[i++];\n\n\t\t\tif (item.value) {\n\t\t\t\tcandidates = splitValue(item.value).filter(isKeyword);\n\n\t\t\t\t// extract possible keywords from snippet value\n\t\t\t\tfor (let j = 0; j < candidates.length; j++) {\n\t\t\t\t\tkeywords.add(candidates[j].trim());\n\t\t\t\t}\n\n\t\t\t\t// add dependencies into scan stack\n\t\t\t\tfor (let j = 0, deps = item.dependencies; j < deps.length; j++) {\n\t\t\t\t\tif (stack.indexOf(deps[j]) === -1) {\n\t\t\t\t\t\tstack.push(deps[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(keywords);\n\t}\n}\n\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * background-position-x -> background-position -> background\n * @param  {CSSSnippet[]} snippets\n * @return {CSSSnippet[]}\n */\nfunction nest(snippets) {\n\tsnippets = snippets.sort(snippetsSort);\n\tconst stack = [];\n\n\t// For sorted list of CSS properties, create dependency graph where each\n\t// shorthand property contains its more specific one, e.g.\n\t// background -> background-position -> background-position-x\n\tfor (let i = 0, cur, prev; i < snippets.length; i++) {\n\t\tcur = snippets[i];\n\n\t\tif (!cur.property) {\n\t\t\t// not a CSS property, skip it\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check if current property belongs to one from parent stack.\n\t\t// Since `snippets` array is sorted, items are perfectly aligned\n\t\t// from shorthands to more specific variants\n\t\twhile (stack.length) {\n\t\t\tprev = stack[stack.length - 1];\n\n\t\t\tif (cur.property.indexOf(prev.property) === 0\n\t\t\t\t&& cur.property.charCodeAt(prev.property.length) === DASH$1) {\n\t\t\t\tprev.addDependency(cur);\n\t\t\t\tstack.push(cur);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstack.pop();\n\t\t}\n\n\t\tif (!stack.length) {\n\t\t\tstack.push(cur);\n\t\t}\n\t}\n\n\treturn snippets;\n}\n\n/**\n * A sorting function for array of snippets\n * @param  {CSSSnippet} a\n * @param  {CSSSnippet} b\n * @return {Number}\n */\nfunction snippetsSort(a, b) {\n\tif (a.key === b.key) {\n\t\treturn 0;\n\t}\n\n\treturn a.key < b.key ? -1 : 1;\n}\n\n/**\n * Check if given string is a keyword candidate\n * @param  {String}  str\n * @return {Boolean}\n */\nfunction isKeyword(str) {\n\treturn /^\\s*[\\w-]+/.test(str);\n}\n\nfunction splitValue(value) {\n\treturn String(value).split('|');\n}\n\nconst globalKeywords = ['auto', 'inherit', 'unset'];\nconst unitlessProperties = [\n\t'z-index', 'line-height', 'opacity', 'font-weight', 'zoom',\n\t'flex', 'flex-grow', 'flex-shrink'\n];\n\nconst defaultOptions = {\n\tintUnit: 'px',\n\tfloatUnit: 'em',\n\tunitAliases: {\n\t\te :'em',\n\t\tp: '%',\n\t\tx: 'ex',\n\t\tr: 'rem'\n\t},\n\tfuzzySearchMinScore: 0\n};\n\n/**\n * For every node in given `tree`, finds matching snippet from `registry` and\n * updates node with snippet data.\n *\n * This resolver uses fuzzy matching for searching matched snippets and their\n * keyword values.\n */\n\nfunction index(tree, registry, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\toptions.unitAliases = Object.assign({}, defaultOptions.unitAliases, options && options.unitAliases);\n\n\tconst snippets = convertToCSSSnippets(registry);\n\n\ttree.walk(node => resolveNode(node, snippets, options));\n\treturn tree;\n}\n\nfunction convertToCSSSnippets(registry) {\n\treturn cssSnippets(registry.all({type: 'string'}));\n}\n\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n * @param  {Node} node\n * @param  {CSSSnippet[]} snippets\n * @param  {Object} options\n * @return {Node}\n */\nfunction resolveNode(node, snippets, options) {\n\tif (options.property) {\n\t\t// Resolve as value of given CSS property\n\t\treturn resolveAsPropertyValue(node, snippets.find(snippet => snippet.property === options.property), options);\n\t}\n\n\tconst snippet = findBestMatch(node.name, snippets, 'key', options.fuzzySearchMinScore);\n\n\tif (!snippet) {\n\t\t// Edge case: `!important` snippet\n\t\treturn node.name === '!' ? setNodeAsText(node, '!important') : node;\n\t}\n\n\treturn snippet.property\n\t\t? resolveAsProperty(node, snippet, options)\n\t\t: resolveAsSnippet(node, snippet);\n}\n\n/**\n * Resolves given parsed abbreviation node as CSS property\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @param  {Object} formatOptions\n * @return {Node}\n */\nfunction resolveAsProperty(node, snippet, formatOptions) {\n\tconst abbr = node.name;\n\tnode.name = snippet.property;\n\n\tif (node.value && typeof node.value === 'object') {\n\t\t// resolve keyword shortcuts\n\t\tconst keywords = snippet.keywords();\n\n\t\tif (!node.value.size) {\n\t\t\t// no value defined, try to resolve unmatched part as a keyword alias\n\t\t\tlet kw = findBestMatch(getUnmatchedPart(abbr, snippet.key), keywords);\n\n\t\t\tif (!kw) {\n\t\t\t\t// no matching value, try to get default one\n\t\t\t\tkw = snippet.defaultValue;\n\t\t\t\tif (kw && kw.indexOf('${') === -1) {\n\t\t\t\t\t// Quick and dirty test for existing field. If not, wrap\n\t\t\t\t\t// default value in a field\n\t\t\t\t\tkw = `\\${1:${kw}}`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (kw) {\n\t\t\t\tnode.value.add(kw);\n\t\t\t}\n\t\t} else {\n\t\t\t// replace keyword aliases in current node value\n\t\t\tfor (let i = 0, token; i < node.value.value.length; i++) {\n\t\t\t\ttoken = node.value.value[i];\n\n\t\t\t\tif (token === '!') {\n\t\t\t\t\ttoken = `${!i ? '${1} ' : ''}!important`;\n\t\t\t\t} else if (isKeyword$1(token)) {\n\t\t\t\t\ttoken = findBestMatch(token.value, keywords)\n\t\t\t\t\t\t|| findBestMatch(token.value, globalKeywords)\n\t\t\t\t\t\t|| token;\n\t\t\t\t} else if (isNumericValue(token)) {\n\t\t\t\t\ttoken = resolveNumericValue(node.name, token, formatOptions);\n\t\t\t\t}\n\n\t\t\t\tnode.value.value[i] = token;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node;\n}\n\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @return {Node}\n */\nfunction resolveAsSnippet(node, snippet) {\n\treturn setNodeAsText(node, snippet.value);\n}\n\n/**\n * Resolves given parsed abbreviation node as property value of given `snippet`:\n * tries to find best matching keyword from CSS snippet\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @param {Object} options\n * @return {Node}\n */\nfunction resolveAsPropertyValue(node, snippet, options) {\n\t// Possible resolved result for CSS property:\n\t// * matched snippet keyword\n\t// * color (starts with #)\n\t// Everything else should result the same as input abbreviation\n\tlet keywords = globalKeywords.slice();\n\tif (snippet) {\n\t\tkeywords = keywords.concat(snippet.keywords());\n\t}\n\n\tconst values = [node.name].concat(node.value.value)\n\t\t.filter(Boolean)\n\t\t.map(value => {\n\t\t\tif (typeof value === 'string' || value.type === 'keyword') {\n\t\t\t\tvalue = String(value);\n\t\t\t\treturn findBestMatch(value, keywords, null, options.fuzzySearchMinScore) || value;\n\t\t\t}\n\n\t\t\treturn value;\n\t\t});\n\n\tnode.name = null;\n\tnode.value.value = values;\n\n\treturn node;\n}\n\n/**\n * Sets given parsed abbreviation node as a text snippet\n * @param {Node} node\n * @param {String} text\n * @return {Node}\n */\nfunction setNodeAsText(node, text) {\n\tnode.name = null;\n\tnode.value = text;\n\treturn node;\n}\n\n/**\n * Finds best matching item from `items` array\n * @param {String} abbr  Abbreviation to match\n * @param {Array}  items List of items for match\n * @param {String} [key] If `items` is a list of objects, use `key` as object\n * property to test against\n * @param {Number} fuzzySearchMinScore The minimum score the best matched item should have to be a valid match.\n * @return {*}\n */\nfunction findBestMatch(abbr, items, key, fuzzySearchMinScore) {\n\tif (!abbr) {\n\t\treturn null;\n\t}\n\n\tlet matchedItem = null;\n\tlet maxScore = 0;\n\tfuzzySearchMinScore = fuzzySearchMinScore || 0;\n\n\tfor (let i = 0, item; i < items.length; i++) {\n\t\titem = items[i];\n\t\tconst score = stringScore(abbr, getScoringPart(item, key));\n\n\t\tif (score === 1) {\n\t\t\t// direct hit, no need to look further\n\t\t\treturn item;\n\t\t}\n\n\t\tif (score && score >= maxScore) {\n\t\t\tmaxScore = score;\n\t\t\tmatchedItem = item;\n\t\t}\n\t}\n\n\treturn maxScore >= fuzzySearchMinScore ? matchedItem : null;\n}\n\nfunction getScoringPart(item, key) {\n\tconst value = item && typeof item === 'object' ? item[key] : item;\n\tconst m = (value || '').match(/^[\\w-@]+/);\n\treturn m ? m[0] : value;\n}\n\n/**\n * Returns a part of `abbr` that wasn’t directly matched agains `string`.\n * For example, if abbreviation `poas` is matched against `position`, the unmatched part will be `as`\n * since `a` wasn’t found in string stream\n * @param {String} abbr\n * @param {String} string\n * @return {String}\n */\nfunction getUnmatchedPart(abbr, string) {\n\tfor (let i = 0, lastPos = 0; i < abbr.length; i++) {\n\t\tlastPos = string.indexOf(abbr[i], lastPos);\n\t\tif (lastPos === -1) {\n\t\t\treturn abbr.slice(i);\n\t\t}\n\t\tlastPos++;\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if given CSS value token is a keyword\n * @param {*} token\n * @return {Boolean}\n */\nfunction isKeyword$1(token) {\n\treturn tokenTypeOf(token, 'keyword');\n}\n\n/**\n * Check if given CSS value token is a numeric value\n * @param  {*}  token\n * @return {Boolean}\n */\nfunction isNumericValue(token) {\n\treturn tokenTypeOf(token, 'numeric');\n}\n\nfunction tokenTypeOf(token, type) {\n\treturn token && typeof token === 'object' && token.type === type;\n}\n\n/**\n * Resolves numeric value for given CSS property\n * @param  {String} property    CSS property name\n * @param  {NumericValue} token CSS numeric value token\n * @param  {Object} formatOptions Formatting options for units\n * @return {NumericValue}\n */\nfunction resolveNumericValue(property, token, formatOptions) {\n\tif (token.unit) {\n\t\ttoken.unit = formatOptions.unitAliases[token.unit] || token.unit;\n\t} else if (token.value !== 0 && unitlessProperties.indexOf(property) === -1) {\n\t\t// use `px` for integers, `em` for floats\n\t\t// NB: num|0 is a quick alternative to Math.round(0)\n\t\ttoken.unit = token.value === (token.value|0) ? formatOptions.intUnit : formatOptions.floatUnit;\n\t}\n\n\treturn token;\n}\n\nexport default index;\nexport { convertToCSSSnippets, stringScore, cssSnippets };\n//# sourceMappingURL=css-snippets-resolver.es.js.map\n","import render from '@emmetio/output-renderer';\nimport parseFields from '@emmetio/field-parser';\n\nconst defaultFormatOptions = {\n\tshortHex: true,\n\tbetween: ': ',\n\tafter: ';'\n};\n\n/**\n * Renders given parsed Emmet CSS abbreviation as CSS-like\n * stylesheet, formatted according to `profile` options\n * @param  {Node}     tree    Parsed Emmet abbreviation\n * @param  {Profile}  profile Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction css(tree, profile, options) {\n\toptions = options || {};\n\tconst formatOpt = Object.assign({}, defaultFormatOptions, options && options.format);\n\n\treturn render(tree, options.field, outNode => {\n\t\tconst node = outNode.node;\n\t\tlet value = stringifyValue(node, formatOpt);\n\n\t\tif (node.attributes.length) {\n\t\t\tconst fieldValues = node.attributes.map(attr => stringifyValue(attr, formatOpt));\n\t\t\tvalue = injectFields(value, fieldValues);\n\t\t}\n\n\t\toutNode.open = node.name && profile.name(node.name);\n\t\toutNode.afterOpen = formatOpt.between;\n\t\toutNode.text = outNode.renderFields(value || null);\n\n\t\tif (outNode.open && (!outNode.text || !outNode.text.endsWith(';'))) {\n\t\t\toutNode.afterText = formatOpt.after;\n\t\t}\n\n\t\tif (profile.get('format')) {\n\t\t\toutNode.newline = '\\n';\n\t\t\tif (tree.lastChild !== node) {\n\t\t\t\toutNode.afterText += outNode.newline;\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Injects given field values at each field of given string\n * @param  {String}   string\n * @param  {String[]} attributes\n * @return {FieldString}\n */\nfunction injectFields(string, values) {\n\tconst fieldsModel = parseFields(string);\n\tconst fieldsAmount = fieldsModel.fields.length;\n\n\tif (fieldsAmount) {\n\t\tvalues = values.slice();\n\t\tif (values.length > fieldsAmount) {\n\t\t\t// More values that output fields: collapse rest values into\n\t\t\t// a single token\n\t\t\tvalues = values.slice(0, fieldsAmount - 1)\n\t\t\t\t.concat(values.slice(fieldsAmount - 1).join(', '));\n\t\t}\n\n\t\twhile (values.length) {\n\t\t\tconst value = values.shift();\n\t\t\tconst field = fieldsModel.fields.shift();\n\t\t\tconst delta = value.length - field.length;\n\n\t\t\tfieldsModel.string = fieldsModel.string.slice(0, field.location)\n\t\t\t\t+ value\n\t\t\t\t+ fieldsModel.string.slice(field.location + field.length);\n\n\t\t\t// Update location of the rest fields in string\n\t\t\tfor (let i = 0, il = fieldsModel.fields.length; i < il; i++) {\n\t\t\t\tfieldsModel.fields[i].location += delta;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fieldsModel;\n}\n\nfunction stringifyValue(node, options) {\n\tif (node.value && typeof node.value === 'object' && node.value.type === 'css-value') {\n\t\treturn node.value.value\n\t\t.map(token => {\n\t\t\tif (token && typeof token === 'object') {\n\t\t\t\treturn token.type === 'color'\n\t\t\t\t\t? token.toString(options.shortHex)\n\t\t\t\t\t: token.toString();\n\t\t\t}\n\n\t\t\treturn String(token);\n\t\t})\n\t\t.join(' ');\n\t}\n\n\treturn node.value != null ? String(node.value) : '';\n}\n\nconst syntaxFormat = {\n\tcss: {\n\t\tbetween: ': ',\n\t\tafter: ';'\n\t},\n\tscss: 'css',\n\tless: 'css',\n\tsass: {\n\t\tbetween: ': ',\n\t\tafter: ''\n\t},\n\tstylus: {\n\t\tbetween: ' ',\n\t\tafter: ''\n\t}\n};\n\n/**\n * Outputs given parsed abbreviation in specified stylesheet syntax\n * @param {Node}     tree     Parsed abbreviation tree\n * @param {Profile}  profile  Output profile\n * @param {String}   [syntax] Output syntax. If not given, `css` syntax is used\n * @param {Function} options.field A function to output field/tabstop for\n * host editor. This function takes two arguments: `index` and `placeholder` and\n * should return a string that represents tabstop in host editor. By default\n * only a placeholder is returned\n * @example\n * {\n * \tfield(index, placeholder) {\n * \t\t// return field in TextMate-style, e.g. ${1} or ${2:foo}\n * \t\treturn `\\${${index}${placeholder ? ':' + placeholder : ''}}`;\n *  }\n * }\n * @return {String}\n */\nfunction index(tree, profile, syntax, options) {\n\tif (typeof syntax === 'object') {\n\t\toptions = syntax;\n\t\tsyntax = null;\n\t}\n\n\tif (!supports(syntax)) {\n\t\t// fallback to CSS if given syntax is not supported\n\t\tsyntax = 'css';\n\t}\n\n\toptions = Object.assign({}, options, {\n\t\tformat: getFormat(syntax, options)\n\t});\n\n\t// CSS abbreviations doesn’t support nesting so simply\n\t// output root node children\n\treturn css(tree, profile, options);\n}\n\n/**\n * Check if given syntax is supported\n * @param {String} syntax\n * @return {Boolean}\n */\nfunction supports(syntax) {\n\treturn !!syntax && syntax in syntaxFormat;\n}\n\n/**\n * Returns formatter object for given syntax\n * @param  {String} syntax\n * @param  {Object} [options]\n * @return {Object} Formatter object as defined in `syntaxFormat`\n */\nfunction getFormat(syntax, options) {\n\tlet format = syntaxFormat[syntax];\n\tif (typeof format === 'string') {\n\t\tformat = syntaxFormat[format];\n\t}\n\n\treturn Object.assign({}, format, options && options.format);\n}\n\nexport default index;\nexport { supports };\n//# sourceMappingURL=stylesheet-formatters.es.js.map\n","var html = {\n\t\"a\": \"a[href]\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"style\": \"style\",\n\t\"script\": \"script[!src]\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:button\": \"input[type=button value]\",\n    \"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+meta:edge+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar css = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${1});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:flex-start|flex-end|center|space-between|space-around|stretch\",\n\t\"ai\": \"align-items:flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:${1:time}\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:#${1:000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:#${1:000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:#${1:000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:#${1:000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:#${1:000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:#${1:000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} #${5:000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:#${1:000}\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters({$0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fz\": \"font-size\",\n\t\"fza\": \"font-size-adjust\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:flex-start|flex-end|center|space-between|space-around\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:#${1:000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xsl = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar index = { html, css, xsl };\n\nexport default index;\n","import resolveImplicitTag from '@emmetio/implicit-tag';\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst langs = { latin, ru, sp };\n\nconst defaultOptions = {\n\twordCount: 30,\n\tskipCommon: false,\n\tlang: 'latin'\n};\n\n/**\n * Replaces given parsed Emmet abbreviation node with nodes filled with\n * Lorem Ipsum stub text.\n * @param {Node} node\n * @return {Node}\n */\nvar index = function(node, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\tconst dict = langs[options.lang] || langs.latin;\n    const startWithCommon = !options.skipCommon && !isRepeating(node);\n\n\tif (!node.repeat && !isRoot(node.parent)) {\n\t\t// non-repeating element, insert text stub as a content of parent node\n\t\t// and remove current one\n\t\tnode.parent.value = paragraph(dict, options.wordCount, startWithCommon);\n\t\tnode.remove();\n\t} else {\n\t\t// Replace named node with generated content\n\t\tnode.value = paragraph(dict, options.wordCount, startWithCommon);\n\t\tnode.name = node.parent.name ? resolveImplicitTag(node.parent.name) : null;\n\t}\n\n\treturn node;\n};\n\nfunction isRoot(node) {\n\treturn !node.parent;\n}\n\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n * @param {Number} from\n * @param {Number} to\n * @returns {Number}\n */\nfunction rand(from, to) {\n\treturn Math.floor(Math.random() * (to - from) + from);\n}\n\n/**\n * @param {Array} arr\n * @param {Number} count\n * @returns {Array}\n */\nfunction sample(arr, count) {\n\tconst len = arr.length;\n\tconst iterations = Math.min(len, count);\n\tconst result = new Set();\n\n\twhile (result.size < iterations) {\n\t\tresult.add(arr[rand(0, len)]);\n\t}\n\n\treturn Array.from(result);\n}\n\nfunction choice(val) {\n\treturn val[rand(0, val.length - 1)];\n}\n\nfunction sentence(words, end) {\n\tif (words.length) {\n\t\twords = [capitalize(words[0])].concat(words.slice(1));\n\t}\n\n\treturn words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\n\nfunction capitalize(word) {\n\treturn word[0].toUpperCase() + word.slice(1);\n}\n\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside <code>words</code> array\n * @param {Array} words\n */\nfunction insertCommas(words) {\n\tif (words.length < 2) {\n\t\treturn words;\n\t}\n\n\twords = words.slice();\n\tconst len = words.length;\n\tconst hasComma = /,$/;\n\tlet totalCommas = 0;\n\n\tif (len > 3 && len <= 6) {\n\t\ttotalCommas = rand(0, 1);\n\t} else if (len > 6 && len <= 12) {\n\t\ttotalCommas = rand(0, 2);\n\t} else {\n\t\ttotalCommas = rand(1, 4);\n\t}\n\n\tfor (let i = 0, pos, word; i < totalCommas; i++) {\n\t\tpos = rand(0, len - 2);\n\t\tif (!hasComma.test(words[pos])) {\n\t\t\twords[pos] += ',';\n\t\t}\n\t}\n\n\treturn words;\n}\n\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param {Object} dict Words dictionary (see `lang/*.json`)\n * @param {Number} wordCount Words count in paragraph\n * @param {Boolean} startWithCommon Should paragraph start with common\n * \"lorem ipsum\" sentence.\n * @returns {String}\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n\tconst result = [];\n\tlet totalWords = 0;\n\tlet words;\n\n\tif (startWithCommon && dict.common) {\n\t\twords = dict.common.slice(0, wordCount);\n\t\ttotalWords += words.length;\n\t\tresult.push(sentence(insertCommas(words), '.'));\n\t}\n\n\twhile (totalWords < wordCount) {\n\t\twords = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n\t\ttotalWords += words.length;\n\t\tresult.push(sentence(insertCommas(words)));\n\t}\n\n\treturn result.join(' ');\n}\n\n/**\n * Check if given node is in repeating context, e.g. node itself or one of its\n * parent is repeated\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isRepeating(node) {\n    while (node.parent) {\n        if (node.repeat && node.repeat.value && node.repeat.value > 1) {\n            return true;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\nexport default index;\n","class Snippet {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n\nclass SnippetsStorage {\n    constructor(data) {\n        this._string = new Map();\n        this._regexp = new Map();\n        this._disabled = false;\n\n        this.load(data);\n    }\n\n    get disabled() {\n        return this._disabled;\n    }\n\n    /**\n     * Disables current store. A disabled store always returns `undefined`\n     * on `get()` method\n     */\n    disable() {\n        this._disabled = true;\n    }\n\n    /**\n     * Enables current store.\n     */\n    enable() {\n        this._disabled = false;\n    }\n\n    /**\n     * Registers a new snippet item\n     * @param {String|Regexp} key\n     * @param {String|Function} value\n     */\n    set(key, value) {\n        if (typeof key === 'string') {\n            key.split('|').forEach(k => this._string.set(k, new Snippet(k, value)));\n        } else if (key instanceof RegExp) {\n            this._regexp.set(key, new Snippet(key, value));\n        } else {\n            throw new Error('Unknow snippet key: ' + key);\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns a snippet matching given key. It first tries to find snippet\n     * exact match in a string key map, then tries to match one with regexp key\n     * @param {String} key\n     * @return {Snippet}\n     */\n    get(key) {\n        if (this.disabled) {\n            return undefined;\n        }\n\n        if (this._string.has(key)) {\n            return this._string.get(key);\n        }\n\n        const keys = Array.from(this._regexp.keys());\n        for (let i = 0, il = keys.length; i < il; i++) {\n            if (keys[i].test(key)) {\n                return this._regexp.get(keys[i]);\n            }\n        }\n    }\n\n    /**\n     * Batch load of snippets data\n     * @param {Object|Map} data\n     */\n    load(data) {\n        this.reset();\n        if (data instanceof Map) {\n            data.forEach((value, key) => this.set(key, value));\n        } else if (data && typeof data === 'object') {\n            Object.keys(data).forEach(key => this.set(key, data[key]));\n        }\n    }\n\n    /**\n     * Clears all stored snippets\n     */\n    reset() {\n        this._string.clear();\n        this._regexp.clear();\n    }\n\n    /**\n     * Returns all available snippets from given store\n     */\n    values() {\n        if (this.disabled) {\n            return [];\n        }\n        \n        const string = Array.from(this._string.values());\n        const regexp = Array.from(this._regexp.values());\n        return string.concat(regexp);\n    }\n}\n\n/**\n * A snippets registry. Contains snippets, separated by store and sorted by\n * priority: a store with higher priority takes precedence when resolving snippet\n * for given key\n */\nclass SnippetsRegistry {\n    /**\n     * Creates snippets registry, filled with given `data`\n     * @param {Object|Array} data Registry snippets. If array is given, adds items\n     * from array in order of precedence, registers global snippets otherwise\n     */\n    constructor(data) {\n        this._registry = [];\n\n        if (Array.isArray(data)) {\n            data.forEach((snippets, level) => this.add(level, snippets));\n        } else if (typeof data === 'object') {\n            this.add(data);\n        }\n    }\n\n    /**\n     * Return store for given level\n     * @param {Number} level\n     * @return {SnippetsStorage}\n     */\n    get(level) {\n        for (let i = 0; i < this._registry.length; i++) {\n            const item = this._registry[i];\n            if (item.level === level) {\n                return item.store;\n            }\n        }\n    }\n\n    /**\n     * Adds new store for given level\n     * @param {Number} [level] Store level (priority). Store with higher level\n     * takes precedence when resolving snippets\n     * @param {Object} [snippets] A snippets data for new store\n     * @return {SnipetsStorage}\n     */\n    add(level, snippets) {\n        if (level != null && typeof level === 'object') {\n            snippets = level;\n            level = 0;\n        }\n\n        const store = new SnippetsStorage(snippets);\n\n        // remove previous store from same level\n        this.remove(level);\n\n        this._registry.push({level, store});\n        this._registry.sort((a, b) => b.level - a.level);\n\n        return store;\n    }\n\n    /**\n     * Remove registry with given level or store\n     * @param {Number|SnippetsStorage} data Either level or snippets store\n     */\n    remove(data) {\n        this._registry = this._registry\n        .filter(item => item.level !== data && item.store !== data);\n    }\n\n    /**\n     * Returns snippet from registry that matches given name\n     * @param {String} name\n     * @return {Snippet}\n     */\n    resolve(name) {\n        for (let i = 0; i < this._registry.length; i++) {\n            const snippet = this._registry[i].store.get(name);\n            if (snippet) {\n                return snippet;\n            }\n        }\n    }\n\n    /**\n     * Returns all available snippets from current registry. Snippets with the\n     * same key are resolved by their storage priority.\n     * @param {Object} options\n     * @param {Object} options.type Return snippets only of given type: 'string'\n     * or 'regexp'. Returns all snippets if not defined\n     * @return {Array}\n     */\n    all(options) {\n        options = options || {};\n        const result = new Map();\n\n        const fillResult = snippet => {\n            const type = snippet.key instanceof RegExp ? 'regexp' : 'string';\n            if ((!options.type || options.type === type) && !result.has(snippet.key)) {\n                result.set(snippet.key, snippet);\n            }\n        };\n\n        this._registry.forEach(item => {\n            item.store.values().forEach(fillResult);\n        });\n\n        return Array.from(result.values());\n    }\n\n    /**\n     * Removes all stores from registry\n     */\n    clear() {\n        this._registry.length = 0;\n    }\n}\n\nexport default SnippetsRegistry;\n","/**\n * @type {EmmetOutputProfile}\n */\nvar defaultOptions = {\n\tindent: '\\t',\n\ttagCase: '',\n\tattributeCase: '',\n\tattributeQuotes: 'double',\n\tformat: true,\n\tformatSkip: ['html'],\n\tformatForce: ['body'],\n\tinlineBreak: 3,\n\tcompactBooleanAttributes: false,\n\tbooleanAttributes: ['contenteditable', 'seamless', 'async', 'autofocus',\n\t\t'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n\t\t'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n\t\t'required', 'reversed', 'selected', 'typemustmatch'],\n\tselfClosingStyle: 'html',\n\tinlineElements: ['a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n\t\t'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n\t\t'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n\t\t's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n\t\t'textarea', 'tt', 'u', 'var']\n};\n\n/**\n * Creates output profile for given options\n */\nclass Profile {\n\t/**\n\t * @param {EmmetOutputProfile} options \n\t */\n    constructor(options) {\n\t\t/** @type {EmmetOutputProfile} */\n\t\tthis.options = Object.assign({}, defaultOptions, options);\n\t\tthis.quoteChar = this.options.attributeQuotes === 'single' ? '\\'' : '\"';\n    }\n\n\t/**\n\t * Returns value of given option name\n\t * @param {String} name\n\t * @return {*}\n\t */\n\tget(name) {\n\t\treturn this.options[name];\n\t}\n\n    /**\n     * Quote given string according to profile\n     * @param {String} str String to quote\n     * @return {String}\n     */\n    quote(str) {\n        return `${this.quoteChar}${str != null ? str : ''}${this.quoteChar}`;\n    }\n\n    /**\n     * Output given tag name according to options\n     * @param {String} name\n     * @return {String}\n     */\n    name(name) {\n        return strcase(name, this.options.tagCase);\n    }\n\n\t/**\n\t * Outputs attribute name according to current settings\n\t * @param {String} attr Attribute name\n\t * @return {String}\n\t */\n    attribute(attr) {\n        return strcase(attr, this.options.attributeCase);\n    }\n\n    /**\n     * Check if given attribute is boolean\n     * @param {Object} attr\n     * @return {Boolean}\n     */\n    isBooleanAttribute(attr) {\n        return attr.options.boolean\n\t\t\t|| this.get('booleanAttributes').indexOf((attr.name || '').toLowerCase()) !== -1;\n    }\n\n\t/**\n\t * Returns a token for self-closing tag, depending on current options\n\t * @return {String}\n\t */\n\tselfClose() {\n\t\tswitch (this.options.selfClosingStyle) {\n\t\t\tcase 'xhtml': return ' /';\n\t\t\tcase 'xml':   return '/';\n\t\t\tdefault:      return '';\n\t\t}\n\t}\n\n\t/**\n\t * Returns indent for given level\n\t * @param {Number} level Indentation level\n\t * @return {String}\n\t */\n\tindent(level) {\n\t\tlevel = level || 0;\n\t\tlet output = '';\n\t\twhile (level--) {\n\t\t\toutput += this.options.indent;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\t/**\n\t * Check if given tag name belongs to inline-level element\n\t * @param {Object|String} node Parsed node or tag name\n\t * @return {Boolean}\n\t */\n\tisInline(node) {\n        if (typeof node === 'string') {\n            return this.get('inlineElements').indexOf(node.toLowerCase()) !== -1;\n        }\n\n        // inline node is a node either with inline-level name or text-only node\n        return node.name != null ? this.isInline(node.name) : node.isTextOnly;\n\t}\n\n\t/**\n\t * Outputs formatted field for given params\n\t * @param {Number} index Field index\n\t * @param {String} [placeholder] Field placeholder, can be empty\n\t * @return {String}\n\t */\n\tfield(index, placeholder) {\n\t\treturn this.options.field(index, placeholder);\n\t}\n}\nfunction strcase(string, type) {\n    if (type) {\n        return type === 'upper' ? string.toUpperCase() : string.toLowerCase();\n\t}\n\t\n    return string;\n}\n\nexport default Profile;\n","import parseAbbreviation from '@emmetio/abbreviation';\nimport resolveSnippets from '@emmetio/html-snippets-resolver';\nimport transform from '@emmetio/html-transform';\nimport resolveVariables from '@emmetio/variable-resolver';\nimport format from '@emmetio/markup-formatters';\nimport parseAbbreviation$1 from '@emmetio/css-abbreviation';\nimport resolveSnippets$1 from '@emmetio/css-snippets-resolver';\nimport format$1 from '@emmetio/stylesheet-formatters';\nimport defaultSnippets from '@emmetio/snippets';\nimport lorem from '@emmetio/lorem';\nimport SnippetsRegistry from '@emmetio/snippets-registry';\nimport Profile from '@emmetio/output-profile';\n\n/**\n * Expands given abbreviation into code\n * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation\n * @param  {Object} config\n * @return {String}\n */\nfunction expand(abbr, config) {\n\tconfig = Object.assign({}, config);\n\n\tif (typeof abbr === 'string') {\n\t\tabbr = parse(abbr, config);\n\t}\n\n\treturn format(abbr, config.profile, config.syntax, config);\n}\n\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n * @param {String} Abbreviation to parse\n * @param  {Object} config\n * @return {Node}\n */\nfunction parse(abbr, config) {\n\treturn parseAbbreviation(abbr)\n\t\t.use(resolveSnippets, config.snippets)\n\t\t.use(resolveVariables, config.variables)\n\t\t.use(transform, config.text, config.options);\n}\n\n/**\n * Expands given abbreviation into code\n * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation\n * @param  {Object} config\n * @return {String}\n */\nfunction expand$1(abbr, config) {\n\tconfig = config || {};\n\n\tif (typeof abbr === 'string') {\n\t\tabbr = parse$1(abbr, config);\n\t}\n\n\treturn format$1(abbr, config.profile, config.syntax, config);\n}\n\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n * @param {String|Node} abbr Abbreviation to parse or already parsed abbreviation\n * @param  {Object} config\n * @return {Node}\n */\nfunction parse$1(abbr, config) {\n\tif (typeof abbr === 'string') {\n\t\tabbr = parseAbbreviation$1(abbr);\n\t}\n\n\treturn abbr.use(resolveSnippets$1, config.snippets, config.options);\n}\n\nconst reLorem = /^lorem([a-z]*)(\\d*)$/i;\n\n/**\n * Constructs a snippets registry, filled with snippets, for given options\n * @param  {String} syntax  Abbreviation syntax\n * @param  {Object|Object[]} snippets Additional snippets\n * @return {SnippetsRegistry}\n */\nfunction snippetsRegistryFactory(type, syntax, snippets) {\n\tconst registrySnippets = [];\n\n\tif (type === 'markup') {\n\t\tregistrySnippets.push(defaultSnippets.html);\n\t} else if (type === 'stylesheet') {\n\t\tregistrySnippets.push(defaultSnippets.css);\n\t}\n\n\tif (syntax in defaultSnippets && registrySnippets.indexOf(defaultSnippets[syntax]) === -1) {\n\t\tregistrySnippets.push(defaultSnippets[syntax]);\n\t}\n\n\tif (Array.isArray(snippets)) {\n\t\tsnippets.forEach(item => {\n\t\t\t// if array item is a string, treat it as a reference to globally\n\t\t\t// defined snippets\n\t\t\tregistrySnippets.push(typeof item === 'string' ? defaultSnippets[item] : item);\n\t\t});\n\t} else if (typeof snippets === 'object') {\n\t\tregistrySnippets.push(snippets);\n\t}\n\n\tconst registry = new SnippetsRegistry(registrySnippets.filter(Boolean));\n\n\t// for non-stylesheet syntaxes add Lorem Ipsum generator\n\tif (type !== 'stylesheet') {\n\t\tregistry.get(0).set(reLorem, loremGenerator);\n\t}\n\n\treturn registry;\n}\n\nfunction loremGenerator(node) {\n\tconst options = {};\n\tconst m = node.name.match(reLorem);\n\tif (m[1]) {\n\t\toptions.lang = m[1];\n\t}\n\n\tif (m[2]) {\n\t\toptions.wordCount = +m[2];\n\t}\n\n\treturn lorem(node, options);\n}\n\n/**\n * Default variables used in snippets to insert common values into predefined snippets\n * @type {Object}\n */\nconst defaultVariables = {\n\tlang: 'en',\n\tlocale: 'en-US',\n\tcharset: 'UTF-8'\n};\n\n/**\n * A list of syntaxes that should use Emmet CSS abbreviations:\n * a variations of default abbreviation that holds values right in abbreviation name\n * @type {Array}\n */\nconst stylesheetSyntaxes = ['css', 'sass', 'scss', 'less', 'stylus', 'sss'];\n\nconst defaultOptions = {\n\t/**\n\t * Type of abbreviation to parse: 'markup' or 'stylesheet'.\n\t * Can be auto-detected from `syntax` property. Default is 'markup'\n\t */\n\ttype: null,\n\n\t/**\n\t * Abbreviation output syntax\n\t * @type {String}\n\t */\n\tsyntax: 'html',\n\n\t/**\n\t * Field/tabstop generator for editor. Most editors support TextMate-style\n\t * fields: ${0} or ${1:item}. So for TextMate-style fields this function\n\t * will look like this:\n\t * @example\n\t * (index, placeholder) => `\\${${index}${placeholder ? ':' + placeholder : ''}}`\n\t *\n\t * @param  {Number} index         Placeholder index. Fields with the same indices\n\t * should be linked\n\t * @param  {String} [placeholder] Field placeholder\n\t * @return {String}\n\t */\n\tfield: (index, placeholder) => placeholder || '',\n\n\t/**\n\t * Insert given text string(s) into expanded abbreviation\n\t * If array of strings is given, the implicitly repeated element (e.g. `li*`)\n\t * will be repeated by the amount of items in array\n\t * @type {String|String[]}\n\t */\n\ttext: null,\n\n\t/**\n\t * Either predefined output profile or options for output profile. Used for\n\t * abbreviation output\n\t * @type {Profile|Object}\n\t */\n\tprofile: null,\n\n\t/**\n\t * Custom variables for variable resolver\n\t * @see @emmetio/variable-resolver\n\t * @type {Object}\n\t */\n\tvariables: {},\n\n\t/**\n\t * Custom predefined snippets for abbreviation. The expanded abbreviation\n\t * will try to match given snippets that may contain custom elements,\n\t * predefined attributes etc.\n\t * May also contain array of items: either snippets (Object) or references\n\t * to default syntax snippets (String; the key in default snippets hash)\n\t * @see @emmetio/snippets\n\t * @type {Object|SnippetsRegistry}\n\t */\n\tsnippets: {},\n\n\t/**\n\t * Hash of additional transformations that should be applied to expanded\n\t * abbreviation, like BEM or JSX. Since these transformations introduce\n\t * side-effect, they are disabled by default and should be enabled by\n\t * providing a transform name as a key and transform options as value:\n\t * @example\n\t * {\n\t *     bem: {element: '--'},\n\t *     jsx: true // no options, just enable transform\n\t * }\n\t * @see @emmetio/html-transform/lib/addons\n\t * @type {Object}\n\t */\n\toptions: null,\n\n\t/**\n\t * Additional options for syntax formatter\n\t * @see @emmetio/markup-formatters\n\t * @type {Object}\n\t */\n\tformat: null\n};\n\n/**\n * Expands given abbreviation into string, formatted according to provided\n * syntax and options\n * @param  {String|Node} abbr       Abbreviation string or parsed abbreviation tree\n * @param  {String|Object} [config] Parsing and formatting options (object) or\n * abbreviation syntax (string)\n * @return {String}\n */\nfunction expand$2(abbr, config) {\n\tconfig = createOptions(config);\n\n\treturn getType(config.type, config.syntax) === 'stylesheet'\n\t\t? expand$1(abbr, config)\n\t\t: expand(abbr, config);\n}\n\n/**\n * Parses given abbreviation into AST tree. This tree can be later formatted to\n * string with `expand` function\n * @param  {String} abbr             Abbreviation to parse\n * @param  {String|Object} [options] Parsing and formatting options (object) or\n * abbreviation syntax (string)\n * @return {Node}\n */\nfunction parse$2(abbr, options) {\n\toptions = createOptions(options);\n\n\treturn getType(options.type, options.syntax) === 'stylesheet'\n\t\t? parse$1(abbr, options)\n\t\t: parse(abbr, options);\n}\n\n/**\n * Creates snippets registry for given syntax and additional `snippets`\n * @param  {String} type     Abbreviation type, 'markup' or 'stylesheet'\n * @param  {String} syntax   Snippets syntax, used for retrieving predefined snippets\n * @param  {SnippetsRegistry|Object|Object[]} [snippets] Additional snippets\n * @return {SnippetsRegistry}\n */\nfunction createSnippetsRegistry(type, syntax, snippets) {\n\t// Backward-compatibility with <0.6\n\tif (type && type !== 'markup' && type !== 'stylesheet') {\n\t\tsnippets = syntax;\n\t\tsyntax = type;\n\t\ttype = 'markup';\n\t}\n\n\treturn snippets instanceof SnippetsRegistry\n\t\t? snippets\n\t\t: snippetsRegistryFactory(type, syntax, snippets);\n}\n\nfunction createOptions(options) {\n\tif (typeof options === 'string') {\n\t\toptions = { syntax: options };\n\t}\n\n\toptions = Object.assign({}, defaultOptions, options);\n\tif (options.type == null && options.syntax) {\n\t\toptions.type = isStylesheet(options.syntax) ? 'stylesheet' : 'markup';\n\t}\n\n\toptions.format = Object.assign({field: options.field}, options.format);\n\toptions.profile = createProfile(options);\n\toptions.variables = Object.assign({}, defaultVariables, options.variables);\n\toptions.snippets = createSnippetsRegistry(options.type, options.syntax, options.snippets);\n\n\treturn options;\n}\n\n/**\n * Check if given syntax belongs to stylesheet markup.\n * Emmet uses different abbreviation flavours: one is a default markup syntax,\n * used for HTML, Slim, Pug etc, the other one is used for stylesheets and\n * allows embedded values in abbreviation name\n * @param  {String}  syntax\n * @return {Boolean}\n */\nfunction isStylesheet(syntax) {\n\treturn stylesheetSyntaxes.indexOf(syntax) !== -1;\n}\n\n/**\n * Creates output profile from given options\n * @param  {Object} options\n * @return {Profile}\n */\nfunction createProfile(options) {\n\treturn options.profile instanceof Profile\n\t\t? options.profile\n\t\t: new Profile(options.profile);\n}\n\n/**\n * Returns type of abbreviation expander: either 'markup' or 'stylesheet'\n * @param {String} type\n * @param {String} [syntax]\n */\nfunction getType(type, syntax) {\n\tif (type) {\n\t\treturn type === 'stylesheet' ? 'stylesheet' : 'markup';\n\t}\n\n\treturn isStylesheet(syntax) ? 'stylesheet' : 'markup';\n}\n\nexport { expand$2 as expand, parse$2 as parse, createSnippetsRegistry, createOptions, isStylesheet, createProfile };\n//# sourceMappingURL=expand.es.js.map\n","/**\n * Minimalistic backwards stream reader\n */\nclass StreamReader {\n\tconstructor(string, start) {\n\t\tthis.string = string;\n\t\tthis.start = start || 0;\n\t\tthis.pos = this.string.length;\n\t}\n\n\tsol() {\n\t\treturn this.pos === this.start;\n\t}\n\n\tpeek(offset) {\n\t\treturn this.string.charCodeAt(this.pos - 1 + (offset || 0));\n\t}\n\n\tprev() {\n\t\tif (!this.sol()) {\n\t\t\treturn this.string.charCodeAt(--this.pos);\n\t\t}\n\t}\n\n\teat(match) {\n\t\tif (this.sol()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst ok = typeof match === 'function'\n\t\t\t? match(this.peek())\n\t\t\t: match === this.peek();\n\n\t\tif (ok) {\n\t\t\tthis.pos--;\n\t\t}\n\n\t\treturn ok;\n\t}\n\n\teatWhile(match) {\n\t\tconst start = this.pos;\n\t\twhile (this.eat(match)) {}\n\t\treturn this.pos < start;\n\t}\n}\n\n/**\n * Quotes-related utilities\n */\n\nconst SINGLE_QUOTE = 39; // '\nconst DOUBLE_QUOTE = 34; // \"\nconst ESCAPE       = 92; // \\\n\n/**\n * Check if given character code is a quote\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isQuote(c) {\n\treturn c === SINGLE_QUOTE || c === DOUBLE_QUOTE;\n}\n\n/**\n * Consumes quoted value, if possible\n * @param  {StreamReader} stream\n * @return {Boolean}      Returns `true` is value was consumed\n */\nfunction eatQuoted(stream) {\n\tconst start = stream.pos;\n\tconst quote = stream.prev();\n\n\tif (isQuote(quote)) {\n\t\twhile (!stream.sol()) {\n\t\t\tif (stream.prev() === quote && stream.peek() !== ESCAPE) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}\n\nconst TAB         = 9;\nconst SPACE       = 32;\nconst DASH        = 45; // -\nconst SLASH       = 47; // /\nconst COLON       = 58; // :\nconst EQUALS      = 61; // =\nconst ANGLE_LEFT  = 60; // <\nconst ANGLE_RIGHT = 62; // >\n\n/**\n * Check if given reader’s current position points at the end of HTML tag\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nvar isAtHTMLTag = function (stream) {\n\tconst start = stream.pos;\n\n\tif (!stream.eat(ANGLE_RIGHT)) {\n\t\treturn false;\n\t}\n\n\tlet ok = false;\n\tstream.eat(SLASH); // possibly self-closed element\n\n\twhile (!stream.sol()) {\n\t\tstream.eatWhile(isWhiteSpace);\n\n\t\tif (eatIdent(stream)) {\n\t\t\t// ate identifier: could be a tag name, boolean attribute or unquoted\n\t\t\t// attribute value\n\t\t\tif (stream.eat(SLASH)) {\n\t\t\t\t// either closing tag or invalid tag\n\t\t\t\tok = stream.eat(ANGLE_LEFT);\n\t\t\t\tbreak;\n\t\t\t} else if (stream.eat(ANGLE_LEFT)) {\n\t\t\t\t// opening tag\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t} else if (stream.eat(isWhiteSpace)) {\n\t\t\t\t// boolean attribute\n\t\t\t\tcontinue;\n\t\t\t} else if (stream.eat(EQUALS)) {\n\t\t\t\t// simple unquoted value or invalid attribute\n\t\t\t\tif (eatIdent(stream)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if (eatAttributeWithUnquotedValue(stream)) {\n\t\t\t\t// identifier was a part of unquoted value\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// invalid tag\n\t\t\tbreak;\n\t\t}\n\n\t\tif (eatAttribute(stream)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tstream.pos = start;\n\treturn ok;\n};\n\n/**\n * Eats HTML attribute from given string.\n * @param  {StreamReader} state\n * @return {Boolean}       `true` if attribute was consumed.\n */\nfunction eatAttribute(stream) {\n\treturn eatAttributeWithQuotedValue(stream) || eatAttributeWithUnquotedValue(stream);\n}\n\n/**\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatAttributeWithQuotedValue(stream) {\n\tconst start = stream.pos;\n\tif (eatQuoted(stream) && stream.eat(EQUALS) && eatIdent(stream)) {\n\t\treturn true;\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}\n\n/**\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatAttributeWithUnquotedValue(stream) {\n\tconst start = stream.pos;\n\tif (stream.eatWhile(isUnquotedValue) && stream.eat(EQUALS) && eatIdent(stream)) {\n\t\treturn true;\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}\n\n/**\n * Eats HTML identifier from stream\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatIdent(stream) {\n\treturn stream.eatWhile(isIdent);\n}\n\n/**\n * Check if given character code belongs to HTML identifier\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isIdent(c) {\n\treturn c === COLON || c === DASH || isAlpha(c) || isNumber(c);\n}\n\n/**\n * Check if given character code is alpha code (letter though A to Z)\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isAlpha(c) {\n\tc &= ~32; // quick hack to convert any char code to uppercase char code\n\treturn c >= 65 && c <= 90; // A-Z\n}\n\n/**\n * Check if given code is a number\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isNumber(c) {\n\treturn c > 47 && c < 58;\n}\n\n/**\n * Check if given code is a whitespace\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isWhiteSpace(c) {\n\treturn c === SPACE || c === TAB;\n}\n\n/**\n * Check if given code may belong to unquoted attribute value\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isUnquotedValue(c) {\n\treturn c && c !== EQUALS && !isWhiteSpace(c) && !isQuote(c);\n}\n\nconst code = ch => ch.charCodeAt(0);\nconst SQUARE_BRACE_L = code('[');\nconst SQUARE_BRACE_R = code(']');\nconst ROUND_BRACE_L  = code('(');\nconst ROUND_BRACE_R  = code(')');\nconst CURLY_BRACE_L  = code('{');\nconst CURLY_BRACE_R  = code('}');\n\nconst specialChars = new Set('#.*:$-_!@%^+>/'.split('').map(code));\nconst bracePairs = new Map()\n\t.set(SQUARE_BRACE_L, SQUARE_BRACE_R)\n\t.set(ROUND_BRACE_L,  ROUND_BRACE_R)\n\t.set(CURLY_BRACE_L,  CURLY_BRACE_R);\n\nconst defaultOptions = {\n\tsyntax: 'markup',\n\tlookAhead: null,\n\tprefix: ''\n};\n\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param {String}  line A text line where abbreviation should be expanded\n * @param {Number}  [pos] Caret position in line. If not given, uses end-of-line\n * @param {Object}  [options]\n * @param {Boolean} [options.lookAhead] Allow parser to look ahead of `pos` index for\n * searching of missing abbreviation parts. Most editors automatically inserts\n * closing braces for `[`, `{` and `(`, which will most likely be right after\n * current caret position. So in order to properly expand abbreviation, user\n * must explicitly move caret right after auto-inserted braces. With this option\n * enabled, parser will search for closing braces right after `pos`. Default is `true`\n * @param {String} [options.syntax] Name of context syntax of expanded abbreviation.\n * Either 'markup' (default) or 'stylesheet'. In 'stylesheet' syntax, braces `[]`\n * and `{}` are not supported thus not extracted.\n * @param {String} [options.prefix] A string that should precede abbreviation in\n * order to make it successfully extracted. If given, the abbreviation will be\n * extracted from the nearest `prefix` occurrence.\n * @return {Object} Object with `abbreviation` and its `location` in given line\n * if abbreviation can be extracted, `null` otherwise\n */\nfunction extractAbbreviation(line, pos, options) {\n\t// make sure `pos` is within line range\n\tpos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n\n\tif (typeof options === 'boolean') {\n\t\toptions = Object.assign({}, defaultOptions, { lookAhead: options });\n\t} else {\n\t\toptions = Object.assign({}, defaultOptions, options);\n\t}\n\n\tif (options.lookAhead == null || options.lookAhead === true) {\n\t\tpos = offsetPastAutoClosed(line, pos, options);\n\t}\n\n\tlet c;\n\tconst start = getStartOffset(line, pos, options.prefix);\n\tif (start === -1) {\n\t\treturn null;\n\t}\n\n\tconst stream = new StreamReader(line, start);\n\tstream.pos = pos;\n\tconst stack = [];\n\n\twhile (!stream.sol()) {\n\t\tc = stream.peek();\n\n\t\tif (isCloseBrace(c, options.syntax)) {\n\t\t\tstack.push(c);\n\t\t} else if (isOpenBrace(c, options.syntax)) {\n\t\t\tif (stack.pop() !== bracePairs.get(c)) {\n\t\t\t\t// unexpected brace\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (has(stack, SQUARE_BRACE_R) || has(stack, CURLY_BRACE_R)) {\n\t\t\t// respect all characters inside attribute sets or text nodes\n\t\t\tstream.pos--;\n\t\t\tcontinue;\n\t\t} else if (isAtHTMLTag(stream) || !isAbbreviation(c)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tstream.pos--;\n\t}\n\n\tif (!stack.length && stream.pos !== pos) {\n\t\t// found something, remove some invalid symbols from the\n\t\t// beginning and return abbreviation\n\t\tconst abbreviation = line.slice(stream.pos, pos).replace(/^[*+>^]+/, '');\n\t\treturn {\n\t\t\tabbreviation,\n\t\t\tlocation: pos - abbreviation.length,\n\t\t\tstart: options.prefix\n\t\t\t\t? start - options.prefix.length\n\t\t\t\t: pos - abbreviation.length,\n\t\t\tend: pos\n\t\t};\n\t}\n}\n\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n * @param {String} line\n * @param {Number} pos\n * @return {Number}\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n\t// closing quote is allowed only as a next character\n\tif (isQuote(line.charCodeAt(pos))) {\n\t\tpos++;\n\t}\n\n\t// offset pointer until non-autoclosed character is found\n\twhile (isCloseBrace(line.charCodeAt(pos), options.syntax)) {\n\t\tpos++;\n\t}\n\n\treturn pos;\n}\n\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: it’s nearest to `pos` location of `prefix` token\n * @param {String} line\n * @param {Number} pos\n * @param {String} prefix\n * @return {Number}\n */\nfunction getStartOffset(line, pos, prefix) {\n\tif (!prefix) {\n\t\treturn 0;\n\t}\n\n\tconst stream = new StreamReader(line);\n\tconst compiledPrefix = String(prefix).split('').map(code);\n\tstream.pos = pos;\n\tlet result;\n\n\twhile (!stream.sol()) {\n\t\tif (consumePair(stream, SQUARE_BRACE_R, SQUARE_BRACE_L) || consumePair(stream, CURLY_BRACE_R, CURLY_BRACE_L)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult = stream.pos;\n\t\tif (consumeArray(stream, compiledPrefix)) {\n\t\t\treturn result;\n\t\t}\n\n\t\tstream.pos--;\n\t}\n\n\treturn -1;\n}\n\n/**\n * Consumes full character pair, if possible\n * @param {StreamReader} stream\n * @param {Number} close\n * @param {Number} open\n * @return {Boolean}\n */\nfunction consumePair(stream, close, open) {\n\tconst start = stream.pos;\n\tif (stream.eat(close)) {\n\t\twhile (!stream.sol()) {\n\t\t\tif (stream.eat(open)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tstream.pos--;\n\t\t}\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}\n\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n * @param {StreamReader} stream\n * @param {Number[]} arr\n */\nfunction consumeArray(stream, arr) {\n\tconst start = stream.pos;\n\tlet consumed = false;\n\n\tfor (let i = arr.length - 1; i >= 0 && !stream.sol(); i--) {\n\t\tif (!stream.eat(arr[i])) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconsumed = i === 0;\n\t}\n\n\tif (!consumed) {\n\t\tstream.pos = start;\n\t}\n\n\treturn consumed;\n}\n\nfunction has(arr, value) {\n\treturn arr.indexOf(value) !== -1;\n}\n\nfunction isAbbreviation(c) {\n\treturn (c > 64 && c < 91)   // uppercase letter\n\t\t|| (c > 96 && c < 123)  // lowercase letter\n\t\t|| (c > 47 && c < 58)   // number\n\t\t|| specialChars.has(c); // special character\n}\n\nfunction isOpenBrace(c, syntax) {\n\treturn c === ROUND_BRACE_L || (syntax === 'markup' && (c === SQUARE_BRACE_L || c === CURLY_BRACE_L));\n}\n\nfunction isCloseBrace(c, syntax) {\n\treturn c === ROUND_BRACE_R || (syntax === 'markup' && (c === SQUARE_BRACE_R || c === CURLY_BRACE_R));\n}\n\nexport default extractAbbreviation;\n","var defaultSyntaxes = {\n\tmarkup: 'html',\n\tstylesheet: 'css'\n};\n\nvar knownSyntaxes = {\n\tmarkup: ['html', 'xml', 'xsl', 'jsx', 'js', 'pug', 'slim', 'haml'],\n\tstylesheet: ['css', 'sass', 'scss', 'less', 'sss', 'stylus']\n};\n\n/**\n * Config resolver: returns compiled config that can be used in\n * `@emmetio/expand-abbreviation` module for expanding abbreviations\n * @param {EmmetConfig} config Config object\n * @param {EmmetConfigParams} [params] Additional params like `.syntax` and `.project` for\n * config resolving\n * @returns {Object}\n */\nfunction compileConfig(config, params) {\n\tparams = createParams(config, params || {});\n\n\tvar resolved = resolveConfig(config, params);\n\n\t// Copy extra fields from original config\n\tvar knownFields = ['globals', 'syntax', 'project'];\n\tfor (var p in config) {\n\t\tif (knownFields.indexOf(p) === -1) {\n\t\t\tresolved[p] = config[p];\n\t\t}\n\t}\n\n\treturn resolved;\n}\n\n/**\n * Resolves config for markup syntax\n * @param {EmmetConfig} config\n * @param {EmmetConfigParams} params\n * @return {Object}\n */\nfunction resolveConfig(config, ref) {\n\tvar type = ref.type;\n\tvar syntax = ref.syntax;\n\tvar project = ref.project;\n\n\treturn {\n\t\tsyntax: syntax,\n\t\ttype: type,\n\t\tproject: project,\n\t\tformat:  mergeConfig(config, 'format', type, syntax, project),\n\t\tprofile: mergeConfig(config, 'profile', type, syntax, project),\n\t\toptions: mergeConfig(config, 'options', type, syntax, project),\n\t\tvariables: mergeConfig(config, 'variables', type, syntax, project),\n\t\tsnippets: getConfig(config, 'snippets', type, syntax, project).filter(Boolean)\n\t};\n}\n\n/**\n * @param {EmmetConfig} config \n * @param {EmmetConfigParams} params \n * @returns {EmmetConfigParams}\n */\nfunction createParams(config, params) {\n\tvar type = params.type;\n\tvar syntax = params.syntax;\n\n\tif (!type && !syntax) {\n\t\ttype = 'markup';\n\t\tsyntax = defaultSyntaxes[type];\n\t} else if (!type && syntax) {\n\t\tif (knownSyntaxes.markup.indexOf(syntax) !== -1) {\n\t\t\ttype = 'markup';\n\t\t} else if (knownSyntaxes.stylesheet.indexOf(syntax) !== -1) {\n\t\t\ttype = 'stylesheet';\n\t\t} else {\n\t\t\ttype = get(config, ['syntax', syntax, 'type'])\n\t\t\t\t|| get(config, ['project', params.project, 'syntax', syntax, 'type']);\n\t\t}\n\t} else if (!syntax) {\n\t\tsyntax = defaultSyntaxes[type];\n\t}\n\n\treturn Object.assign({}, params, {type: type, syntax: syntax});\n}\n\nfunction mergeConfig(config, key, type, syntax, project) {\n\treturn getConfig(config, key, type, syntax, project)\n\t\t.reduce(function (out, obj) { return (Object.assign({}, out, obj)); }, {});\n}\n\nfunction getConfig(config, key, type, syntax, project) {\n\treturn [\n\t\tget(config, ['globals', type, key]),\n\t\tget(config, ['project', project, 'globals', type, key]),\n\t\tget(config, ['syntax', syntax, key]),\n\t\tget(config, ['project', project, 'syntax', syntax, key])\n\t].filter(Boolean);\n}\n\n/**\n * Safe dot-property getter for `obj`: returns value of `obj` by given `key`,\n * separated by `.`, but doesn’t throw error if any of the property key exists\n * @param {Object} obj\n * @param {String[]} key\n * @param {*} [defaultValue] \n * @return {*}\n */\nfunction get(obj, key, defaultValue) {\n\tvar result = obj;\n\n\tfor (var i = 0; i < key.length; i++) {\n\t\tif (result == null) {\n\t\t\tbreak;\n\t\t}\n\n\t\tresult = result[key[i]];\n\t}\n\n\treturn result != null ? result : defaultValue;\n}\n\nexport default compileConfig;\n//# sourceMappingURL=config.es.js.map\n","'use strict';\n\nimport resolveConfig from '@emmetio/config';\n\nconst editorField = (index, placeholder = '') => `\\${${index}${placeholder ? ':' + placeholder : ''}}`;\n\n/**\n * Returns resolved Emmet config for `pos` location of given editor\n * @param  {CodeMirror.Editor} editor\n * @param  {CodeMirror.Position} [pos]  Point in editor where syntax should be detected.\n * Uses `editor.getCursor()` if not given\n * @param  {Object} [options] Additional options to override before config resolve\n * @return {Object}\n */\nexport default function createConfig(editor, pos, options) {\n\tpos = pos || editor.getCursor();\n\tconst syntax = getSyntax(editor, pos);\n\n\t/** @type {EmmetConfig} */\n\tconst config = resolveConfig(Object.assign(\n\t\t{ field: editorField },\n\t\teditor.getOption('emmet'),\n\t\toptions\n\t), { syntax });\n\n\tconst mode = editor.getModeAt(pos);\n\tif (syntax === 'jsx') {\n\t\tconfig.profile = Object.assign({ selfClosingStyle: 'xml' }, config.profile);\n\t\tconfig.options = Object.assign({ jsx: true }, config.options);\n\t} else if (mode.name === 'xml') {\n\t\tconfig.profile = Object.assign({ selfClosingStyle: mode.configuration }, config.profile);\n\t}\n\n\treturn config;\n}\n\n/**\n * Detect Emmet syntax from given editor’s position.\n * @param {CodeMirror.Editor} editor\n * @param {CodeMirror.Position} [pos]\n * @return {String} Returns `null` if Emmet syntax can’t be detected\n */\nexport function getSyntax(editor, pos) {\n\tconst rootMode = editor.getMode();\n\tif (rootMode.name === 'jsx' || rootMode.name === 'javascript') {\n\t\treturn rootMode.name;\n\t}\n\n\tconst mode = editor.getModeAt(pos);\n\treturn mode.name === 'xml' ? 'html' : mode.name;\n}\n","'use strict';\n\nimport StreamReader from '@emmetio/stream-reader';\n\nconst LINE_END = 10; // \\n\n\n/**\n * A stream reader for CodeMirror editor\n */\nexport default class CodeMirrorStreamReader extends StreamReader {\n\t/**\n\t * @param  {CodeMirror.Editor} editor\n\t * @param  {CodeMirror.Position} [pos]\n\t * @param  {CodeMirror.Range} [limit]\n\t */\n\tconstructor(editor, pos, limit) {\n\t\tsuper();\n\t\tconst CodeMirror = editor.constructor;\n\t\tthis.editor = editor;\n\t\tthis.start = this.pos = pos || CodeMirror.Pos(0, 0);\n\n\t\tconst lastLine = editor.lastLine();\n\t\tthis._eof = limit ? limit.to   : CodeMirror.Pos(lastLine, this._lineLength(lastLine));\n\t\tthis._sof = limit ? limit.from : CodeMirror.Pos(0, 0);\n\t}\n\n\t/**\n\t * Returns true only if the stream is at the beginning of the file.\n\t * @returns {Boolean}\n\t */\n\tsof() {\n\t\treturn comparePos(this.pos, this._sof) <= 0;\n\t}\n\n\t/**\n\t * Returns true only if the stream is at the end of the file.\n\t * @returns {Boolean}\n\t */\n\teof() {\n\t\treturn comparePos(this.pos, this._eof) >= 0;\n\t}\n\n\t/**\n\t * Creates a new stream instance which is limited to given `start` and `end`\n\t * points for underlying buffer\n\t * @param  {CodeMirror.Pos} start\n\t * @param  {CodeMirror.Pos} end\n\t * @return {CodeMirrorStreamReader}\n\t */\n\tlimit(from, to) {\n\t\treturn new this.constructor(this.editor, from, { from, to });\n\t}\n\n\t/**\n\t * Returns the next character code in the stream without advancing it.\n\t * Will return NaN at the end of the file.\n\t * @returns {Number}\n\t */\n\tpeek() {\n\t\tconst { line, ch } = this.pos;\n\t\tconst lineStr = this.editor.getLine(line);\n\t\treturn ch < lineStr.length ? lineStr.charCodeAt(ch) : LINE_END;\n\t}\n\n\t/**\n\t * Returns the next character in the stream and advances it.\n\t * Also returns NaN when no more characters are available.\n\t * @returns {Number}\n\t */\n\tnext() {\n\t\tif (!this.eof()) {\n\t\t\tconst code = this.peek();\n\t\t\tthis.pos = Object.assign({}, this.pos, { ch: this.pos.ch + 1 });\n\n\t\t\tif (this.pos.ch >= this._lineLength(this.pos.line)) {\n\t\t\t\tthis.pos.line++;\n\t\t\t\tthis.pos.ch = 0;\n\t\t\t}\n\n\t\t\tif (this.eof()) {\n\t\t\t\t// handle edge case where position can move on next line\n\t\t\t\t// after EOF\n\t\t\t\tthis.pos = Object.assign({}, this._eof);\n\t\t\t}\n\n\t\t\treturn code;\n\t\t}\n\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * Backs up the stream n characters. Backing it up further than the\n\t * start of the current token will cause things to break, so be careful.\n\t * @param {Number} n\n\t */\n\tbackUp(n) {\n\t\tconst CodeMirror = this.editor.constructor;\n\n\t\tlet { line, ch } = this.pos;\n\t\tch -= (n || 1);\n\n\t\twhile (line >= 0 && ch < 0) {\n\t\t\tline--;\n\t\t\tch += this._lineLength(line);\n\t\t}\n\n\t\tthis.pos = line < 0 || ch < 0\n\t\t\t? CodeMirror.Pos(0, 0)\n\t\t\t: CodeMirror.Pos(line, ch);\n\n\t\treturn this.peek();\n\t}\n\n\t/**\n\t * Get the string between the start of the current token and the\n\t * current stream position.\n\t * @returns {String}\n\t */\n\tcurrent() {\n\t\treturn this.substring(this.start, this.pos);\n\t}\n\n\t/**\n\t * Returns contents for given range\n\t * @param  {Point} from\n\t * @param  {Point} to\n\t * @return {String}\n\t */\n\tsubstring(from, to) {\n\t\treturn this.editor.getRange(from, to);\n\t}\n\n\t/**\n\t * Creates error object with current stream state\n\t * @param {String} message\n\t * @return {Error}\n\t */\n\terror(message) {\n\t\tconst err = new Error(`${message} at line ${this.pos.line}, column ${this.pos.ch}`);\n\t\terr.originalMessage = message;\n\t\terr.pos = this.pos;\n\t\terr.string = this.string;\n\t\treturn err;\n\t}\n\n\t/**\n\t * Returns length of given line, including line ending\n\t * @param  {Number} line\n\t * @return {Number}\n\t */\n\t_lineLength(line) {\n\t\tconst isLast = line === this.editor.lastLine();\n\t\treturn this.editor.getLine(line).length + (isLast ? 0 : 1);\n\t}\n}\n\nfunction comparePos(a, b) {\n\treturn a.line - b.line || a.ch - b.ch;\n}\n","'use strict';\n\nimport parseFields from '@emmetio/field-parser';\nimport CodeMirrorStreamReader from './stream-reader';\nimport { isSpace } from '@emmetio/stream-reader-utils';\n\n/**\n * Returns token used for single indentation in given editor\n * @param  {CodeMirror.Editor} editor\n * @return {String}\n */\nexport function getIndentation(editor) {\n\tif (!editor.getOption('indentWithTabs')) {\n\t\treturn repeatString(' ', editor.getOption('indentUnit'));\n\t}\n\n\treturn '\\t';\n}\n\n/**\n * Normalizes text according to given CodeMirror instance indentation\n * preferences\n * @param  {String} text\n * @param  {CodeMirror.Editor} editor\n * @param  {String} [indentation] Applies `indentText()` with given argument, if provided\n * @return {String}\n */\nexport function normalizeText(editor, text, indentation) {\n\tlet lines = splitByLines(text);\n\tconst indent = getIndentation(editor);\n\n\tif (indent !== '\\t') {\n\t\tlines = lines.map(line => line.replace(/^\\t+/,\n\t\t\ttabs => repeatString(indent, tabs.length)));\n\t}\n\n\tif (indentation) {\n\t\tlines = lines.map((line, i) => i ? indentation + line : line);\n\t}\n\n\treturn lines.join('\\n');\n}\n\n/**\n * Indents each line, except first one, in given text\n * @param  {String} text\n * @param  {String} indentation\n * @return {String}\n */\nexport function indentText(text, indentation) {\n\treturn splitByLines(text)\n\t\t.map((line, i) => i ? indentation + line : line)\n\t\t.join('\\n');\n}\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]} Lines of text\n */\nexport function splitByLines(text) {\n\treturn Array.isArray(text) ? text : text.split(/\\r\\n|\\r|\\n/g);\n}\n\nexport function repeatString(str, count) {\n\tlet result = '';\n\twhile (0 < count--) {\n\t\tresult += str;\n\t}\n\n\treturn result;\n}\n\n/**\n * Quick and dirty way to remove fields from given string\n * @param  {String} str\n * @return {String}\n */\nexport function removeFields(str) {\n\treturn parseFields(str).string;\n}\n\n/**\n * Check if given range contains point\n * @param  {CodeMirror.Range} range\n * @param  {CodeMirror.Position} pos\n * @param  {Boolean} [exclude] Exclude range and and start\n * @return {Boolean}\n */\nexport function containsPos(range, pos, exclude) {\n\treturn exclude\n\t\t? comparePos(pos, range.from) > 0 && comparePos(pos, range.to) < 0\n\t\t: comparePos(pos, range.from) >= 0 && comparePos(pos, range.to) <= 0;\n}\n\nexport function comparePos(a, b) {\n\treturn a.line - b.line || a.ch - b.ch;\n}\n\nexport function rangeFromNode(node) {\n\treturn {\n\t\tfrom: node.start,\n\t\tto: node.end\n\t};\n}\n\n/**\n * Narrows given `{from, to}` range to first non-whitespace characters in given \n * editor content\n * @param {CodeMirror.Editor} editor \n * @param {CodeMirror.Position} from \n * @param {CodeMirror.Position} [to] \n * @returns {Object}\n */\nexport function narrowToNonSpace(editor, from, to) {\n\tconst stream = new CodeMirrorStreamReader(editor, from);\n\n\tstream.eatWhile(isSpace);\n\tfrom = stream.pos;\n\t\n\tif (to) {\n\t\tstream.pos = to;\n\t\tstream.backUp();\n\n\t\twhile (!stream.sof() && isSpace(stream.peek())) {\n\t\t\tstream.backUp();\n\t\t}\n\n\t\tstream.next();\n\t\tto = stream.pos;\n\t} else {\n\t\tto = from;\n\t}\n\n\treturn { from, to };\n}\n\n/**\n * Returns nearest CSS property name, left to given position\n * @param {CodeMirror.Editor} editor \n * @param {CodeMirror.Position} pos \n * @returns {String}\n */\nexport function getCSSPropertyName(editor, pos) {\n\tconst line = pos.line;\n\tlet ch = pos.ch, token;\n\n\twhile (ch >= 0) {\n\t\ttoken = editor.getTokenAt({ line, ch });\n\t\tif (token.type === 'property') {\n\t\t\treturn token.string;\n\t\t}\n\n\t\tif (token.start !== ch) {\n\t\t\tch = token.start;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Check if given position is inside CSS property value\n * @param {CodeMirror.Editor} editor \n * @param {CodeMirror.Position} pos \n * @return {Boolean}\n */\nexport function isCSSPropertyValue(editor, pos) {\n\tconst mode = editor.getModeAt(pos);\n\tif (mode && mode.name === 'css') {\n\t\tconst token = editor.getTokenAt(pos);\n\t\tconst state = token.state && token.state.localState || token.state;\n\t\treturn state && state.context && state.context.type === 'prop';\n\t}\n\n\treturn false;\n}\n","'use strict';\n\nimport parseFields from '@emmetio/field-parser';\nimport { normalizeText } from './utils';\n\n/**\n * Replaces `range` in `editor` with `text` snippet. A snippet is a string containing\n * tabstops/fields like `${index:placeholder}`: this function will locate such \n * fields and place cursor at first one.\n * Inserted snippet will be automatically matched with current editor indentation\n * @param {CodeMirror.Editor} editor \n * @param {CodeMirror.Range} range \n * @param {String} text\n */\nexport default function insertSnippet(editor, range, text) {\n\tconst line = editor.getLine(range.from.line);\n\tconst matchIndent = line.match(/^\\s+/);\n\tlet snippet = normalizeText(editor, text, matchIndent && matchIndent[0]);\n\tconst fieldModel = parseFields(snippet);\n\t\n\treturn editor.operation(() => {\n\t\teditor.replaceRange(fieldModel.string, range.from, range.to);\n\n\t\t// Position cursor\n\t\tconst startIx = editor.indexFromPos(range.from);\n\t\tif (fieldModel.fields.length) {\n\t\t\tconst field = fieldModel.fields[0];\n\t\t\tconst from = editor.posFromIndex(field.location + startIx);\n\t\t\tconst to = editor.posFromIndex(field.location + field.length + startIx);\n\t\t\teditor.setSelection(from, to);\n\t\t} else {\n\t\t\teditor.setCursor(editor.posFromIndex(startIx + fieldModel.string.length));\n\t\t}\n\n\t\treturn true;\n\t});\n}\n","'use strict';\n\nimport { expand, parse } from '@emmetio/expand-abbreviation';\nimport extract from './extract-abbreviation';\nimport insertSnippet from './snippet';\nimport { removeFields, isCSSPropertyValue } from './utils';\n\nconst emmetMarkerClass = 'emmet-abbreviation';\n\n/**\n * Returns parsed abbreviation from given position in `editor`, if possible.\n * @param {CodeMirror.Editor} editor\n * @param {CodeMirror.Position} pos\n * @param {Boolean} [contextAware] Use context-aware abbreviation detection\n * @returns {Abbreviation}\n */\nexport default function abbreviationFromPosition(editor, pos, contextAware) {\n\t// Try to find abbreviation marker from given position\n\tconst marker = findMarker(editor, pos);\n\tif (marker && marker.model) {\n\t\treturn marker.model;\n\t}\n\n\t// Try to extract abbreviation from given position\n\tconst extracted = extract(editor, pos, contextAware);\n\tif (extracted) {\n\t\ttry {\n\t\t\tconst abbr = new Abbreviation(extracted.abbreviation, extracted.range, extracted.config);\n\t\t\treturn abbr.valid(editor, contextAware) ? abbr : null;\n\t\t} catch (err) {\n\t\t\t// skip\n\t\t\t// console.warn(err);\n\t\t}\n\t}\n}\n\n/**\n * Returns *valid* Emmet abbreviation marker (if any) for given position of editor\n * @param  {CodeMirror.Editor} editor\n * @param  {CodeMirror.Position} [pos]\n * @return {CodeMirror.TextMarker}\n */\nexport function findMarker(editor, pos) {\n\tconst markers = editor.findMarksAt(pos);\n\tfor (let i = 0, marker; i < markers.length; i++) {\n\t\tmarker = markers[i];\n\t\tif (marker.className === emmetMarkerClass) {\n\t\t\tif (isValidMarker(editor, marker)) {\n\t\t\t\treturn marker;\n\t\t\t}\n\n\t\t\tmarker.clear();\n\t\t}\n\t}\n}\n\n/**\n * Removes Emmet abbreviation markers from given editor\n * @param {CodeMirror.Editor} editor\n */\nexport function clearMarkers(editor) {\n\tconst markers = editor.getAllMarks();\n\tfor (let i = 0; i < markers.length; i++) {\n\t\tif (markers[i].className === emmetMarkerClass) {\n\t\t\tmarkers[i].clear();\n\t\t}\n\t}\n}\n\n/**\n * Marks Emmet abbreviation for given editor position, if possible\n * @param  {CodeMirror.Editor} editor Editor where abbreviation marker should be created\n * @param  {Abbreviation} model Parsed abbreviation model\n * @return {CodeMirror.TextMarker} Returns `undefined` if no valid abbreviation under caret\n */\nexport function createMarker(editor, model) {\n\tconst { from, to } = model.range;\n\tconst marker = editor.markText(from, to, {\n\t\tinclusiveLeft: true,\n\t\tinclusiveRight: true,\n\t\tclearWhenEmpty: true,\n\t\tclassName: emmetMarkerClass\n\t});\n\tmarker.model = model;\n\treturn marker;\n}\n\n/**\n * Ensures that given editor Emmet abbreviation marker contains valid Emmet abbreviation\n * and updates abbreviation model if required\n * @param {CodeMirror} editor\n * @param {CodeMirror.TextMarket} marker\n * @return {Boolean} `true` if marker contains valid abbreviation\n */\nfunction isValidMarker(editor, marker) {\n\tconst range = marker.find();\n\n\t// No newlines inside abbreviation\n\tif (range.from.line !== range.to.line) {\n\t\treturn false;\n\t}\n\n\t// Make sure marker contains valid abbreviation\n\tlet text = editor.getRange(range.from, range.to);\n\tif (!text || /^\\s|\\s$/g.test(text)) {\n\t\treturn false;\n\t}\n\n\tif (marker.model && marker.model.config.syntax === 'jsx' && text[0] === '<') {\n\t\ttext = text.slice(1);\n\t}\n\n\tif (!marker.model || marker.model.abbreviation !== text) {\n\t\t// marker contents was updated, re-parse abbreviation\n\t\ttry {\n\t\t\tmarker.model = new Abbreviation(text, range, marker.model.config);\n\t\t\tif (!marker.model.valid(editor, true)) {\n\t\t\t\tmarker.model = null;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.warn(err);\n\t\t\tmarker.model = null;\n\t\t}\n\t}\n\n\treturn Boolean(marker.model && marker.model.snippet);\n}\n\nexport class Abbreviation {\n\t/**\n\t * @param {String} abbreviation Abbreviation string\n\t * @param {CodeMirror.Range} range Abbreviation location in editor\n\t * @param {Object} [config]\n\t */\n\tconstructor(abbreviation, range, config) {\n\t\tthis.abbreviation = abbreviation;\n\t\tthis.range = range;\n\t\tthis.config = config;\n\t\tthis.ast = parse(abbreviation, config);\n\t\tthis.snippet = expand(this.ast, config);\n\t\tthis.preview = removeFields(this.snippet);\n\t}\n\n\t/**\n\t * Inserts current expanded abbreviation into given `editor` by replacing\n\t * `range`\n\t * @param {CodeMirror.Editor} editor\n\t * @param {CodeMirror.Range} [range]\n\t */\n\tinsert(editor, range) {\n\t\treturn insertSnippet(editor, range || this.range, this.snippet);\n\t}\n\n\t/**\n\t * Check if parsed abbreviation is valid\n\t * @param {Boolean} [contextAware] Perform context-aware validation: ensure \n\t * that expanded result is expected at abbreviation location\n\t */\n\tvalid(editor, contextAware) {\n\t\tif (this.preview && this.abbreviation !== this.preview) {\n\t\t\treturn contextAware && this.config.type === 'stylesheet'\n\t\t\t\t? this._isValidForStylesheet(editor)\n\t\t\t\t: true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_isValidForStylesheet(editor) {\n\t\tconst pos = this.range.from;\n\t\tconst token = editor.getTokenAt(pos);\n\n\t\tif (/^[#!]/.test(this.abbreviation)) {\n\t\t\t// Abbreviation is a property value\n\t\t\treturn isCSSPropertyValue(editor, pos);\n\t\t}\n\n\t\t// All expanded nodes are properties? Properties has names, regular snippets don’t.\n\t\tconst isProperty = this.ast.children.every(node => node.name);\n\t\tconst state = token.state && token.state.localState || token.state;\n\n\t\tif (isProperty) {\n\t\t\t// Expanded abbreviation consists of properties: make sure we’re inside \n\t\t\t// block context\n\t\t\t// NB: in Sass, no actual block context since it’s indetation-based\n\t\t\treturn this.config.syntax === 'sass' \n\t\t\t\t|| (state && state.context && state.context.type === 'block');\n\t\t}\n\n\t\t// Expanded abbreviations are basic snippets: allow them everywhere, but forbid\n\t\t// if expanded result equals abbreviation (meaningless).\n\t\treturn true;\n\t}\n}\n","'use strict';\n\nimport extract from '@emmetio/extract-abbreviation';\nimport createConfig from './config';\nimport { isCSSPropertyValue, getCSSPropertyName } from './utils';\n\n/**\n * Context-aware abbreviation extraction from given editor.\n * Detects syntax context in `pos` editor location and, if it allows Emmet\n * abbreviation to be extracted here, returns object with extracted abbreviation,\n * its location and config.\n * @param {CodeMirror.Editor} editor\n * @param {CodeMirror.Position} pos\n */\nexport default function extractAbbreviation(editor, pos, contextAware) {\n\tconst config = createConfig(editor, pos);\n\n\tif (contextAware && !canExtract(editor, pos, config)) {\n\t\treturn null;\n\t}\n\n\tconst extracted = extract(editor.getLine(pos.line), pos.ch, {\n\t\tlookAhead: true,\n\t\tsyntax: config.type,\n\t\tprefix: config.syntax === 'jsx' && editor.getOption('jsxBracket') ? '<' : ''\n\t});\n\n\tif (extracted) {\n\t\tconst from = {\n\t\t\tline: pos.line,\n\t\t\tch: extracted.start\n\t\t};\n\t\tconst to = {\n\t\t\tline: pos.line,\n\t\t\tch: extracted.end\n\t\t};\n\n\t\tif (config.type === 'stylesheet' && contextAware) {\n\t\t\t// In case of stylesheet syntaxes (CSS, LESS) we should narrow down\n\t\t\t// expand context to property value, if possible\n\t\t\tif (isCSSPropertyValue(editor, pos)) {\n\t\t\t\tconfig.options = Object.assign({ property: getCSSPropertyName(editor, pos) }, config.options);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tabbreviation: extracted.abbreviation,\n\t\t\trange: { from, to },\n\t\t\tconfig\n\t\t};\n\t}\n}\n\n/**\n * Check if abbreviation can be extracted from given position\n * @param {CodeMirror.Editor} editor\n * @param {CodeMirror.Position} pos\n * @param {Object} config\n * @return {Boolean}\n */\nfunction canExtract(editor, pos, config) {\n\tconst tokenType = editor.getTokenTypeAt(pos);\n\n\tif (config.type === 'stylesheet') {\n\t\treturn tokenType !== 'comment' && tokenType !== 'string';\n\t}\n\n\tif (config.syntax === 'html') {\n\t\treturn tokenType === null;\n\t}\n\n\tif (config.syntax === 'slim' || config.syntax === 'pug') {\n\t\treturn tokenType === null || tokenType === 'tag'\n\t\t\t|| (tokenType && /attribute/.test(tokenType));\n\t}\n\n\tif (config.syntax === 'haml') {\n\t\treturn tokenType === null || tokenType === 'attribute';\n\t}\n\n\tif (config.syntax === 'jsx') {\n\t\t// JSX a bit tricky, delegate it to caller\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n","'use strict';\n\nimport getAbbreviation, { clearMarkers } from '../abbreviation';\n\n/**\n * Expand abbreviation command\n * @param {CodeMirror.Editor} editor\n * @param {Boolean} contextAware\n */\nexport default function(editor, contextAware) {\n\tif (editor.somethingSelected()) {\n\t\treturn editor.constructor.Pass;\n\t}\n\n\tconst abbr = getAbbreviation(editor, editor.getCursor(), contextAware);\n\n\tif (abbr) {\n\t\tabbr.insert(editor);\n\t\tclearMarkers(editor);\n\t\treturn true;\n\t}\n\n\t// If no abbreviation was expanded, allow editor to handle different\n\t// action for keyboard shortcut (Tab key mostly)\n\treturn editor.constructor.Pass;\n}\n","'use strict';\n\nexport default function(editor) {\n\tconst between = editor.listSelections().map(sel => betweenTags(editor, sel));\n\n\tif (!between.some(Boolean)) {\n\t\treturn editor.constructor.Pass;\n\t}\n\n\teditor.operation(() => {\n\t\tlet sels = editor.listSelections();\n\t\tconst singleSep = editor.doc.lineSeparator();\n\t\tconst doubleSep = singleSep + singleSep;\n\n\t\t// Step 1: insert newlines either single or double depending on selection\n\t\tfor (let i = sels.length - 1; i >= 0; i--) {\n\t\t\teditor.replaceRange(between[i] ? doubleSep : singleSep, sels[i].anchor, sels[i].head, '+newline');\n\t\t}\n\n\t\t// Step 2: indent inserted lines\n\t\tsels = editor.listSelections();\n\t\tfor (let i = 0; i < sels.length; i++) {\n\t\t\teditor.indentLine(sels[i].from().line, null, true);\n\n\t\t\tif (between[i]) {\n\t\t\t\teditor.indentLine(sels[i].from().line - 1, null, true);\n\t\t\t}\n\t\t}\n\n\t\t// Step 3: adjust caret positions\n\t\teditor.setSelections(editor.listSelections().map((sel, i) => {\n\t\t\tif (between[i]) {\n\t\t\t\tconst line = sel.from().line - 1;\n\t\t\t\tconst cursor = {\n\t\t\t\t\tline,\n\t\t\t\t\tch: editor.getLine(line).length\n\t\t\t\t};\n\t\t\t\treturn { anchor: cursor, head: cursor };\n\t\t\t}\n\n\t\t\treturn sel;\n\t\t}));\n\t});\n}\n\n/**\n * Check if given range is a single caret between tags\n * @param {CodeMirror} editor\n * @param {CodeMirror.range} range\n */\nfunction betweenTags(editor, range) {\n\tif (equalCursorPos(range.anchor, range.head)) {\n\t\tconst cursor = range.anchor;\n\t\tconst mode = editor.getModeAt(cursor);\n\n\t\tif (mode.name === 'xml') {\n\t\t\tconst left = editor.getTokenAt(cursor);\n\t\t\tconst right = editor.getTokenAt(Object.assign({}, cursor, { ch: cursor.ch + 1 }));\n\n\t\t\treturn left.type === 'tag bracket' && left.string === '>'\n\t\t\t\t&& right.type === 'tag bracket' && right.string === '</';\n\t\t}\n\t}\n}\n\n// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a, b) {\n\treturn a.line - b.line || a.ch - b.ch;\n}\n\nfunction equalCursorPos(a, b) {\n\treturn a.sticky === b.sticky && cmp(a, b) === 0;\n}\n\n","'use strict';\n\nimport { containsPos, rangeFromNode, narrowToNonSpace, comparePos } from '../utils';\nimport createConfig from '../config';\nimport { Abbreviation } from '../abbreviation';\n\n/**\n * Marks selected text or matched node content with abbreviation\n * @param {CodeMirror} editor \n */\nexport default function wrapWithAbbreviation(editor) {\n\tconst range = getWrappingContentRange(editor);\n\n\tif (range) {\n\t\tconst prompt = editor.getOption('emmetPrompt') || defaultPrompt;\n\t\tconst text = editor.getRange(range.from, range.to, '\\n')\n\t\t\t.split('\\n')\n\t\t\t.map(line => line.trim());\n\n\t\tprompt(editor, 'Enter abbreviation to wrap with:', abbr => {\n\t\t\tif (abbr) {\n\t\t\t\tconst model = new Abbreviation(abbr, range, createConfig(editor, range.from, { text }));\n\t\t\t\tmodel.insert(editor);\n\t\t\t}\n\t\t});\n\t} else {\n\t\tconsole.warn('Nothing to wrap');\n\t}\n}\n\n/**\n * Returns content range that should be wrapped\n * @param {CodeMirror} editor \n */\nfunction getWrappingContentRange(editor) {\n\tif (editor.somethingSelected()) {\n\t\tconst sel = editor.listSelections().filter(sel => sel.anchor !== sel.head)[0];\n\t\tif (sel) {\n\t\t\treturn  comparePos(sel.anchor, sel.head) < 0\n\t\t\t\t? { from: sel.anchor, to: sel.head }\n\t\t\t\t: { from: sel.head, to: sel.anchor };\n\t\t}\n\t}\n\n\t// Nothing selected, find parent HTML node and return range for its content\n\treturn getTagRangeForPos(editor, editor.getCursor());\n}\n\n/**\n * Returns either inner or outer tag range (depending on `pos` location) \n * for given position\n * @param {CodeMirror} editor \n * @param {Object} pos \n * @return {Object}\n */\nfunction getTagRangeForPos(editor, pos) {\n\tconst model = editor.getEmmetDocumentModel();\n\tconst tag = model && model.nodeForPoint(pos);\n\n\tif (!tag) {\n\t\treturn null;\n\t}\n\n\t// Depending on given position, return either outer or inner tag range\n\tif (inRange(tag.open, pos) || inRange(tag.close, pos)) {\n\t\t// Outer range\n\t\treturn rangeFromNode(tag);\n\t}\n\n\t// Inner range\n\tconst from = tag.open.end;\n\tconst to = tag.close ? tag.close.start : tag.open.end;\n\n\treturn narrowToNonSpace(editor, from, to);\n}\n\nfunction inRange(tag, pos) {\n\treturn tag && containsPos(rangeFromNode(tag), pos);\n}\n\nfunction defaultPrompt(editor, message, callback) {\n\tcallback(window.prompt(message));\n}\n","const DASH = 45; // -\n\n/**\n * Calculates fuzzy match score of how close `abbr` matches given `string`.\n * @param  {String} abbr        Abbreviation to score\n * @param  {String} string      String to match\n * @param  {Number} [fuzziness] Fuzzy factor\n * @return {Number}             Match score\n */\nfunction stringScore(abbr, string) {\n\tabbr = abbr.toLowerCase();\n\tstring = string.toLowerCase();\n\n\tif (abbr === string) {\n\t\treturn 1;\n\t}\n\n\t// a string MUST start with the same character as abbreviation\n\tif (!string || abbr.charCodeAt(0) !== string.charCodeAt(0)) {\n\t\treturn 0;\n\t}\n\n\tconst abbrLength = abbr.length;\n\tconst stringLength = string.length;\n\tlet i = 1, j = 1, score = stringLength;\n\tlet ch1, ch2, found, acronym;\n\n\twhile (i < abbrLength) {\n\t\tch1 = abbr.charCodeAt(i);\n\t\tfound = false;\n\t\tacronym = false;\n\n\t\twhile (j < stringLength) {\n\t\t\tch2 = string.charCodeAt(j);\n\n\t\t\tif (ch1 === ch2) {\n\t\t\t\tfound = true;\n\t\t\t\tscore += (stringLength - j) * (acronym ? 2 : 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// add acronym bonus for exactly next match after unmatched `-`\n\t\t\tacronym = ch2 === DASH;\n\t\t\tj++;\n\t\t}\n\n\t\tif (!found) {\n\t\t\tbreak;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn score && score * (i / abbrLength) / sum(stringLength);\n}\n\n/**\n * Calculates sum of first `n` natural numbers, e.g. 1+2+3+...n\n * @param  {Number} n\n * @return {Number}\n */\nfunction sum(n) {\n\treturn n * (n + 1) / 2;\n}\n\nconst reProperty = /^([a-z\\-]+)(?:\\s*:\\s*([^\\n\\r]+))?$/;\nconst DASH$1 = 45; // -\n\n/**\n * Creates a special structure for resolving CSS properties from plain CSS\n * snippets.\n * Almost all CSS snippets are aliases for real CSS properties with available\n * value variants, optionally separated by `|`. Most values are keywords that\n * can be fuzzy-resolved as well. Some CSS properties are shorthands for other,\n * more specific properties, like `border` and `border-style`. For such cases\n * keywords from more specific properties should be available in shorthands too.\n * @param {Snippet[]} snippets\n * @return {CSSSnippet[]}\n */\nfunction cssSnippets(snippets) {\n\treturn nest( snippets.map(snippet => new CSSSnippet(snippet.key, snippet.value)) );\n}\n\nclass CSSSnippet {\n\tconstructor(key, value) {\n\t\tthis.key = key;\n\t\tthis.value = value;\n\t\tthis.property = null;\n\n\t\t// detect if given snippet is a property\n\t\tconst m = value && value.match(reProperty);\n\t\tif (m) {\n\t\t\tthis.property = m[1];\n\t\t\tthis.value = m[2];\n\t\t}\n\n\t\tthis.dependencies = [];\n\t}\n\n\taddDependency(dep) {\n\t\tthis.dependencies.push(dep);\n\t}\n\n\tget defaultValue() {\n\t\treturn this.value != null ? splitValue(this.value)[0] : null;\n\t}\n\n\t/**\n     * Returns list of unique keywords for current CSS snippet and its dependencies\n     * @return {String[]}\n     */\n\tkeywords() {\n\t\tconst stack = [];\n\t\tconst keywords = new Set();\n\t\tlet i = 0, item, candidates;\n\n\t\tif (this.property) {\n\t\t\t// scan valid CSS-properties only\n\t\t\tstack.push(this);\n\t\t}\n\n\t\twhile (i < stack.length) {\n\t\t\t// NB Keep items in stack instead of push/pop to avoid possible\n\t\t\t// circular references\n\t\t\titem = stack[i++];\n\n\t\t\tif (item.value) {\n\t\t\t\tcandidates = splitValue(item.value).filter(isKeyword);\n\n\t\t\t\t// extract possible keywords from snippet value\n\t\t\t\tfor (let j = 0; j < candidates.length; j++) {\n\t\t\t\t\tkeywords.add(candidates[j].trim());\n\t\t\t\t}\n\n\t\t\t\t// add dependencies into scan stack\n\t\t\t\tfor (let j = 0, deps = item.dependencies; j < deps.length; j++) {\n\t\t\t\t\tif (stack.indexOf(deps[j]) === -1) {\n\t\t\t\t\t\tstack.push(deps[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(keywords);\n\t}\n}\n\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * background-position-x -> background-position -> background\n * @param  {CSSSnippet[]} snippets\n * @return {CSSSnippet[]}\n */\nfunction nest(snippets) {\n\tsnippets = snippets.sort(snippetsSort);\n\tconst stack = [];\n\n\t// For sorted list of CSS properties, create dependency graph where each\n\t// shorthand property contains its more specific one, e.g.\n\t// backgound -> background-position -> background-position-x\n\tfor (let i = 0, cur, prev; i < snippets.length; i++) {\n\t\tcur = snippets[i];\n\n\t\tif (!cur.property) {\n\t\t\t// not a CSS property, skip it\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check if current property belongs to one from parent stack.\n\t\t// Since `snippets` array is sorted, items are perfectly aligned\n\t\t// from shorthands to more specific variants\n\t\twhile (stack.length) {\n\t\t\tprev = stack[stack.length - 1];\n\n\t\t\tif (cur.property.indexOf(prev.property) === 0\n                && cur.property.charCodeAt(prev.property.length) === DASH$1) {\n\t\t\t\tprev.addDependency(cur);\n\t\t\t\tstack.push(cur);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstack.pop();\n\t\t}\n\n\t\tif (!stack.length) {\n\t\t\tstack.push(cur);\n\t\t}\n\t}\n\n\treturn snippets;\n}\n\n/**\n * A sorting function for array of snippets\n * @param  {CSSSnippet} a\n * @param  {CSSSnippet} b\n * @return {Number}\n */\nfunction snippetsSort(a, b) {\n\tif (a.key === b.key) {\n\t\treturn 0;\n\t}\n\n\treturn a.key < b.key ? -1 : 1;\n}\n\n/**\n * Check if given string is a keyword candidate\n * @param  {String}  str\n * @return {Boolean}\n */\nfunction isKeyword(str) {\n\treturn /^\\s*[\\w-]+/.test(str);\n}\n\nfunction splitValue(value) {\n\treturn String(value).split('|');\n}\n\nconst globalKeywords = ['auto', 'inherit', 'unset'];\nconst unitlessProperties = [\n\t'z-index', 'line-height', 'opacity', 'font-weight', 'zoom',\n\t'flex', 'flex-grow', 'flex-shrink'\n];\n\nconst defaultOptions = {\n\tintUnit: 'px',\n\tfloatUnit: 'em',\n\tunitAliases: {\n\t\te :'em',\n\t\tp: '%',\n\t\tx: 'ex',\n\t\tr: 'rem'\n\t},\n\tfuzzySearchMinScore: 0\n};\n\n/**\n * For every node in given `tree`, finds matching snippet from `registry` and\n * updates node with snippet data.\n *\n * This resolver uses fuzzy matching for searching matched snippets and their\n * keyword values.\n */\n\nfunction index(tree, registry, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\toptions.unitAliases = Object.assign({}, defaultOptions.unitAliases, options && options.unitAliases);\n\n\tconst snippets = convertToCSSSnippets(registry);\n\n\ttree.walk(node => resolveNode(node, snippets, options));\n\treturn tree;\n}\n\nfunction convertToCSSSnippets(registry) {\n\treturn cssSnippets(registry.all({type: 'string'}));\n}\n\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n * @param  {Node} node\n * @param  {CSSSnippet[]} snippets\n * @param  {Object} options\n * @return {Node}\n */\nfunction resolveNode(node, snippets, options) {\n\tconst snippet = findBestMatch(node.name, snippets, 'key', options.fuzzySearchMinScore);\n\n\tif (!snippet) {\n\t\t// Edge case: `!important` snippet\n\t\treturn node.name === '!' ? setNodeAsText(node, '!important') : node;\n\t}\n\n\treturn snippet.property\n\t\t? resolveAsProperty(node, snippet, options)\n\t\t: resolveAsSnippet(node, snippet);\n}\n\n/**\n * Resolves given parsed abbreviation node as CSS property\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @param  {Object} formatOptions\n * @return {Node}\n */\nfunction resolveAsProperty(node, snippet, formatOptions) {\n\tconst abbr = node.name;\n\tnode.name = snippet.property;\n\n\tif (node.value && typeof node.value === 'object') {\n\t\t// resolve keyword shortcuts\n\t\tconst keywords = snippet.keywords();\n\n\t\tif (!node.value.size) {\n\t\t\t// no value defined, try to resolve unmatched part as a keyword alias\n\t\t\tlet kw = findBestMatch(getUnmatchedPart(abbr, snippet.key), keywords);\n\n\t\t\tif (!kw) {\n\t\t\t\t// no matching value, try to get default one\n\t\t\t\tkw = snippet.defaultValue;\n\t\t\t\tif (kw && kw.indexOf('${') === -1) {\n\t\t\t\t\t// Quick and dirty test for existing field. If not, wrap\n\t\t\t\t\t// default value in a field\n\t\t\t\t\tkw = `\\${1:${kw}}`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (kw) {\n\t\t\t\tnode.value.add(kw);\n\t\t\t}\n\t\t} else {\n\t\t\t// replace keyword aliases in current node value\n\t\t\tfor (let i = 0, token; i < node.value.value.length; i++) {\n\t\t\t\ttoken = node.value.value[i];\n\n\t\t\t\tif (token === '!') {\n\t\t\t\t\ttoken = `${!i ? '${1} ' : ''}!important`;\n\t\t\t\t} else if (isKeyword$1(token)) {\n\t\t\t\t\ttoken = findBestMatch(token.value, keywords)\n\t\t\t\t\t\t|| findBestMatch(token.value, globalKeywords)\n\t\t\t\t\t\t|| token;\n\t\t\t\t} else if (isNumericValue(token)) {\n\t\t\t\t\ttoken = resolveNumericValue(node.name, token, formatOptions);\n\t\t\t\t}\n\n\t\t\t\tnode.value.value[i] = token;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node;\n}\n\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @return {Node}\n */\nfunction resolveAsSnippet(node, snippet) {\n\treturn setNodeAsText(node, snippet.value);\n}\n\n/**\n * Sets given parsed abbreviation node as a text snippet\n * @param {Node} node\n * @param {String} text\n * @return {Node}\n */\nfunction setNodeAsText(node, text) {\n\tnode.name = null;\n\tnode.value = text;\n\treturn node;\n}\n\n/**\n * Finds best matching item from `items` array\n * @param {String} abbr  Abbreviation to match\n * @param {Array}  items List of items for match\n * @param {String} [key] If `items` is a list of objects, use `key` as object\n * property to test against\n * @param {Number} fuzzySearchMinScore The minimum score the best matched item should have to be a valid match.\n * @return {*}\n */\nfunction findBestMatch(abbr, items, key, fuzzySearchMinScore) {\n\tif (!abbr) {\n\t\treturn null;\n\t}\n\n\tlet matchedItem = null;\n\tlet maxScore = 0;\n\tfuzzySearchMinScore = fuzzySearchMinScore || 0;\n\n\tfor (let i = 0, item; i < items.length; i++) {\n\t\titem = items[i];\n\t\tconst score = stringScore(abbr, getScoringPart(item, key));\n\n\t\tif (score === 1) {\n\t\t\t// direct hit, no need to look further\n\t\t\treturn item;\n\t\t}\n\n\t\tif (score && score >= maxScore) {\n\t\t\tmaxScore = score;\n\t\t\tmatchedItem = item;\n\t\t}\n\t}\n\n\treturn maxScore >= fuzzySearchMinScore ? matchedItem : null;\n}\n\nfunction getScoringPart(item, key) {\n\tconst value = item && typeof item === 'object' ? item[key] : item;\n\tconst m = (value || '').match(/^[\\w-@]+/);\n\treturn m ? m[0] : value;\n}\n\n/**\n * Returns a part of `abbr` that wasn’t directly matched agains `string`.\n * For example, if abbreviation `poas` is matched against `position`, the unmatched part will be `as`\n * since `a` wasn’t found in string stream\n * @param {String} abbr\n * @param {String} string\n * @return {String}\n */\nfunction getUnmatchedPart(abbr, string) {\n\tfor (let i = 0, lastPos = 0; i < abbr.length; i++) {\n\t\tlastPos = string.indexOf(abbr[i], lastPos);\n\t\tif (lastPos === -1) {\n\t\t\treturn abbr.slice(i);\n\t\t}\n\t\tlastPos++;\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if given CSS value token is a keyword\n * @param {*} token\n * @return {Boolean}\n */\nfunction isKeyword$1(token) {\n\treturn tokenTypeOf(token, 'keyword');\n}\n\n/**\n * Check if given CSS value token is a numeric value\n * @param  {*}  token\n * @return {Boolean}\n */\nfunction isNumericValue(token) {\n\treturn tokenTypeOf(token, 'numeric');\n}\n\nfunction tokenTypeOf(token, type) {\n\treturn token && typeof token === 'object' && token.type === type;\n}\n\n/**\n * Resolves numeric value for given CSS property\n * @param  {String} property    CSS property name\n * @param  {NumericValue} token CSS numeric value token\n * @param  {Object} formatOptions Formatting options for units\n * @return {NumericValue}\n */\nfunction resolveNumericValue(property, token, formatOptions) {\n\tif (token.unit) {\n\t\ttoken.unit = formatOptions.unitAliases[token.unit] || token.unit;\n\t} else if (token.value !== 0 && unitlessProperties.indexOf(property) === -1) {\n\t\t// use `px` for integers, `em` for floats\n\t\t// NB: num|0 is a quick alternative to Math.round(0)\n\t\ttoken.unit = token.value === (token.value|0) ? formatOptions.intUnit : formatOptions.floatUnit;\n\t}\n\n\treturn token;\n}\n\nexport default index;\nexport { convertToCSSSnippets, stringScore, cssSnippets };\n//# sourceMappingURL=css-snippets-resolver.es.js.map\n","'use strict';\n\nimport { createSnippetsRegistry, expand } from '@emmetio/expand-abbreviation';\nimport { convertToCSSSnippets } from '@emmetio/css-snippets-resolver';\nimport createConfig from './config';\nimport getAbbreviation, { clearMarkers } from './abbreviation';\nimport { removeFields } from './utils';\nimport insertSnippet from './snippet';\n\n/**\n * Returns available completions from given editor\n * @param  {CodeMirror.Editor} editor\n * @param  {Abbreviation} abbrModel Parsed Emmet abbreviation model for which\n * completions should be populated\n * @param  {CodeMirror.Position} abbrPos Abbreviation location in editor\n * @param  {CodeMirror.Position} [pos] Cursor position in editor\n * @return {EmmetCompletion[]}\n */\nexport default function(editor, pos) {\n\tpos = pos || editor.getCursor();\n\tlet completions = [];\n\n\t// Provide two types of completions:\n\t// 1. Expanded abbreviation\n\t// 2. Snippets\n\n\tconst abbreviation = getAbbreviation(editor, pos, true);\n\t// NB: Check for edge case: expanded abbreviation equals to original\n\t// abbreviation (for example, `li.item` expands to `li.item` in Slim),\n\t// no need to provide completion for this case\n\tif (abbreviation && abbreviation.abbreviation !== abbreviation.snippet) {\n\t\tcompletions.push(expandedAbbreviationCompletion(editor, pos, abbreviation));\n\t}\n\n\tconst config = abbreviation ? abbreviation.config : createConfig(editor, pos);\n\n\tif (config.type === 'stylesheet') {\n\t\tcompletions = completions.concat(getStylesheetCompletions(editor, pos, config));\n\t} else {\n\t\tcompletions = completions.concat(getMarkupCompletions(editor, pos, config));\n\t}\n\n\treturn {\n\t\ttype: config.type,\n\t\tsyntax: config.syntax,\n\t\tabbreviation,\n\t\tcompletions: completions.filter(Boolean)\n\t};\n}\n\n/**\n * Returns completions for markup syntaxes (HTML, Slim, Pug etc.)\n * @param  {CodeMirror} editor\n * @param  {CodeMirror.Position} pos Cursor position in editor\n * @param  {Object} config Resolved Emmet config\n * @return {EmmetCompletion[]}\n */\nfunction getMarkupCompletions(editor, pos, config) {\n\tconst line = editor.getLine(pos.line).slice(0, pos.ch);\n\tconst prefix = extractPrefix(line, /[\\w:\\-$@]/);\n\n\t// Make sure that current position precedes element name (e.g. not attribute,\n\t// class, id etc.)\n\tif (prefix) {\n\t\tconst prefixRange = {\n\t\t\tfrom: { line: pos.line, ch: pos.ch - prefix.length },\n\t\t\tto: pos\n\t\t};\n\n\t\treturn getSnippetCompletions(editor, pos, config)\n\t\t\t.filter(completion => completion.key !== prefix && completion.key.indexOf(prefix) === 0)\n\t\t\t.map(completion => new EmmetCompletion('snippet', editor, prefixRange, completion.key, completion.preview, completion.snippet));\n\t}\n\n\treturn [];\n}\n\n/**\n * Returns completions for stylesheet syntaxes\n * @param  {CodeMirror} editor\n * @param  {CodeMirror.Position} pos Cursor position in editor\n * @param  {Object} config Resolved Emmet config\n * @return {EmmetCompletion[]}\n */\nfunction getStylesheetCompletions(editor, pos, config) {\n\tconst line = editor.getLine(pos.line).slice(0, pos.ch);\n\tconst prefix = extractPrefix(line, /[\\w-@$]/);\n\n\tif (prefix) {\n\t\t// Make sure that current position precedes element name (e.g. not attribute,\n\t\t// class, id etc.)\n\t\tconst prefixRange = {\n\t\t\tfrom: { line: pos.line, ch: pos.ch - prefix.length },\n\t\t\tto: pos\n\t\t};\n\n\t\tif (config.options && config.options.property) {\n\t\t\tconst lowerProp = config.options.property.toLowerCase();\n\t\t\t// Find matching CSS property snippet for keyword completions\n\t\t\tconst completion = getSnippetCompletions(editor, pos, config)\n\t\t\t\t.find(item => item.property && item.property === lowerProp);\n\n\t\t\tif (completion && completion.keywords.length) {\n\t\t\t\treturn completion.keywords.map(kw => {\n\t\t\t\t\treturn kw.key.indexOf(prefix) === 0 && new EmmetCompletion('value', editor, prefixRange, kw.key, kw.preview, kw.snippet);\n\t\t\t\t}).filter(Boolean);\n\t\t\t}\n\t\t} else {\n\t\t\treturn getSnippetCompletions(editor, pos, config)\n\t\t\t\t.filter(completion => completion.key !== prefix && completion.key.indexOf(prefix) === 0)\n\t\t\t\t.map(completion => new EmmetCompletion('snippet', editor, prefixRange, completion.key, completion.preview, completion.snippet));\n\t\t}\n\t}\n\n\treturn [];\n}\n\n/**\n * Returns all possible snippets completions for given editor context.\n * Completions are cached in editor for for re-use\n * @param  {CodeMirror.Editor} editor\n * @param  {CodeMirror.Position} pos\n * @param  {Object} config\n * @return {Array}\n */\nfunction getSnippetCompletions(editor, pos, config) {\n\tconst { type, syntax } = config;\n\n\tif (!editor.state.emmetCompletions) {\n\t\teditor.state.emmetCompletions = {};\n\t}\n\n\tconst cache = editor.state.emmetCompletions;\n\n\tif (!(syntax in cache)) {\n\t\tconst registry = createSnippetsRegistry(type, syntax, config.snippets);\n\n\t\tcache[syntax] = type === 'stylesheet'\n\t\t\t? getStylesheetSnippets(registry, config)\n\t\t\t: getMarkupSnippets(registry, config);\n\t}\n\n\treturn cache[syntax];\n}\n\n/**\n * Returns stylesheet snippets list\n * @param {SnippetsRegistry} registry\n * @return {Array}\n */\nfunction getStylesheetSnippets(registry) {\n\treturn convertToCSSSnippets(registry).map(snippet => {\n\t\tlet preview = snippet.property;\n\t\tconst keywords = snippet.keywords();\n\t\tif (keywords.length) {\n\t\t\tpreview += `: ${removeFields(keywords.join(' | '))}`;\n\t\t} else if (snippet.value) {\n\t\t\tpreview += `: ${removeFields(snippet.value)}`;\n\t\t}\n\n\t\treturn {\n\t\t\tkey: snippet.key,\n\t\t\tvalue: snippet.value,\n\t\t\tsnippet: snippet.key,\n\t\t\tproperty: snippet.property,\n\t\t\tkeywords: keywords.map(kw => {\n\t\t\t\tconst m = kw.match(/^[\\w-]+/);\n\t\t\t\treturn m && {\n\t\t\t\t\tkey: m[0],\n\t\t\t\t\tpreview: removeFields(kw),\n\t\t\t\t\tsnippet: kw\n\t\t\t\t};\n\t\t\t}).filter(Boolean),\n\t\t\tpreview\n\t\t};\n\t});\n}\n\n/**\n * Returns markup snippets list\n * @param {SnippetsRegistry} registry\n * @param {Object} config\n * @return {Array}\n */\nfunction getMarkupSnippets(registry, config) {\n\treturn registry.all({ type: 'string' }).map(snippet => ({\n\t\tkey: snippet.key,\n\t\tvalue: snippet.value,\n\t\tpreview: removeFields(expand(snippet.value, config)),\n\t\tsnippet: snippet.key\n\t}));\n}\n\nfunction expandedAbbreviationCompletion(editor, pos, abbrModel) {\n\tlet preview = abbrModel.preview;\n\tif (preview.length > 500) {\n\t\tpreview = preview.slice(0, 500) + '...';\n\t}\n\n\treturn new EmmetCompletion('expanded-abbreviation', editor, abbrModel.range,\n\t\t'Expand abbreviation', preview, (editor, range) => abbrModel.insert(editor, range));\n}\n\n/**\n * Extracts prefix from the end of given string that matches `match` regexp\n * @param {String} str\n * @param {RegExp} match\n * @return {String} Extracted prefix\n */\nfunction extractPrefix(str, match) {\n\tlet offset = str.length;\n\n\twhile (offset > 0) {\n\t\tif (!match.test(str[offset - 1])) {\n\t\t\tbreak;\n\t\t}\n\t\toffset--;\n\t}\n\n\treturn str.slice(offset);\n}\n\nclass EmmetCompletion {\n\t/**\n\t * @param {String} type\n\t * @param {CodeMirror.Editor} editor\n\t * @param {CodeMirror.Range} range\n\t * @param {String} name\n\t * @param {String} preview\n\t * @param {Function} snippet\n\t */\n\tconstructor(type, editor, range, name, preview, snippet) {\n\t\tthis.type = type;\n\t\tthis.editor = editor;\n\t\tthis.range = range;\n\t\tthis.name = name;\n\t\tthis.preview = preview;\n\t\tthis.snippet = snippet;\n\n\t\tthis._inserted = false;\n\t}\n\n\tinsert() {\n\t\tif (!this._inserted) {\n\t\t\tthis._inserted = true;\n\t\t\tif (typeof this.snippet === 'function') {\n\t\t\t\tthis.snippet(this.editor, this.range);\n\t\t\t} else {\n\t\t\t\tinsertSnippet(this.editor, this.range, this.snippet);\n\t\t\t}\n\t\t\tclearMarkers(this.editor);\n\t\t}\n\t}\n}\n","import StreamReader from '@emmetio/stream-reader';\nimport { eatPair, eatQuoted, isAlphaNumeric, isQuote, isSpace } from '@emmetio/stream-reader-utils';\n\nclass Node {\n\tconstructor(stream, type, open, close) {\n\t\tthis.stream = stream;\n\t\tthis.type = type;\n\t\tthis.open = open;\n\t\tthis.close = close;\n\n\t\tthis.children = [];\n\t\tthis.parent = null;\n\t}\n\n\t/**\n\t * Returns node name\n\t * @return {String}\n\t */\n\tget name() {\n\t\tif (this.type === 'tag' && this.open) {\n\t\t\treturn this.open && this.open.name && this.open.name.value;\n\t\t}\n\n\t\treturn '#' + this.type;\n\t}\n\n\t/**\n\t * Returns attributes of current node\n\t * @return {Array}\n\t */\n\tget attributes() {\n\t\treturn this.open && this.open.attributes;\n\t}\n\n\t/**\n\t * Returns node’s start position in stream\n\t * @return {*}\n\t */\n\tget start() {\n\t\treturn this.open && this.open.start;\n\t}\n\n\t/**\n\t * Returns node’s start position in stream\n\t * @return {*}\n\t */\n\tget end() {\n\t\treturn this.close ? this.close.end : this.open && this.open.end;\n\t}\n\n\tget firstChild() {\n\t\treturn this.children[0];\n\t}\n\n\tget nextSibling() {\n\t\tconst ix = this.getIndex();\n\t\treturn ix !== -1 ? this.parent.children[ix + 1] : null;\n\t}\n\n\tget previousSibling() {\n\t\tconst ix = this.getIndex();\n\t\treturn ix !== -1 ? this.parent.children[ix - 1] : null;\n\t}\n\n\t/**\n\t * Returns current element’s index in parent list of child nodes\n\t * @return {Number}\n\t */\n\tgetIndex() {\n\t\treturn this.parent ? this.parent.children.indexOf(this) : -1;\n\t}\n\n\t/**\n\t * Adds given node as a child\n\t * @param {Node} node\n\t * @return {Node} Current node\n\t */\n\taddChild(node) {\n\t\tthis.removeChild(node);\n\t\tthis.children.push(node);\n\t\tnode.parent = this;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes given node from current node’s child list\n\t * @param  {Node} node\n\t * @return {Node} Current node\n\t */\n\tremoveChild(node) {\n\t\tconst ix = this.children.indexOf(node);\n\t\tif (ix !== -1) {\n\t\t\tthis.children.splice(ix, 1);\n\t\t\tnode.parent = null;\n\t\t}\n\n\t\treturn this;\n\t}\n}\n\n/**\n * A token factory method\n * @param  {StreamReader}   stream\n * @param  {Point|Function} start  Tokens’ start location or stream consumer\n * @param  {Point}          [end]  Tokens’ end location\n * @return {Token}\n */\nvar token = function(stream, start, end) {\n\treturn typeof start === 'function'\n\t\t? eatToken(stream, start)\n\t\t: new Token(stream, start, end);\n};\n\n/**\n * Consumes characters from given stream that matches `fn` call and returns it\n * as token, if consumed\n * @param  {StreamReader} stream\n * @param  {Function} test\n * @return {Token}\n */\nfunction eatToken(stream, test) {\n\tconst start = stream.pos;\n\tif (stream.eatWhile(test)) {\n\t\treturn new Token(stream, start, stream.pos);\n\t}\n\n\tstream.pos = start;\n}\n\n/**\n * A structure describing text fragment in content stream\n */\nclass Token {\n\t/**\n\t * @param {ContentStreamReader} stream\n\t * @param {Point} start         Tokens’ start location in content stream\n\t * @param {Point} end           Tokens’ end location in content stream\n\t */\n\tconstructor(stream, start, end) {\n\t\tthis.stream = stream;\n\t\tthis.start = start != null ? start : stream.start;\n\t\tthis.end   = end   != null ? end   : stream.pos;\n\t\tthis._value = null;\n\t}\n\n\t/**\n\t * Returns token textual value\n\t * NB implemented as getter to reduce unnecessary memory allocations for\n\t * strings that not required\n\t * @return {String}\n\t */\n\tget value() {\n\t\tif (this._value === null) {\n\t\t\tconst start = this.stream.start;\n\t\t\tconst end = this.stream.pos;\n\n\t\t\tthis.stream.start = this.start;\n\t\t\tthis.stream.pos = this.end;\n\t\t\tthis._value = this.stream.current();\n\n\t\t\tthis.stream.start = start;\n\t\t\tthis.stream.pos = end;\n\t\t}\n\n\t\treturn this._value;\n\t}\n\n\ttoString() {\n\t\treturn this.value;\n\t}\n\n\tvalueOf() {\n\t\treturn `${this.value} [${this.start}; ${this.end}]`;\n\t}\n}\n\nconst LANGLE  = 60;\nconst RANGLE  = 62;  // < and >\nconst LSQUARE = 91;\nconst RSQUARE = 93;  // [ and ]\nconst LROUND  = 40;\nconst RROUND  = 41;  // ( and )\nconst LCURLY  = 123;\nconst RCURLY  = 125; // { and }\n\nconst opt = { throws: true };\n\n/**\n * Consumes paired tokens (like `[` and `]`) with respect of nesting and embedded\n * quoted values\n * @param  {StreamReader} stream\n * @return {Token} A token with consumed paired character\n */\nvar eatPaired = function(stream) {\n\tconst start = stream.pos;\n\tconst consumed = eatPair(stream, LANGLE, RANGLE, opt)\n\t\t|| eatPair(stream, LSQUARE, RSQUARE, opt)\n\t\t|| eatPair(stream, LROUND,  RROUND,  opt)\n\t\t|| eatPair(stream, LCURLY,  RCURLY,  opt);\n\n\tif (consumed) {\n\t\treturn token(stream, start);\n\t}\n};\n\nconst SLASH$1        = 47;  // /\nconst EQUALS       = 61;  // =\nconst RIGHT_ANGLE$1  = 62;  // >\n\n/**\n * Consumes attributes from given stream\n * @param {StreamReader} stream\n * @return {Array} Array of consumed attributes\n */\nvar eatAttributes = function(stream) {\n\tconst result = [];\n\tlet name, value, attr;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isSpace);\n\t\tattr = { start: stream.pos };\n\n\t\t// A name could be a regular name or expression:\n\t\t// React-style – <div {...props}>\n\t\t// Angular-style – <div [ng-for]>\n\t\tif (attr.name = eatAttributeName(stream)) {\n\t\t\t// Consumed attribute name. Can be an attribute with name\n\t\t\t// or boolean attribute. The value can be React-like expression\n\t\t\tif (stream.eat(EQUALS)) {\n\t\t\t\tattr.value = eatAttributeValue(stream);\n\t\t\t} else {\n\t\t\t\tattr.boolean = true;\n\t\t\t}\n\t\t\tattr.end = stream.pos;\n\t\t\tresult.push(attr);\n\t\t} else if (isTerminator(stream.peek())) {\n\t\t\t// look for tag terminator in order to skip any other possible characters\n\t\t\t// (maybe junk)\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Consumes attribute name from current location\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatAttributeName(stream) {\n\treturn eatPaired(stream) || token(stream, isAttributeName);\n}\n\n/**\n * Consumes attribute value from given location\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatAttributeValue(stream) {\n\tconst start = stream.pos;\n\tif (eatQuoted(stream)) {\n\t\t// Should return token that points to unquoted value.\n\t\t// Use stream readers’ public API to traverse instead of direct\n\t\t// manipulation\n\t\tconst current = stream.pos;\n\t\tlet valueStart, valueEnd;\n\n\t\tstream.pos = start;\n\t\tstream.next();\n\t\tvalueStart = stream.start = stream.pos;\n\n\t\tstream.pos = current;\n\t\tstream.backUp(1);\n\t\tvalueEnd = stream.pos;\n\n\t\tconst result = token(stream, valueStart, valueEnd);\n\t\tstream.pos = current;\n\t\treturn result;\n\t}\n\n\treturn eatPaired(stream) || eatUnquoted(stream);\n}\n\n/**\n * Check if given code belongs to attribute name.\n * NB some custom HTML variations allow non-default values in name, like `*ngFor`\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAttributeName(code) {\n\treturn code !== EQUALS && !isTerminator(code) && !isSpace(code);\n}\n\n/**\n * Check if given code is tag terminator\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isTerminator(code) {\n\treturn code === RIGHT_ANGLE$1 || code === SLASH$1;\n}\n\n/**\n * Eats unquoted value from stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatUnquoted(stream) {\n\treturn token(stream, isUnquoted);\n}\n\n/**\n * Check if given character code is valid unquoted value\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isUnquoted(code) {\n\treturn !isNaN(code) && !isQuote(code) && !isSpace(code) && !isTerminator(code);\n}\n\nconst DASH        = 45; // -\nconst DOT         = 46; // .\nconst SLASH       = 47; // /\nconst COLON       = 58; // :\nconst LEFT_ANGLE  = 60; // <\nconst RIGHT_ANGLE = 62; // >\nconst UNDERSCORE  = 95; // _\n\n/**\n * Parses tag definition (open or close tag) from given stream state\n * @param {StreamReader} stream Content stream reader\n * @return {Object}\n */\nvar tag = function(stream) {\n\tconst start = stream.pos;\n\n\tif (stream.eat(LEFT_ANGLE)) {\n\t\tconst model = { type: stream.eat(SLASH) ? 'close' : 'open' };\n\n\t\tif (model.name = eatTagName(stream)) {\n\t\t\tif (model.type !== 'close') {\n\t\t\t\tmodel.attributes = eatAttributes(stream);\n\t\t\t\tstream.eatWhile(isSpace);\n\t\t\t\tmodel.selfClosing = stream.eat(SLASH);\n\t\t\t}\n\n\t\t\tif (stream.eat(RIGHT_ANGLE)) {\n\t\t\t\t// tag properly closed\n\t\t\t\treturn Object.assign(token(stream, start), model);\n\t\t\t}\n\t\t}\n\t}\n\n\t// invalid tag, revert to original position\n\tstream.pos = start;\n\treturn null;\n};\n\n/**\n * Eats HTML identifier (tag or attribute name) from given stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatTagName(stream) {\n\treturn token(stream, isTagName);\n}\n\n/**\n * Check if given character code can be used as HTML/XML tag name\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isTagName(code) {\n\treturn isAlphaNumeric(code)\n\t\t|| code === COLON // colon is used for namespaces\n\t\t|| code === DOT   // in rare cases declarative tag names may have dots in names\n\t\t|| code === DASH\n\t\t|| code === UNDERSCORE;\n}\n\n/**\n * Eats array of character codes from given stream\n * @param  {StreamReader} stream\n * @param  {Number[]} codes  Array of character codes\n * @return {Boolean}\n */\nfunction eatArray(stream, codes) {\n\tconst start = stream.pos;\n\n\tfor (let i = 0; i < codes.length; i++) {\n\t\tif (!stream.eat(codes[i])) {\n\t\t\tstream.pos = start;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstream.start = start;\n\treturn true;\n}\n\n/**\n * Consumes section from given string which starts with `open` character codes\n * and ends with `close` character codes\n * @param  {StreamReader} stream\n * @param  {Number[]} open\n * @param  {Number[]} close\n * @return {Boolean}  Returns `true` if section was consumed\n */\nfunction eatSection(stream, open, close, allowUnclosed) {\n\tconst start = stream.pos;\n\tif (eatArray(stream, open)) {\n\t\t// consumed `<!--`, read next until we find ending part or reach the end of input\n\t\twhile (!stream.eof()) {\n\t\t\tif (eatArray(stream, close)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tstream.next();\n\t\t}\n\n\t\t// unclosed section is allowed\n\t\tif (allowUnclosed) {\n\t\t\treturn true;\n\t\t}\n\n\t\tstream.pos = start;\n\t\treturn false;\n\t}\n\n\t// unable to find section, revert to initial position\n\tstream.pos = start;\n\treturn null;\n}\n\n/**\n * Converts given string into array of character codes\n * @param  {String} str\n * @return {Number[]}\n */\nfunction toCharCodes(str) {\n\treturn str.split('').map(ch => ch.charCodeAt(0));\n}\n\nconst open  = toCharCodes('<!--');\nconst close = toCharCodes('-->');\n\n/**\n * Consumes HTML comment from given stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nvar comment = function(stream) {\n\tconst start = stream.pos;\n\tif (eatSection(stream, open, close, true)) {\n\t\tconst result = token(stream, start);\n\t\tresult.type = 'comment';\n\t\treturn result;\n\t}\n\n\treturn null;\n};\n\nconst open$1  = toCharCodes('<![CDATA[');\nconst close$1 = toCharCodes(']]>');\n\n/**\n * Consumes CDATA from given stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nvar cdata = function(stream) {\n\tconst start = stream.pos;\n\tif (eatSection(stream, open$1, close$1, true)) {\n\t\tconst result = token(stream, start);\n\t\tresult.type = 'cdata';\n\t\treturn result;\n\t}\n\n\treturn null;\n};\n\nconst defaultOptions = {\n\t/**\n\t * Expect XML content in searching content. It alters how should-be-empty\n\t * elements are treated: for example, in XML mode parser will try to locate\n\t * closing pair for `<br>` tag\n\t * @type {Boolean}\n\t */\n\txml: false,\n\n\tspecial: ['script', 'style'],\n\n\t/**\n\t * List of elements that should be treated as empty (e.g. without closing tag)\n\t * in non-XML syntax\n\t * @type {Array}\n\t */\n\tempty: ['img', 'meta', 'link', 'br', 'base', 'hr', 'area', 'wbr','col', 'embed', 'input', 'param', 'source', 'track']\n};\n\n/**\n * Parses given content into a DOM-like structure\n * @param  {String|StreamReader} content\n * @param  {Object} options\n * @return {Node}\n */\nfunction parse(content, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\tconst stream = typeof content === 'string'\n\t\t? new StreamReader(content)\n\t\t: content;\n\n\tconst root = new Node(stream, 'root');\n\tconst empty = new Set(options.empty);\n\tconst special = options.special.reduce(\n\t\t(map, name) => map.set(name, toCharCodes(`</${name}>`)), new Map());\n\tconst isEmpty = (token, name) =>\n\t\ttoken.selfClosing || (!options.xml && empty.has(name));\n\n\tlet m, node, name, stack = [root];\n\n\twhile (!stream.eof()) {\n\t\tif (m = match(stream)) {\n\t\t\tname = getName(m);\n\n\t\t\tif (m.type === 'open') {\n\t\t\t\t// opening tag\n\t\t\t\tnode = new Node(stream, 'tag', m);\n\t\t\t\tlast(stack).addChild(node);\n\t\t\t\tif (special.has(name)) {\n\t\t\t\t\tnode.close = consumeSpecial(stream, special.get(name));\n\t\t\t\t} else if (!isEmpty(m, name)) {\n\t\t\t\t\tstack.push(node);\n\t\t\t\t}\n\t\t\t} else if (m.type === 'close') {\n\t\t\t\t// closing tag, find it’s matching opening tag\n\t\t\t\tfor (let i = stack.length - 1; i > 0; i--) {\n\t\t\t\t\tif (stack[i].name.toLowerCase() === name) {\n\t\t\t\t\t\tstack[i].close = m;\n\t\t\t\t\t\tstack = stack.slice(0, i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlast(stack).addChild(new Node(stream, m.type, m));\n\t\t\t}\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t}\n\n\treturn root;\n}\n\n/**\n * Matches known token in current state of given stream\n * @param  {ContentStreamReader} stream\n * @return {Token}\n */\nfunction match(stream) {\n\t// fast-path optimization: check for `<` code\n\tif (stream.peek() === 60 /* < */) {\n\t\treturn comment(stream) || cdata(stream) || tag(stream);\n\t}\n}\n\n/**\n * @param  {StreamReader} stream\n * @param  {Number[]} codes\n * @return {Token}\n */\nfunction consumeSpecial(stream, codes) {\n\tconst start = stream.pos;\n\tlet m;\n\n\twhile (!stream.eof()) {\n\t\tif (eatArray(stream, codes)) {\n\t\t\tstream.pos = stream.start;\n\t\t\treturn tag(stream);\n\t\t}\n\t\tstream.next();\n\t}\n\n\tstream.pos = start;\n\treturn null;\n}\n\n/**\n * Returns name of given matched token\n * @param  {Token} tag\n * @return {String}\n */\nfunction getName(tag$$1) {\n\treturn tag$$1.name ? tag$$1.name.value.toLowerCase() : `#${tag$$1.type}`;\n}\n\nfunction last(arr) {\n\treturn arr[arr.length - 1];\n}\n\nexport { defaultOptions, match };export default parse;\n","'use strict';\n\nimport { containsPos, rangeFromNode } from '../utils';\n\n/**\n * A syntax-specific model container, used to get unified access to underlying\n * parsed document\n */\nexport default class SyntaxModel {\n\t/**\n\t * @param  {Object} dom      Parsed document tree\n\t * @param  {String} type     Type of document (html, stylesheet, etc.)\n\t * @param  {String} [syntax] Optional document syntax like html, xhtml or xml\n\t */\n\tconstructor(dom, type, syntax) {\n\t\tthis.dom = dom;\n\t\tthis.type = type;\n\t\tthis.syntax = syntax;\n\t}\n\n\t/**\n\t * Returns best matching node for given point\n\t * @param  {CodeMirror.Pos}   pos\n\t * @param  {Boolean} [exclude] Exclude node’s start and end positions from\n\t *                             search\n\t * @return {Node}\n\t */\n\tnodeForPoint(pos, exclude) {\n\t\tlet ctx = this.dom.firstChild;\n\t\tlet found = null;\n\n\t\twhile (ctx) {\n\t\t\tif (containsPos(rangeFromNode(ctx), pos, exclude)) {\n\t\t\t\t// Found matching tag. Try to find deeper, more accurate match\n\t\t\t\tfound = ctx;\n\t\t\t\tctx = ctx.firstChild;\n\t\t\t} else {\n\t\t\t\tctx = ctx.nextSibling;\n\t\t\t}\n\t\t}\n\n\t\treturn found;\n\t}\n}\n","'use strict';\n\nimport parseHTML from '@emmetio/html-matcher';\nimport SyntaxModel from './syntax-model';\nimport StreamReader from '../stream-reader';\n\n/**\n * Creates DOM-like model for given text editor\n * @param  {CodeMirror} editor\n * @param  {String}     syntax\n * @return {Node}\n */\nexport default function create(editor, syntax) {\n\tconst stream = new StreamReader(editor);\n\tconst xml = syntax === 'xml';\n\n\ttry {\n\t\treturn new SyntaxModel(parseHTML(stream, { xml }), 'html', syntax || 'html');\n\t} catch (err) {\n\t\tconsole.warn(err);\n\t}\n}\n","'use strict';\n\nimport parseHTML from './html';\n\nexport default function getModel(editor) {\n\tconst syntax = getSyntax(editor);\n\treturn parseHTML(editor, syntax);\n}\n\nexport function getCachedModel(editor) {\n\tif (!editor.state._emmetModel) {\n\t\teditor.state._emmetModel = getModel(editor);\n\t}\n\n\treturn editor.state._emmetModel;\n}\n\nexport function resetCachedModel(editor) {\n\teditor.state._emmetModel = null;\n}\n\n/**\n * Returns parser-supported syntax of given editor (like 'html', 'css' etc.).\n * Returns `null` if editor’s syntax is unsupported\n * @param  {CodeMirror} editor\n * @return {String}\n */\nfunction getSyntax(editor) {\n\tconst mode = editor.getMode();\n\n\tif (mode.name === 'htmlmixed') {\n\t\treturn 'html';\n\t}\n\n\treturn mode.name === 'xml' ? mode.configuration : mode.name;\n}\n","'use strict';\n\nimport { containsPos } from './utils';\n\nconst openTagMark = 'emmet-open-tag';\nconst closeTagMark = 'emmet-close-tag';\n\n/**\n * Finds matching tag pair for given position in editor\n * @param  {CodeMirror.Editor} editor\n * @param  {CodeMirror.Position} pos\n * @return {Object}\n */\nexport default function matchTag(editor, pos) {\n\tpos = pos || editor.getCursor();\n\n\t// First, check if there are tag markers in editor\n\tconst marked = getMarkedTag(editor);\n\n\t// If marks found, validate them: make sure cursor is either in open\n\t// or close tag\n\tif (marked) {\n\t\tif (containsPos(marked.open.find(), pos)) {\n\t\t\t// Point is inside open tag, make sure if there’s a closing tag,\n\t\t\t// it matches open tag content\n\t\t\tif (!marked.close || text(editor, marked.open) === text(editor, marked.close)) {\n\t\t\t\treturn marked;\n\t\t\t}\n\t\t} else if (marked.close) {\n\t\t\t// There’s a close tag, make sure pointer is inside it and it matches\n\t\t\t// open tag\n\t\t\tif (containsPos(marked.close.find(), pos) && text(editor, marked.open) === text(editor, marked.close)) {\n\t\t\t\treturn marked;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Markers are not valid anymore, remove them\n\tclearTagMatch(editor);\n\n\t// Find new tag pair from parsed HTML model and mark them\n\tconst node = findTagPair(editor, pos);\n\tif (node && node.type === 'tag') {\n\t\treturn {\n\t\t\topen: createTagMark(editor, node.open.name, openTagMark),\n\t\t\tclose: node.close && createTagMark(editor, node.close.name, closeTagMark)\n\t\t};\n\t}\n}\n\nexport function getMarkedTag(editor) {\n\tlet open, close;\n\teditor.getAllMarks().forEach(mark => {\n\t\tif (mark.className === openTagMark) {\n\t\t\topen = mark;\n\t\t} else if (mark.className === closeTagMark) {\n\t\t\tclose = mark;\n\t\t}\n\t});\n\n\treturn open ? { open, close } : null;\n}\n\n/**\n * Removes all matched tag pair markers from editor\n * @param  {CodeMirror.Editor} editor\n */\nexport function clearTagMatch(editor) {\n\teditor.getAllMarks().forEach(mark => {\n\t\tif (mark.className === openTagMark || mark.className === closeTagMark) {\n\t\t\tmark.clear();\n\t\t}\n\t});\n}\n\n/**\n * Finds tag pair (open and close, if any) form parsed HTML model of given editor\n * @param  {CodeMirror.Editor} editor\n * @param  {CodeMirror.Position} pos\n * @return {Object}\n */\nexport function findTagPair(editor, pos) {\n\tconst model = editor.getEmmetDocumentModel();\n\treturn model && model.nodeForPoint(pos || editor.getCursor());\n}\n\nfunction createTagMark(editor, tag, className) {\n\treturn editor.markText(tag.start, tag.end, {\n\t\tclassName,\n\t\tinclusiveLeft: true,\n\t\tinclusiveRight: true,\n\t\tclearWhenEmpty: false\n\t});\n}\n\nfunction text(editor, mark) {\n\tconst range = mark.find();\n\treturn range ? editor.getRange(range.from, range.to) : '';\n}\n","'use strict';\n\nimport { getMarkedTag, clearTagMatch } from './match-tag';\nimport { containsPos } from './utils';\n\nexport default function renameTag(editor, obj) {\n\tconst tag = getMarkedTag(editor);\n\tconst pos = obj.from;\n\n\tif (!tag) {\n\t\treturn;\n\t}\n\n\tif (containsPos(tag.open.find(), pos) && tag.close) {\n\t\t// Update happened inside open tag, update close tag as well\n\t\tupdateTag(editor, tag.open, tag.close);\n\t} else if (tag.close && containsPos(tag.close.find(), pos)) {\n\t\t// Update happened inside close tag, update open tag as well\n\t\tupdateTag(editor, tag.close, tag.open);\n\t}\n}\n\nexport function updateTag(editor, source, dest) {\n\tconst name = text(editor, source);\n\tconst range = dest.find();\n\tconst m = name.match(/[\\w:.-]+/);\n\tconst newName = !name ? '' : (m && m[0]);\n\n\tif (newName != null) {\n\t\tif (editor.getRange(range.from, range.to) !== newName) {\n\t\t\teditor.replaceRange(newName, range.from, range.to);\n\t\t}\n\t} else {\n\t\t// User entered something that wasn’t a valid tag name.\n\t\tclearTagMatch(editor);\n\t}\n}\n\nfunction text(editor, mark) {\n\tconst range = mark.find();\n\treturn range ? editor.getRange(range.from, range.to) : '';\n}\n","'use strict';\n\nimport registerEmmetExtension from './extension.js';\n\nif (typeof CodeMirror !== 'undefined') {\n\tregisterEmmetExtension(CodeMirror);\n}\n","'use strict';\n\nimport expandAbbreviation from './lib/commands/expand-abbreviation';\nimport emmetInsertLineBreak from './lib/commands/formatted-line-break';\nimport emmetWrapWithAbbreviation from './lib/commands/wrap-with-abbreviation';\nimport markAbbreviation from './lib/abbreviation-marker';\nimport getAbbreviation, { findMarker, clearMarkers, createMarker } from './lib/abbreviation';\nimport autocompleteProvider from './lib/autocomplete';\nimport getModel, { getCachedModel, resetCachedModel } from './lib/model/index';\nimport matchTag, { clearTagMatch } from './lib/match-tag';\nimport renameTag from './lib/rename-tag';\n\n/**\n * Registers Emmet extension on given CodeMirror constructor.\n * This file is designed to be imported somehow into the app (CommonJS, ES6,\n * Rollup/Webpack/whatever). If you simply want to add a <script> into your page\n * that registers Emmet extension on global CodeMirror constructor, use\n * `browser.js` instead\n */\nexport default function registerEmmetExtension(CodeMirror) {\n\t// Register Emmet commands\n\tObject.assign(CodeMirror.commands, {\n\t\temmetExpandAbbreviation: editor => expandAbbreviation(editor, true),\n\t\temmetExpandAbbreviationAll: editor => expandAbbreviation(editor, false),\n\t\temmetInsertLineBreak,\n\t\temmetWrapWithAbbreviation\n\t});\n\tconst markOnEditorChange = editor => markAbbreviation(editor, editor.getCursor());\n\n\t// Defines options that allows abbreviation marking in text editor\n\tCodeMirror.defineOption('markEmmetAbbreviation', true, (editor, value) => {\n\t\tif (value) {\n\t\t\teditor.on('change', markOnEditorChange);\n\t\t} else {\n\t\t\teditor.off('change', markOnEditorChange);\n\t\t\tclearMarkers(editor);\n\t\t}\n\t});\n\n\tCodeMirror.defineOption('autoRenameTags', true, (editor, value) => {\n\t\tvalue ? editor.on('change', renameTag) : editor.off('change', renameTag);\n\t});\n\n\t// Enable/disable leading angle bracket for JSX abbreviations\n\tCodeMirror.defineOption('jsxBracket', true);\n\n\tCodeMirror.defineOption('markTagPairs', false, (editor, value) => {\n\t\tif (value) {\n\t\t\teditor.on('cursorActivity', matchTag);\n\t\t\teditor.on('change', resetCachedModel);\n\t\t} else {\n\t\t\teditor.off('cursorActivity', matchTag);\n\t\t\teditor.off('change', resetCachedModel);\n\t\t\tresetCachedModel(editor);\n\t\t\tclearTagMatch(editor);\n\t\t}\n\t});\n\n\t// Emmet config: https://github.com/emmetio/config\n\tCodeMirror.defineOption('emmet', {});\n\n\t/**\n\t * Returns Emmet completions for context from `pos` position.\n\t * Abbreviations are calculated for marked abbreviation at given position.\n\t * If no parsed abbreviation marker is available and `force` argument is\n\t * given, tries to mark abbreviation and populate completions list again.\n\t * @param  {CodeMirror.Position} [pos]\n\t * @param  {Boolean} [force]\n\t * @return {EmmetCompletion[]}\n\t */\n\tCodeMirror.defineExtension('getEmmetCompletions', function(pos, force) {\n\t\tconst editor = this;\n\t\tif (typeof pos === 'boolean') {\n\t\t\tforce = pos;\n\t\t\tpos = null;\n\t\t}\n\n\t\tpos = pos || editor.getCursor();\n\n\t\tconst autocomplete = autocompleteProvider(editor, pos);\n\t\tif (autocomplete && autocomplete.completions.length) {\n\t\t\tif (editor.getOption('markEmmetAbbreviation')) {\n\t\t\t\t// Ensure abbreviation marker exists\n\t\t\t\tif (!findMarker(editor, pos) && force) {\n\t\t\t\t\tclearMarkers(editor);\n\t\t\t\t\tcreateMarker(autocomplete.model);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tfrom: autocomplete.abbreviation.range.from,\n\t\t\t\tto: autocomplete.abbreviation.range.to,\n\t\t\t\tlist: autocomplete.completions\n\t\t\t};\n\t\t}\n\t});\n\n\t/**\n\t * Returns valid Emmet abbreviation and its location in editor from given\n\t * position\n\t * @param  {CodeMirror.Pos} [pos] Position from which abbreviation should be\n\t * extracted. If not given, current cursor position is used\n\t * @return {Abbreviation}\n\t */\n\tCodeMirror.defineExtension('getEmmetAbbreviation', function(pos, contextAware) {\n\t\treturn getAbbreviation(this, pos || this.getCursor(), contextAware);\n\t});\n\n\tCodeMirror.defineExtension('findEmmetMarker', function(pos) {\n\t\treturn findMarker(this, pos || this.getCursor());\n\t});\n\n\tCodeMirror.defineExtension('getEmmetDocumentModel', function() {\n\t\tconst editor = this;\n\t\treturn editor.getOption('markTagPairs')\n\t\t\t? getCachedModel(editor)\n\t\t\t: getModel(editor);\n\t});\n}\n","'use strict';\n\nimport getAbbreviation, { findMarker, createMarker, clearMarkers } from './abbreviation';\n\n/**\n * Marks Emmet abbreviation for given editor position, if possible\n * @param  {CodeMirror.Editor} editor Editor where abbreviation marker should be created\n * @param  {CodeMirror.Position} pos Editor position where abbreviation marker\n * should be created. Abbreviation will be automatically extracted from given position\n * @return {CodeMirror.TextMarker} Returns `undefined` if no valid abbreviation under caret\n */\nexport default function markAbbreviation(editor, pos) {\n\tconst marker = findMarker(editor, pos);\n\tif (marker) {\n\t\t// there’s active marker with valid abbreviation\n\t\treturn marker;\n\t}\n\n\t// No active marker: remove previous markers and create new one, if possible\n\tclearMarkers(editor);\n\n\tconst model = getAbbreviation(editor, pos, true);\n\n\tif (model) {\n\t\treturn createMarker(editor, model);\n\t}\n}\n"],"names":["const","SINGLE_QUOTE","DOUBLE_QUOTE","defaultOptions","escape","throws","eatQuoted","stream","options","Object","assign","start","pos","quote","peek","eat","isQuote","eof","next","error","code","isNumber","isAlpha","from","to","isAlphaNumeric","isWhiteSpace","isSpace","defaultOptions$1","eatPair","open","close","let","ch","stack","String","fromCharCode","Attribute","name","value","this","clone","valueOf","Node","attributes","repeat","selfClosing","children","parent","previous","_attributes","Array","isArray","forEach","attr","setAttribute","createAttribute","normalize","str","trim","uniqueClass","item","i","arr","indexOf","prototypeAccessors","attributesMap","reduce","out","boolean","isGroup","length","isTextOnly","firstChild","lastChild","childIndex","nextSibling","previousSibling","classList","getAttribute","split","filter","create","curAttr","replaceAttribute","push","hasAttribute","curAttribute","newName","newValue","ix","splice","removeAttribute","clearAttributes","addClass","token","hasClass","concat","join","removeClass","appendChild","node","insertAt","insertBefore","newNode","refNode","Error","prev","remove","removeChild","deep","child","walk","fn","_level","ctx","use","args","arguments","apply","toString","attrs","map","opt","implied","count","StreamReader","string","end","limit","constructor","charCodeAt","match","ok","eatWhile","backUp","n","current","substring","slice","message","err","originalMessage","ASTERISK","consumeRepeat","consumeQuoted","TEXT_START","TEXT_END","ESCAPE","consumeText","result","offset","EXCL","DOT","EQUALS","ATTR_OPEN","ATTR_CLOSE","reAttributeName","consumeAttributes","eatUnquoted","test","parseAttributeName","before","after","keys","isUnquoted","HASH","DOT$1","SLASH","consumeElement","eatName","il","isName","GROUP_START","GROUP_END","OP_SIBLING","OP_CHILD","OP_CLIMB","index","abbr","tree","root","groupStack","lastGroup","pop","parse","unroll","registry","Set","resolve","snippet","has","add","delete","childTarget","findDeepestNode","classNames","mergeClassNames","attrMap","Map","set","a","get","newAttrs","values","mergeAttributes","merge","resolveNode","inlineElements","elementMap","p","ul","ol","table","tr","tbody","thead","tfoot","colgroup","select","optgroup","audio","video","object","resolveImplicitName","parentName","toLowerCase","implicitTags","resolveImplicitTag","findUnescapedTokens","tlen","size","len","replaceRanges","ranges","r","offsetLength","descendingOrder","substr","matches","Number","parseInt","numberingToken","applyNumbering","applyNumbering$1","repeater","findRepeater","replaceNumbering","copy","unescapeString","_value","replaceNumberingRanges","range$$1","lastRange","getNumberingRanges","placeholder","caret","reUrl","reEmail","reProto","prepare","amount","implicit","insert","content","updated","inserted","insertContentIntoPlaceholder","setNodeContent","insertContent","state","replaced","replacePlaceholder","_state","element","modifier","reElement","reModifier","blockCandidates1","className","blockCandidates2","getBlockName","lookup","prefix","depth","find","replace","oldName","reSupporterNames","supportedAddons","cl","startsWith","expandClassNames","createBlockLookup","m","originalClass","arrClassNames","Boolean","expandShortNotation","addons","key","addonOpt","appliedAddons","replaceVariables","variables","replaceInString","replaceInNode","model","reVariable","tokens","exec","output","validMatches","location","createModel","v","DOLLAR","COLON","OPEN_BRACE","CLOSE_BRACE","field","fields","cleanString","consumeField","FieldString","createToken","consumeIndex","Field","consumePlaceholder","mark","order","sort","b","defaultFieldsRenderer","text","OutputNode","fieldsRenderer","_fieldsRenderer","beforeOpen","afterOpen","beforeClose","afterClose","beforeText","afterText","indent","newline","indentText","lines","splitByLines","nl","line","renderFields","_wrap","defaultField","render","formatter","fieldState","run","nodes","outNode","parseFields","largestIndex","getFieldsModel","TOKEN","TOKEN_OPEN","TOKEN_CLOSE","template","data","lastPos","replacer","left","right","isFirstChild","isRoot","isPseudoSnippet","handlePseudoSnippet","fieldsModel","parts","splitFieldsModel","commentOptions","enabled","trigger","shouldFormatNode","profile","isInline","adjacentInline","isInlineElement","shouldFormatInline","reId","reClass","defaultAttrOptions","primary","secondary","isBoolean","defaultNodeOptions","omitName","indentFormat","level","getIndentLevel$1","NAME","SELF_CLOSE","selfClose","attribute","PRIMARY_ATTRS","SECONDARY_ATTRS","getAttributes","reNl","reNl$1","secondaryAttrs","none","round","curly","square","reNl$2","supportedSyntaxes","format","comment","getFormatOptions","skip","getIndentLevel","nodeName","hasInnerFormatting","setFormatting","attrName","attrValue","formatAttributes","toUpperCase","commentNode","nodeOptions","updateFormatting","maxLength","Math","max","formatNodeValue","attributeWrap","booleanAttr","isInline$1","updateFormatting$1","formatNodeValue$1","updateFormatting$2","formatNodeValue$2","syntax","supports","CSSValue","type","consumeColor","isHex","base","Color","alpha","raw","g","isShortHex","hex","toShortHex","num","toHex","pad","isAlphaNumericWord","isAlphaWord","short","toRGB","toFixed","PERCENT","DASH","consumeNumericValue","afterNegative","prevPos","eatNumber","NumericValue","unit","DASH$1","AT","consumeKeyword","isVariableName","isKeyword","Keyword","QuotedString","LBRACE","RBRACE","COMMA","consumeArgumentList","arg","argsList","consumeArgument","consumeKeywordOrFunction","kw","FunctionCall","DOLLAR$1","PLUS","DASH$2","AT$1","consumeIdent","isIdentPrefix","isIdent","consumeValue","stringScore","ch1","ch2","found","acronym","abbrLength","stringLength","j","score","reProperty","cssSnippets","snippets","snippetsSort","cur","property","addDependency","nest","CSSSnippet","dependencies","splitValue","dep","defaultValue","keywords","candidates","deps","globalKeywords","unitlessProperties","intUnit","floatUnit","unitAliases","e","x","fuzzySearchMinScore","all","convertToCSSSnippets","findBestMatch","resolveAsPropertyValue","setNodeAsText","formatOptions","isKeyword$1","isNumericValue","resolveNumericValue","getUnmatchedPart","resolveAsProperty","resolveAsSnippet","items","matchedItem","maxScore","getScoringPart","tokenTypeOf","defaultFormatOptions","shortHex","between","css","formatOpt","stringifyValue","fieldsAmount","shift","delta","injectFields","endsWith","syntaxFormat","scss","less","sass","stylus","getFormat","a:link","a:mail","a:tel","acr|acronym","basefont","br","frame","hr","bdo","bdo:r","bdo:l","col","link","link:css","link:print","link:favicon","link:touch","link:rss","link:atom","link:im|link:import","meta","meta:utf","meta:vp","meta:compat","meta:edge","meta:redirect","style","script","script:src","img","img:s|img:srcset","img:z|img:sizes","picture","src|source","src:sc|source:src","src:s|source:srcset","src:t|source:type","src:z|source:sizes","src:m|source:media","src:mt|source:media:type","src:mz|source:media:sizes","src:zt|source:sizes:type","iframe","embed","param","area","area:d","area:c","area:r","area:p","form","form:get","form:post","label","input","inp","input:h|input:hidden","input:t|input:text","input:search","input:email","input:url","input:p|input:password","input:datetime","input:date","input:datetime-local","input:month","input:week","input:time","input:tel","input:number","input:color","input:c|input:checkbox","input:r|input:radio","input:range","input:f|input:file","input:s|input:submit","input:i|input:image","input:b|input:button","input:reset","isindex","select:d|select:disabled","opt|option","textarea","marquee","menu:c|menu:context","menu:t|menu:toolbar","html:xml","keygen","command","btn:s|button:s|button:submit","btn:r|button:r|button:reset","btn:d|button:d|button:disabled","fst:d|fset:d|fieldset:d|fieldset:disabled","bq","fig","figc","pic","ifr","emb","obj","cap","colg","fst","btn","optg","tarea","leg","sect","art","hdr","ftr","adr","dlg","prog","mn","tem","fset","datag","datal","kg","det","cmd","ri:d|ri:dpr","ri:v|ri:viewport","ri:a|ri:art","ri:t|ri:type","!!!","doc","!|html:5","c","cc:ie","cc:noie","@f","@ff","@i|@import","@kf","@m|@media","ac","ai","anim","animdel","animdir","animdur","animfm","animic","animn","animps","animtf","ap","as","bd","bdb","bdbc","bdbi","bdbk","bdbli","bdblrs","bdbri","bdbrrs","bdbs","bdbw","bdc","bdci","bdcl","bdf","bdi","bdl","bdlc","bdlen","bdli","bdls","bdlw","bdr","bdrc","bdri","bdrs","bdrst","bdrw","bds","bdsp","bdt","bdtc","bdti","bdtli","bdtlrs","bdtri","bdtrrs","bdts","bdtw","bdw","bfv","bg","bga","bgbk","bgc","bgcp","bgi","bgo","bgp","bgpx","bgpy","bgr","bgsz","bxsh","bxsz","cm","cnt","coi","colm","colmc","colmf","colmg","colmr","colmrc","colmrs","colmrw","colms","colmw","cor","cp","cps","d","ec","f","fef","fem","femp","fems","ff","fl","fs","fsm","fv","fw","fx","fxb","fxd","fxf","fxg","fxsh","fxw","fz","fza","h","jc","l","lg","lh","lis","lisi","lisp","list","lts","mah","mar","maw","mb","mih","mir","miw","ml","mr","mt","olc","olo","ols","olw","op","ord","ori","orp","ov","ovs","ovx","ovy","pb","pgba","pgbb","pgbi","pl","pr","pt","q","qen","qru","rsz","t","ta","tal","tbl","td","te","th","ti","tj","tov","trf","trfo","trfs","trs","trsde","trsdu","trsp","trstf","tsh","tt","tw","us","va","w","whs","whsc","wid","wm","wob","wos","wow","z","zom","tm|tmatch","tn|tname","call","api","imp","inc","wh|xsl:when","ot","if","par","pare","var","vare","wp","elem","co","val","for|each","tex","com","msg","fall","nam","pres","strip","proc","choose","xsl","langs","common","words","wordCount","skipCommon","lang","dict","latin","startWithCommon","isRepeating","paragraph","rand","floor","random","sample","iterations","min","sentence","word","insertCommas","hasComma","totalCommas","totalWords","Snippet","SnippetsStorage","_string","_regexp","_disabled","load","disabled","disable","enable","k","RegExp","reset","clear","regexp","SnippetsRegistry","_registry","store","fillResult","tagCase","attributeCase","attributeQuotes","formatSkip","formatForce","inlineBreak","compactBooleanAttributes","booleanAttributes","selfClosingStyle","Profile","quoteChar","strcase","config","parseAbbreviation","resolveSnippets","resolveVariables","transform","parse$1","parseAbbreviation$1","resolveSnippets$1","isBooleanAttribute","reLorem","loremGenerator","lorem","defaultVariables","locale","charset","stylesheetSyntaxes","expand$2","getType","createOptions","format$1","expand$1","expand","createSnippetsRegistry","registrySnippets","defaultSnippets","html","snippetsRegistryFactory","isStylesheet","createProfile","sol","TAB","SPACE","isAtHTMLTag","eatIdent","eatAttributeWithUnquotedValue","eatAttribute","eatAttributeWithQuotedValue","isUnquotedValue","SQUARE_BRACE_L","SQUARE_BRACE_R","ROUND_BRACE_L","ROUND_BRACE_R","CURLY_BRACE_L","CURLY_BRACE_R","specialChars","bracePairs","lookAhead","extractAbbreviation","isCloseBrace","offsetPastAutoClosed","compiledPrefix","consumePair","consumeArray","getStartOffset","isOpenBrace","isAbbreviation","abbreviation","consumed","defaultSyntaxes","markup","stylesheet","knownSyntaxes","compileConfig","params","resolved","ref","project","mergeConfig","getConfig","resolveConfig","createParams","knownFields","editorField","createConfig","editor","rootMode","getMode","mode","getModeAt","getSyntax","getCursor","getOption","jsx","configuration","CodeMirrorStreamReader","super","CodeMirror","Pos","lastLine","_eof","_lineLength","_sof","sof","comparePos","lineStr","getLine","NaN","getRange","isLast","normalizeText","indentation","repeatString","getIndentation","tabs","removeFields","containsPos","range","exclude","rangeFromNode","isCSSPropertyValue","getTokenAt","localState","context","insertSnippet","matchIndent","fieldModel","operation","replaceRange","startIx","indexFromPos","posFromIndex","setSelection","setCursor","emmetMarkerClass","abbreviationFromPosition","contextAware","marker","findMarker","extracted","tokenType","getTokenTypeAt","canExtract","extract","getCSSPropertyName","Abbreviation","valid","markers","findMarksAt","isValidMarker","clearMarkers","getAllMarks","createMarker","markText","inclusiveLeft","inclusiveRight","clearWhenEmpty","console","warn","ast","preview","somethingSelected","Pass","getAbbreviation","listSelections","sel","anchor","head","sticky","cmp","cursor","betweenTags","some","sels","singleSep","lineSeparator","doubleSep","indentLine","setSelections","wrapWithAbbreviation","getEmmetDocumentModel","tag","nodeForPoint","inRange","narrowToNonSpace","getTagRangeForPos","getWrappingContentRange","prompt","defaultPrompt","callback","window","_isValidForStylesheet","isProperty","every","completions","abbrModel","EmmetCompletion","expandedAbbreviationCompletion","extractPrefix","prefixRange","getSnippetCompletions","completion","lowerProp","getStylesheetCompletions","getMarkupCompletions","emmetCompletions","cache","getStylesheetSnippets","getMarkupSnippets","_inserted","getIndex","addChild","Token","eatToken","eatPaired","SLASH$1","RIGHT_ANGLE$1","eatAttributeName","isAttributeName","eatAttributeValue","valueStart","valueEnd","isTerminator","isNaN","UNDERSCORE","isTagName","eatTagName","eatAttributes","eatArray","codes","eatSection","allowUnclosed","toCharCodes","open$1","close$1","cdata","xml","special","empty","consumeSpecial","last","SyntaxModel","dom","tag$$1","isEmpty","parseHTML","getModel","resetCachedModel","_emmetModel","openTagMark","closeTagMark","matchTag","marked","getMarkedTag","clearTagMatch","findTagPair","createTagMark","renameTag","updateTag","source","dest","commands","emmetExpandAbbreviation","expandAbbreviation","emmetExpandAbbreviationAll","emmetInsertLineBreak","emmetWrapWithAbbreviation","markOnEditorChange","markAbbreviation","defineOption","on","off","defineExtension","force","autocomplete","autocompleteProvider","getCachedModel","registerEmmetExtension"],"mappings":"uJAIAA,IAAMC,EAAe,GACfC,EAAe,GAEfC,GACLC,OAAQ,GACRC,QAAQ,GAWLC,EAAY,SAASC,EAAQC,GAChCA,EAAUA,EAAUC,OAAOC,UAAWP,EAAgBK,GAAWL,EACjEH,IAAMW,EAAQJ,EAAOK,IACfC,EAAQN,EAAOO,OAErB,GAAIP,EAAOQ,IAAIC,GAAU,CACxB,MAAQT,EAAOU,OACd,OAAQV,EAAOW,QACd,KAAKL,EAEJ,OADAN,EAAOI,MAAQA,GACR,EAER,KAAKH,EAAQJ,OACZG,EAAOW,OASV,GAFAX,EAAOK,IAAMD,EAETH,EAAQH,OACX,MAAME,EAAOY,MAAM,mCAIrB,OAAO,GAGR,SAASH,EAAQI,GAChB,OAAOA,IAASnB,GAAgBmB,IAASlB,EAQ1C,SAASmB,EAASD,GACjB,OAAOA,EAAO,IAAMA,EAAO,GAU5B,SAASE,EAAQF,EAAMG,EAAMC,GAK5B,OAJAD,EAAOA,GAAQ,GACfC,EAAOA,GAAQ,IACfJ,IAAQ,KAEOG,GAAQH,GAAQI,EAQhC,SAASC,EAAeL,GACvB,OAAOC,EAASD,IAASE,EAAQF,GAGlC,SAASM,EAAaN,GACrB,OAAgB,KAATA,GACM,IAATA,GACS,MAATA,EAQL,SAASO,EAAQP,GAChB,OAAOM,EAAaN,IACP,KAATA,GACS,KAATA,EAGLpB,IAAM4B,GACLxB,OAAQ,GACRC,QAAQ,GAYT,SAASwB,EAAQtB,EAAQuB,EAAMC,EAAOvB,GACrCA,EAAUA,EAAUC,OAAOC,UAAWkB,EAAkBpB,GAAWoB,EACnE5B,IAAMW,EAAQJ,EAAOK,IAErB,GAAIL,EAAOQ,IAAIe,GAAO,CAGrB,IAFAE,IAAeC,EAAXC,EAAQ,GAEJ3B,EAAOU,OACd,IAAIX,EAAUC,EAAQC,GAKtB,IADAyB,EAAK1B,EAAOW,UACDY,EACVI,SACM,GAAID,IAAOF,GAEjB,MADAG,EAGC,OADA3B,EAAOI,MAAQA,GACR,OAEEsB,IAAOzB,EAAQJ,QACzBG,EAAOW,OAOT,GAFAX,EAAOK,IAAMD,EAETH,EAAQH,OACX,MAAME,EAAOY,0CAA0CgB,OAAOC,aAAaN,IAI7E,OAAO,EC/IR,IAAMO,EACL,SAAYC,EAAMC,EAAO/B,GACzBgC,KAAMF,KAAOA,EACbE,KAAMD,MAAiB,MAATA,EAAgBA,EAAQ,KACtCC,KAAMhC,QAAUA,OAOjB6B,YAACI,iBACA,OAAQ,IAAIJ,EAAUG,KAAKF,KAAME,KAAKD,MAAO9B,OAAOC,UAAW8B,KAAKhC,WAMrE6B,YAACK,mBACA,OAAWF,eAAcA,gBAO1B,IAAMG,EAML,SAAYL,EAAMM,cAElBJ,KAAMF,KAAOA,GAAQ,KACrBE,KAAMD,MAAQ,KACdC,KAAMK,OAAS,KACfL,KAAMM,aAAc,EAEpBN,KAAMO,YAGNP,KAAMQ,OAAS,KAGfR,KAAMtB,KAAO,KAGbsB,KAAMS,SAAW,KAEjBT,KAAMU,eAEDC,MAAMC,QAAQR,IAClBA,EAAYS,iBAAQC,UAAQd,EAAKe,aAAaD,gTAwYhD,SAASE,EAAgBlB,EAAMC,GAC9B,OAAID,aAAgBD,EACZC,EAGY,iBAATA,EACH,IAAID,EAAUC,EAAMC,GAGxBD,GAAwB,iBAATA,EACX,IAAID,EAAUC,EAAKA,KAAMA,EAAKC,MAAOD,EAAK9B,cADlD,EASD,SAASiD,EAAUC,GAClB,OAAOvB,OAAOuB,GAAKC,OAGpB,SAASC,EAAYC,EAAMC,EAAGC,GAC7B,OAAOF,GAAQE,EAAIC,QAAQH,KAAUC,EAvZtCG,EAAKrB,0BACJ,OAAQJ,KAAKU,aAOde,EAAKC,6BACJ,OAAQ1B,KAAKI,WAAWuB,gBAAQC,EAAKd,GAEpC,OADAc,EAAKd,EAAKhB,MAAQgB,EAAK9C,QAAQ6D,QAAUf,EAAKhB,KAAOgB,EAAKf,MAClD6B,QASVH,EAAKK,uBACJ,OAAS9B,KAAKF,OAASE,KAAKD,QAAUC,KAAKU,YAAYqB,QAOxDN,EAAKO,0BACJ,OAAShC,KAAKF,QAAUE,KAAKD,QAAUC,KAAKU,YAAYqB,QAOzDN,EAAKQ,0BACJ,OAAQjC,KAAKO,SAAS,IAOvBkB,EAAKS,yBACJ,OAAQlC,KAAKO,SAASP,KAAKO,SAASwB,OAAS,IAO9CN,EAAKU,0BACJ,OAAQnC,KAAKQ,OAASR,KAAKQ,OAAOD,SAASiB,QAAQxB,OAAS,GAO7DyB,EAAKW,2BACJ,OAAQpC,KAAKtB,MAOd+C,EAAKY,+BACJ,OAAQrC,KAAKS,UAOdgB,EAAKa,yBACJ,IAAOxB,EAAOd,KAAKuC,aAAa,SAChC,OAAQzB,GAAQA,EAAKf,MACjBe,EAAKf,MAAMyC,MAAM,QAAQC,OAAOrB,OAUrCjB,YAACuC,gBAAO5C,EAAMM,GACb,OAAQ,IAAID,EAAKL,EAAMM,IAQxBD,YAACY,sBAAajB,EAAMC,GACnB,IAAOe,EAAOE,EAAgBlB,EAAMC,GAC7B4C,EAAU3C,KAAKuC,aAAazC,GAC9B6C,EACJ3C,KAAM4C,iBAAiBD,EAAS7B,GAEhCd,KAAMU,YAAYmC,KAAK/B,IASzBX,YAAC2C,sBAAahD,GACb,QAAUE,KAAKuC,aAAazC,IAQ7BK,YAACoC,sBAAazC,GACQ,iBAATA,IACXA,EAAQA,EAAKA,MAGd,IAAM,IAAIwB,EAAI,EAAGA,EAAItB,KAAKU,YAAYqB,OAAQT,IAAK,CAClD,IAAOR,OAAYJ,YAAYY,GAC/B,GAAKR,EAAKhB,OAASA,EAClB,OAAQgB,IAYXX,YAACyC,0BAAiBG,EAAcC,EAASC,GACX,iBAAjBF,IACXA,EAAgB/C,KAAKuC,aAAaQ,IAGnC,IAAOG,EAAKlD,KAAKU,YAAYc,QAAQuB,IACxB,IAARG,GACJlD,KAAMU,YAAYyC,OAAOD,EAAI,EAAGlC,EAAgBgC,EAASC,KAQ3D9C,YAACiD,yBAAgBtC,GACK,iBAATA,IACXA,EAAQd,KAAKuC,aAAazB,IAG3B,IAAOoC,EAAKlD,KAAKU,YAAYc,QAAQV,IACxB,IAARoC,GACJlD,KAAMU,YAAYyC,OAAOD,EAAI,IAO/B/C,YAACkD,2BACArD,KAAMU,YAAYqB,OAAS,GAO5B5B,YAACmD,kBAASC,GACTA,EAAStC,EAAUsC,GAEbvD,KAAK8C,aAAa,SAEZS,IAAUvD,KAAKwD,SAASD,IACnCvD,KAAMe,aAAa,QAASf,KAAKsC,UAAUmB,OAAOF,GAAOG,KAAK,MAF9D1D,KAAMe,aAAa,QAASwC,IAW9BpD,YAACqD,kBAASD,GACT,OAAsD,IAA9CvD,KAAKsC,UAAUd,QAAQP,EAAUsC,KAO1CpD,YAACwD,qBAAYJ,GACZA,EAAStC,EAAUsC,GACdvD,KAAKwD,SAASD,IAClBvD,KAAMe,aAAa,QAASf,KAAKsC,UAAUG,gBAAO3C,UAAQA,IAASyD,IAAOG,KAAK,OAQjFvD,YAACyD,qBAAYC,GACZ7D,KAAM8D,SAASD,EAAM7D,KAAKO,SAASwB,SAQpC5B,YAAC4D,sBAAaC,EAASC,GACtBjE,KAAM8D,SAASE,EAAShE,KAAKO,SAASiB,QAAQyC,KAQ/C9D,YAAC2D,kBAASD,EAAMzF,GACf,GAAKA,EAAM,GAAKA,EAAM4B,KAAKO,SAASwB,OACnC,MAAO,IAAImC,MAAM,8DAGlB,IAAOC,EAAOnE,KAAKO,SAASnC,EAAM,GAC3BM,EAAOsB,KAAKO,SAASnC,GAE5ByF,EAAMO,SACNP,EAAMrD,OAASR,KACfA,KAAMO,SAAS4C,OAAO/E,EAAK,EAAGyF,GAEzBM,IACJN,EAAMpD,SAAW0D,EACjBA,EAAMzF,KAAOmF,GAGTnF,IACJmF,EAAMnF,KAAOA,EACbA,EAAM+B,SAAWoD,IAQnB1D,YAACkE,qBAAYR,GACZ,IAAOX,EAAKlD,KAAKO,SAASiB,QAAQqC,IACrB,IAARX,IACJlD,KAAMO,SAAS4C,OAAOD,EAAI,GACrBW,EAAKpD,WACToD,EAAMpD,SAAS/B,KAAOmF,EAAKnF,MAGvBmF,EAAKnF,OACTmF,EAAMnF,KAAK+B,SAAWoD,EAAKpD,UAG5BoD,EAAMrD,OAASqD,EAAKnF,KAAOmF,EAAKpD,SAAW,OAO7CN,YAACiE,kBACKpE,KAAKQ,QACTR,KAAMQ,OAAO6D,YAAYrE,OAS3BG,YAACF,eAAMqE,GACN,IAAOrE,EAAQ,IAAIE,EAAKH,KAAKF,MAa7B,OAZAG,EAAOF,MAAQC,KAAKD,MACpBE,EAAOK,YAAcN,KAAKM,YACrBN,KAAKK,SACTJ,EAAOI,OAASpC,OAAOC,UAAW8B,KAAKK,SAGxCL,KAAMU,YAAYG,iBAAQC,UAAQb,EAAMc,aAAaD,EAAKb,WAErDqE,GACJtE,KAAMO,SAASM,iBAAQ0D,UAAStE,EAAM2D,YAAYW,EAAMtE,OAAM,MAGvDA,GASTE,YAACqE,cAAKC,EAAIC,GACTA,EAAUA,GAAU,EAGpB,IAFA,IAAKC,EAAM3E,KAAKiC,WAER0C,GAAK,CAEZ,IAAOjG,EAAOiG,EAAIjG,KAElB,IAAyB,IAApB+F,EAAGE,EAAKD,KAAkD,IAA7BC,EAAIH,KAAKC,EAAIC,EAAS,GACvD,OAAQ,EAGTC,EAAOjG,IAQTyB,YAACyE,aAAIH,GAEJ,oBADOI,GAAQ7E,MACLsB,EAAI,EAAGA,EAAIwD,UAAU/C,OAAQT,IACtCuD,EAAMhC,KAAKiC,EAAUxD,IAItB,OADAmD,EAAIM,MAAM,KAAMF,GACR7E,MAGTG,YAAC6E,+BACOC,EAAQjF,KAAKI,WAAW8E,aAAIpE,GAElC,IAAOqE,GADPrE,EAAQd,EAAKuC,aAAazB,EAAKhB,OACb9B,QACb4D,GAASuD,GAAOA,EAAIC,QAAU,IAAM,KAAKtE,EAAKhB,MAAQ,IAM3D,OALKqF,GAAOA,EAAItD,QACfD,GAAQ,IACiB,MAAdd,EAAKf,QAChB6B,GAAQ,KAAKd,aAENc,IAGJA,EAAM,IAAG5B,KAAKF,MAAQ,IAoB3B,OAnBKmF,EAAMlD,SACVH,GAAQ,IAAIqD,EAAMvB,KAAK,UAGL,MAAd1D,KAAKD,QACT6B,GAAQ,IAAI5B,gBAGRA,KAAKM,cACTsB,GAAQ,KAGJ5B,KAAKK,SACTuB,GAAQ,KAAI5B,KAAKK,OAAOgF,MAAQrF,KAAKK,OAAOgF,MAAQ,IAC1B,MAArBrF,KAAKK,OAAON,QAChB6B,GAAQ,IAAI5B,KAAKK,OAAY,QAIvBuB,0CCzbT,IAAM0D,EACL,SAAYC,EAAQpH,EAAOqH,GACf,MAAPA,GAAiC,iBAAXD,IAC1BC,EAAOD,EAAOxD,QAGf/B,KAAMuF,OAASA,EACfvF,KAAM5B,IAAM4B,KAAK7B,MAAQA,GAAS,EAClC6B,KAAMwF,IAAMA,GAObF,YAAC7G,eACA,OAAQuB,KAAK5B,KAAO4B,KAAKwF,KAW1BF,YAACG,eAAMtH,EAAOqH,GACb,OAAQ,IAAIxF,KAAK0F,YAAY1F,KAAKuF,OAAQpH,EAAOqH,IAQlDF,YAAChH,gBACA,OAAQ0B,KAAKuF,OAAOI,WAAW3F,KAAK5B,MAQrCkH,YAAC5G,gBACA,GAAKsB,KAAK5B,IAAM4B,KAAKuF,OAAOxD,OAC3B,OAAQ/B,KAAKuF,OAAOI,WAAW3F,KAAK5B,QAYtCkH,YAAC/G,aAAIqH,GACJ,IAAOnG,EAAKO,KAAK1B,OACVuH,EAAsB,mBAAVD,EAAuBA,EAAMnG,GAAMA,IAAOmG,EAM7D,OAJKC,GACJ7F,KAAMtB,OAGCmH,GASTP,YAACQ,kBAASF,GAET,IADA,IAAOzH,EAAQ6B,KAAK5B,KACX4B,KAAKvB,OAASuB,KAAKzB,IAAIqH,KAChC,OAAQ5F,KAAK5B,MAAQD,GAQtBmH,YAACS,gBAAOC,GACPhG,KAAM5B,KAAQ4H,GAAK,GAQpBV,YAACW,mBACA,OAAQjG,KAAKkG,UAAUlG,KAAK7B,MAAO6B,KAAK5B,MASzCkH,YAACY,mBAAU/H,EAAOqH,GACjB,OAAQxF,KAAKuF,OAAOY,MAAMhI,EAAOqH,IAQlCF,YAAC3G,eAAMyH,GACN,IAAOC,EAAM,IAAInC,MAASkC,eAAmBpG,KAAK5B,IAAM,IAIxD,OAHAiI,EAAKC,gBAAkBF,EACvBC,EAAKjI,IAAM4B,KAAK5B,IAChBiI,EAAKd,OAASvF,KAAKuF,OACXc,GCvHT7I,IAAM+I,EAAW,GAQjB,SAASC,EAAczI,GACtB,GAAIA,EAAOQ,IAAIgI,GAId,OAHAxI,EAAOI,MAAQJ,EAAOK,KAGbiH,MAAOtH,EAAO+H,SAASjH,IAAad,EAAOkI,UAAY,MAIlEzI,IAAM2H,GAAQtH,QAAQ,GAStB,SAAS4I,EAAc1I,GACtB,GAAID,EAAUC,EAAQoH,GACrB,OAAOpH,EAAOkI,UAAUE,MAAM,GAAI,GAIpC3I,IAAMkJ,EAAa,IACbC,EAAW,IACXC,EAAU,GAQhB,SAASC,EAAY9I,GAGpBP,IAAMW,EAAQJ,EAAOK,IAErB,GAAIL,EAAOQ,IAAImI,GAAa,CAK3B,IAJAlH,IAAeC,EAAXC,EAAQ,EACRoH,EAAS,GACTC,EAAShJ,EAAOK,KAEZL,EAAOU,OAEd,IADAgB,EAAK1B,EAAOW,UACDgI,EACVhH,SACM,GAAID,IAAOkH,GAEjB,MADAjH,EAGC,OADA3B,EAAOI,MAAQA,EACR2I,EAAS/I,EAAOmI,UAAUa,EAAQhJ,EAAOK,IAAM,QAE7CqB,IAAOmH,KACjBnH,EAAK1B,EAAOW,UACDgI,GAAcjH,IAAOkH,IAC/BG,GAAU/I,EAAOmI,UAAUa,EAAQhJ,EAAOK,IAAM,GAAKuB,OAAOC,aAAaH,GACzEsH,EAAShJ,EAAOK,MAOnB,MADAL,EAAOK,IAAMD,EACPJ,EAAOY,gCAAgCgB,OAAOC,aAAa+G,sBAGlE,OAAO,KAGRnJ,IAAMwJ,EAAa,GACbC,EAAa,GACbC,EAAa,GACbC,EAAa,GACbC,EAAa,GAEbC,EAAkB,sBASxB,SAASC,EAAkBvJ,GAC1B,IAAKA,EAAOQ,IAAI4I,GACf,OAAO,KAMR,IAHA3J,IACI+F,EAAOzC,EADLgG,MAGE/I,EAAOU,OAAO,CAGrB,GAFAV,EAAO+H,SAAS5G,GAEZnB,EAAOQ,IAAI6I,GACd,OAAON,EACD,GAAuC,OAAlCvD,EAAQkD,EAAc1I,IAEjC+I,EAAOjE,MACN/C,KAAM,KACNC,MAAOwD,QAEF,CAAA,IAAIgE,EAAYxJ,GA4BtB,MAAMA,EAAOY,MAAM,2BA1BnB4E,EAAQxF,EAAOkI,UACVoB,EAAgBG,KAAKjE,IAKzBzC,EAAO2G,EAAmBlE,GAC1BuD,EAAOjE,KAAK/B,GAER/C,EAAOQ,IAAI2I,KAGyB,OAAlC3D,EAAQkD,EAAc1I,IAC1B+C,EAAKf,MAAQwD,EAC8B,OAAhCA,EAAQsD,EAAY9I,KAC/B+C,EAAKf,MAAQwD,EACbzC,EAAK9C,SACJ0J,OAAQ,IACRC,MAAO,MAEEJ,EAAYxJ,KACtB+C,EAAKf,MAAQhC,EAAOkI,aAlBtBa,EAAOjE,MAAO/C,KAAM,KAAMC,MAAOwD,KA2BpC,MAAMxF,EAAOY,MAAM,8BAGpB,SAAS8I,EAAmB3H,GAC3BtC,IAAMQ,KAIF8B,EAAK6F,WAAW,KAAOqB,IAC1BlH,EAAOA,EAAKqG,MAAM,GAClBnI,EAAQoH,SAAU,GAIftF,EAAK6F,WAAW7F,EAAKiC,OAAS,KAAOkF,IACxCnH,EAAOA,EAAKqG,MAAM,EAAGrG,EAAKiC,OAAS,GACnC/D,EAAQ6D,SAAU,GAGnBrE,IAAMsD,QAAShB,GAKf,OAJI7B,OAAO2J,KAAK5J,GAAS+D,SACxBjB,EAAK9C,QAAUA,GAGT8C,EAQR,SAASyG,EAAYxJ,GACpBP,IAAMW,EAAQJ,EAAOK,IACrB,GAAIL,EAAO+H,SAAS+B,GAEnB,OADA9J,EAAOI,MAAQA,GACR,EAIT,SAAS0J,EAAWjJ,GACnB,OAAQO,EAAQP,KAAUJ,EAAQI,IAC9BA,IAASuI,GAAavI,IAASwI,GAAcxI,IAASsI,EAG3D1J,IAAMsK,EAAU,GACVC,EAAY,GACZC,EAAU,GAOhB,SAASC,EAAelK,GAMvB,IAJAP,IAEIkB,EAFEP,EAAQJ,EAAOK,IACfyF,EAAO,IAAI1D,EAAK+H,EAAQnK,KAGtBA,EAAOU,OACd,GAAIV,EAAOQ,IAAIwJ,GACdlE,EAAKP,SAAS4E,EAAQnK,SAChB,GAAIA,EAAOQ,IAAIuJ,GACrBjE,EAAK9C,aAAa,KAAMmH,EAAQnK,QAC1B,CAAA,GAAIA,EAAOQ,IAAIyJ,GAAQ,CAE7B,GAAInE,EAAK/B,QAER,MADA/D,EAAOgI,OAAO,GACRhI,EAAOY,MAAM,qCAEpBkF,EAAKvD,aAAc,GACf5B,EAAO8H,EAAczI,MACxB8F,EAAKxD,OAAS3B,GAEf,MACM,GAAIA,EAAO4I,EAAkBvJ,GACnC,IAAKyB,IAAI8B,EAAI,EAAG6G,EAAKzJ,EAAKqD,OAAQT,EAAI6G,EAAI7G,IACzCuC,EAAK9C,aAAarC,EAAK4C,SAElB,GAAqC,QAAhC5C,EAAOmI,EAAY9I,IAC9B8F,EAAK9D,MAAQrB,MACP,CAAA,KAAIA,EAAO8H,EAAczI,IAG/B,MAFA8F,EAAKxD,OAAS3B,GAMhB,GAAIP,IAAUJ,EAAOK,IACpB,MAAML,EAAOY,yDAAyDZ,EAAOO,QAG9E,OAAOuF,EAGR,SAASqE,EAAQnK,GAGhB,OAFAA,EAAOI,MAAQJ,EAAOK,IACtBL,EAAO+H,SAASsC,GACTrK,EAAOkI,UAGf,SAASmC,EAAOxJ,GACf,OAAOK,EAAeL,IACT,KAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,EAGLpB,IAAM6K,EAAc,GACdC,EAAc,GACdC,EAAc,GACdC,EAAc,GACdC,EAAc,GAwFpB,SAASC,EAAMC,GACdnL,IAAMoL,EAlFP,SAAe1H,GAKd,IAJA1D,IAEiCiC,EAF3B1B,EAAS,IAAIuH,EAAapE,EAAIC,QAC9B0H,EAAO,IAAI1I,EACbwE,EAAMkE,EAAMC,MAER/K,EAAOU,OAGd,IAFAgB,EAAK1B,EAAOO,UAED+J,EAQJ,GAAI5I,IAAO6I,EAAX,CAyBP9K,IAAMqG,EAAOoE,EAAelK,GAG5B,GAFA4G,EAAIf,YAAYC,GAEZ9F,EAAOU,MACV,MAGD,OAAQV,EAAOO,QACd,KAAKiK,EACJxK,EAAOW,OACP,SAED,KAAK8J,EACJzK,EAAOW,OACPiG,EAAMd,EACN,SAED,KAAK4E,EAEJ,KAAO1K,EAAOQ,IAAIkK,IACjB9D,EAAMA,EAAInE,QAAUmE,EAErB,cA/CK,CACNnH,IAAMuL,EAAYD,EAAWE,MAC7B,IAAKD,EACJ,MAAMhL,EAAOY,MAAM,4BAGpBnB,IAAMqG,EAAOkF,EAAU,GAKvB,GAJApE,EAAMoE,EAAU,GAChBhL,EAAOW,OAGHmF,EAAKxD,OAASmG,EAAczI,GAC/B4G,EAAIf,YAAYC,QAGhB,KAAOA,EAAK5B,YACX0C,EAAIf,YAAYC,EAAK5B,YAIvBlE,EAAOQ,IAAIgK,OA5BZ,CAGC/K,IAAMqG,EAAO,IAAI1D,EACjB2I,EAAWjG,MAAMgB,EAAMc,EAAK5G,EAAOK,MACnCuG,EAAMd,EACN9F,EAAOW,OAqDT,GAAIoK,EAAW/G,OAEd,MADAhE,EAAOK,IAAM0K,EAAWE,MAAM,GACxBjL,EAAOY,MAAM,wBAGpB,OAAOkK,EAUMI,CAAMN,GAEnB,OADAC,EAAKpE,KAAK0E,GACHN,EAGR,SAASM,EAAOrF,GACf,GAAKA,EAAKxD,QAAWwD,EAAKxD,OAAOgF,MAAjC,CAOA,IAHA7H,IAAMgD,EAASqD,EAAKrD,OAChB0C,EAAK1C,EAAOD,SAASiB,QAAQqC,GAExBvC,EAAI,EAAGA,EAAIuC,EAAKxD,OAAOgF,MAAO/D,IAAK,CAC3C9D,IAAMyC,EAAQ4D,EAAK5D,OAAM,GAIzB,GAHAA,EAAMI,OAAON,MAAQuB,EAAI,EACzBrB,EAAMuE,KAAK0E,GAEPjJ,EAAM6B,QACT,KAAO7B,EAAMM,SAASwB,OAAS,GAC9B9B,EAAMgC,WAAW5B,OAASJ,EAAMI,OAChCG,EAAOsD,SAAS7D,EAAMgC,WAAYiB,UAGnC1C,EAAOsD,SAAS7D,EAAOiD,KAIzBW,EAAKrD,OAAO6D,YAAYR,IC9WzB,IAAI6E,EAAQ,SAASE,EAAMO,GAEvB,OADAP,EAAKpE,cAAKX,UAId,SAAqBA,EAAMsF,GACvB3L,IAAMkC,EAAQ,IAAI0J,IACZC,WAAUxF,GACZrG,IAAM8L,EAAUH,EAASE,QAAQxF,EAAK/D,MAKtC,GAAKwJ,IAAW5J,EAAM6J,IAAID,GAA1B,CAKA,GAA6B,mBAAlBA,EAAQvJ,MACf,OAAOuJ,EAAQvJ,MAAM8D,EAAMsF,EAAUE,GAGzC7L,IAAMoL,EAAOK,EAAMK,EAAQvJ,OAE3BL,EAAM8J,IAAIF,GACVV,EAAKpE,KAAK6E,GACV3J,EAAM+J,OAAOH,GAGb9L,IAAMkM,EAyGd,SAAyB7F,GACxB,KAAOA,EAAKtD,SAASwB,QACpB8B,EAAOA,EAAKtD,SAASsD,EAAKtD,SAASwB,OAAS,GAG7C,OAAO8B,EA9GoB8F,CAAgBf,GAGpC,KAiBR,SAAe7J,EAAMC,GACjBA,EAAGc,KAAOf,EAAKe,KAEXf,EAAKuB,cACLtB,EAAGsB,aAAc,GAGH,MAAdvB,EAAKgB,QACLf,EAAGe,MAAQhB,EAAKgB,OAGhBhB,EAAKsB,SACLrB,EAAGqB,OAASpC,OAAOC,UAAWa,EAAKsB,UAa3C,SAAyBtB,EAAMC,IA8C/B,SAAyBD,EAAMC,GAE3B,IADAxB,IAAMoM,EAAa7K,EAAKuD,UACfhB,EAAI,EAAGA,EAAIsI,EAAW7H,OAAQT,IACnCtC,EAAGsE,SAASsG,EAAWtI,IAhD3BuI,CAAgB9K,EAAMC,GAQtB,IAHAxB,IAAMsM,EAAU,IAAIC,IAEhB9E,EAAQlG,EAAKqB,WACRkB,EAAI,EAAGA,EAAI2D,EAAMlD,OAAQT,IAC9BwI,EAAQE,IAAI/E,EAAM3D,GAAGxB,KAAMmF,EAAM3D,GAAGrB,SAGxCgF,EAAQjG,EAAGoB,WAAW+F,QACtB,IAAK3G,IAAI8B,EAAI,EAAGR,SAAMmJ,SAAG3I,EAAI2D,EAAMlD,OAAQT,IACvCR,EAAOmE,EAAM3D,GACTwI,EAAQP,IAAIzI,EAAKhB,QACjBmK,EAAIH,EAAQI,IAAIpJ,EAAKhB,OACnBC,MAAQe,EAAKf,MAIXkK,EAAEjM,QAAQoH,UACV6E,EAAEjM,QAAQoH,SAAU,IAGxB0E,EAAQE,IAAIlJ,EAAKhB,KAAMgB,GAG3B9B,EAAGoE,gBAAgBtC,GAIvB,IADAtD,IAAM2M,EAAWxJ,MAAM5B,KAAK+K,EAAQM,UAC3B9I,EAAI,EAAGA,EAAI6I,EAASpI,OAAQT,IACjCtC,EAAG+B,aAAaoJ,EAAS7I,KA5CtB+I,CAAgBtL,EAAMC,GAlCzBsL,CAAMZ,EAAa7F,GAEZ+E,EAAK3G,YACR4B,EAAKrD,OAAOuD,aAAa6E,EAAK3G,WAAY4B,GAG9C6F,EAAYlJ,OAAOuD,aAAaF,EAAM6F,GACtCA,EAAYtF,WAGhBiF,EAAQxF,GAvCU0G,CAAY1G,EAAMsF,KAC7BP,GCnBXpL,IAAMgN,EAAiB,IAAIpB,IAAI,8LAA8L5G,MAAM,MAC7NiI,GACFC,EAAG,OACHC,GAAI,KACJC,GAAI,KACJC,MAAO,KACPC,GAAI,KACJC,MAAO,KACPC,MAAO,KACPC,MAAO,KACPC,SAAU,MACVC,OAAQ,SACRC,SAAU,SACVC,MAAO,SACPC,MAAO,SACPC,OAAQ,QACRrG,IAAK,QAQT,SAASsG,EAAoBC,GAEzB,OADAA,GAAcA,GAAc,IAAIC,cACzBjB,EAAWgB,KACVjB,EAAejB,IAAIkC,GAAc,OAAS,OCtBtD,IAAIE,GAAe,SAAS/C,GAOxB,OANAA,EAAKpE,cAAKX,GAEW,MAAbA,EAAK/D,MAAgB+D,EAAKzD,WAAW2B,SACrC8B,EAAK/D,KAAO8L,EAAmB/H,EAAKrD,OAAOV,SAG5C8I,GASX,SAASiD,GAAoB3K,EAAKqC,GAM9B,IALA/F,IAAMsJ,EAAS,IAAIsC,IACb0C,EAAOvI,EAAMxB,OAGf3D,EAAM,GACkC,KAApCA,EAAM8C,EAAIM,QAAQ+B,EAAOnF,KAC7B0I,EAAO0C,IAAIpL,GACXA,GAAO0N,EAGX,GAAIhF,EAAOiF,KAKP,IAHAvM,IAAIpB,EAAM,EACJ4N,EAAM9K,EAAIa,OAET3D,EAAM4N,GACU,OAAf9K,EAAI9C,MACJ0I,EAAO2C,OAAOrL,KAK1B,OAAOuC,MAAM5B,KAAK+H,GAAQ5B,aAAIhC,UAAYA,EAAI4I,KAWlD,SAASG,GAAc/K,EAAKgL,EAAQnM,GAEnC,IAAKP,IAAI8B,EAAI4K,EAAOnK,OAAS,EAAGT,GAAK,EAAGA,IAAK,CAC5C9D,IAAM2O,EAAID,EAAO5K,GAEPyF,EAAS,EACTqF,EAAe,EACfC,GAAkB,EAEtB,GAAmC,MAA/BnL,EAAIoL,OAAOH,EAAE,GAAKA,EAAE,GAAI,GAAW,CACI,MAAnCjL,EAAIoL,OAAOH,EAAE,GAAKA,EAAE,GAAK,EAAG,KAC5BE,GAAkB,GAEtB7O,IAAM+O,EAAUrL,EAAIoL,OAAOH,EAAE,GAAKA,EAAE,GAAK,EAAIK,OAAOH,IAAkBzG,MAAM,UACxE2G,GACAH,EAAeG,EAAQ,GAAGxK,OAAS,EAAIyK,OAAOH,GAC9CtF,EAAS0F,SAASF,EAAQ,IAAM,GAEhCH,EAAe,EAI7BlL,EAAMA,EAAIgF,UAAU,EAAGiG,EAAE,KACJ,mBAAVpM,EAAuBA,EAAMmB,EAAIoL,OAAOH,EAAE,GAAIA,EAAE,IAAKpF,EAAQsF,GAAmBtM,GACxFmB,EAAIgF,UAAUiG,EAAE,GAAKA,EAAE,GAAKC,GAGhC,OAAOlL,EAOR1D,IAAMkP,GAAiB,IAMnBC,GAAiB,SAAS/D,GAE1B,OADAA,EAAKpE,KAAKoI,IACHhE,GASX,SAASgE,GAAiB/I,GACtBrG,IAAMqP,EA2BV,SAAsBhJ,GAClB,KAAOA,GAAM,CACT,GAAIA,EAAKxD,OACL,OAAOwD,EAAKxD,OAGhBwD,EAAOA,EAAKrD,QAjCCsM,CAAajJ,GAE9B,GAAIgJ,GAA8B,MAAlBA,EAAS9M,MAAe,CAIpCvC,IAAMuC,EAAQ8M,EAAS9M,MACjBsF,EAAQwH,EAASxH,MAEvBxB,EAAK/D,KAAOiN,GAAiBlJ,EAAK/D,KAAMC,EAAOsF,GAC/CxB,EAAK9D,MAAQgN,GAAiBlJ,EAAK9D,MAAOA,EAAOsF,GACjDxB,EAAKzD,WAAWS,iBAAQC,GACpBtD,IAAMwP,EAAOnJ,EAAKtB,aAAazB,EAAKhB,MAAMG,QAC1C+M,EAAKlN,KAAOiN,GAAiBjM,EAAKhB,KAAMC,EAAOsF,GAC/C2H,EAAKjN,MAAQgN,GAAiBjM,EAAKf,MAAOA,EAAOsF,GACjDxB,EAAKjB,iBAAiB9B,EAAKhB,KAAMkN,KAIzC,OAAOnJ,EAwBX,SAASkJ,GAAiB7L,EAAKnB,EAAOsF,GAGlC,MAAmB,iBAARnE,EAqCf,SAAgCA,EAAKgL,EAAQnM,EAAOsF,GAWhD,OAQJ,SAAwBnE,GACpB1B,IAAI8B,EAAI,EAAGwF,EAAS,GACdkF,EAAM9K,EAAIa,OAEhB,KAAOT,EAAI0K,GAAK,CACZxO,IAAMiC,EAAKyB,EAAII,KACfwF,GAAkB,OAAPrH,EAAgByB,EAAII,MAAQ,GAAM7B,EAGjD,OAAOqH,EAjBAmG,CAVUhB,GAAc/K,EAAKgL,WAAS3I,EAAOwD,EAAQsF,GAGxD,IAFJ7M,IAAI0N,EAASb,EAAkB1M,OAAOoH,EAAS1B,EAAQtF,EAAQ,GAAKJ,OAAOI,EAAQgH,GAExEmG,EAAOnL,OAASwB,EAAMxB,QACzBmL,EAAS,IAAMA,EAEnB,OAAOA,KA1CAC,CAAuBjM,EAYtC,SAA4BA,GACxB,OAAO2K,GAAoB3K,GAAO,GAAIwL,IACrC/K,gBAAQC,EAAKwL,GAEV,IAAK,OAAO5F,KAAKtG,EAAIkM,EAAS,GAAK,IAAM,IAAK,CAC1C5P,IAAM6P,EAAYzL,EAAIA,EAAIG,OAAS,GAC/BsL,GAAaA,EAAU,GAAKA,EAAU,KAAOD,EAAS,GACtDC,EAAU,IAAMD,EAAS,GAEzBxL,EAAIiB,KAAKuK,GAIjB,OAAOxL,OA1BQ0L,CAAmBpM,GACSnB,EAAOsF,GAG/CnE,EAgEX1D,IAAM+P,GAAc,KAGdC,GAAQ,IAERC,GAAQ,8EACRC,GAAU,kDACVC,GAAU,mBAqBhB,SAASC,GAAQhF,EAAMiF,GAiBnB,OAhBAA,EAASA,GAAU,EACnBjF,EAAKpE,cAAKX,GACN,GAAIA,EAAKxD,QAAgC,OAAtBwD,EAAKxD,OAAOgF,MAAgB,CAC3C,IAAK7F,IAAI8B,EAAI,EAAGA,EAAIuM,EAAQvM,IAAK,CAC7B9D,IAAMyC,EAAQ4D,EAAK5D,OAAM,GACzBA,EAAMI,OAAOyN,UAAW,EACxB7N,EAAMI,OAAOgF,MAAQwI,EACrB5N,EAAMI,OAAON,MAAQuB,EAAI,EACzBrB,EAAMI,OAAOqI,MAAQpH,EACrBuC,EAAKrD,OAAOuD,aAAa9D,EAAO4D,GAGpCA,EAAKO,YAINwE,EASX,SAASmF,GAAOnF,EAAMoF,GAClB,GAAIrN,MAAMC,QAAQoN,IAAYA,EAAQjM,OAAQ,CAC1CvC,IAAIyO,GAAU,EACdrF,EAAKpE,cAAKX,GACFA,EAAKxD,QAAUwD,EAAKxD,OAAOyN,WAC3BG,GAAU,EAsB1B,SAAuBpK,EAAMmK,GAC5BxO,IAAI0O,EAAWC,GAA6BtK,EAAMmK,GAClDnK,EAAKW,cAAKD,UAAS2J,GAAYC,GAA6B5J,EAAOyJ,KAE9DE,GAEJE,GAAezE,GAAgB9F,GAAOmK,GA3BxBK,CAAcxK,EAAMmK,EAAQnK,EAAKxD,OAAOqI,WAI3CuF,GAGDG,GAAezE,GAAgBf,GAAOoF,EAAQtK,KAAK,OAI3D,OAAOkF,EA6BX,SAASuF,GAA6BtK,EAAMmK,GAC3CxQ,IAAM8Q,GAASC,UAAU,GASzB,OAPA1K,EAAK9D,MAAQyO,GAAmB3K,EAAK9D,MAAOiO,EAASM,GACrDzK,EAAKzD,WAAWS,iBAAQC,GACnBA,EAAKf,OACR8D,EAAK9C,aAAaD,EAAKhB,KAAM0O,GAAmB1N,EAAKf,MAAOiO,EAASM,MAIhEA,EAAMC,SAWd,SAASC,GAAmBtN,EAAKnB,EAAO0O,GACvC,GAAmB,iBAARvN,EAAkB,CAC5B1D,IAAM0O,EAASL,GAAoB3K,EAAKqM,IACpCrB,EAAOnK,SACN0M,IACHA,EAAOF,UAAW,GAGnBrN,EAAM+K,GAAc/K,EAAKgL,EAAQnM,IAInC,OAAOmB,EAQR,SAASyI,GAAgB9F,GACxB,KAAOA,EAAKtD,SAASwB,QACpB8B,EAAOA,EAAKtD,SAASsD,EAAKtD,SAASwB,OAAS,GAG7C,OAAO8B,EAQR,SAASuK,GAAevK,EAAMmK,GAE7B,GAAInK,EAAK9D,MAAO,CACfvC,IAAM0O,EAASL,GAAoBhI,EAAK9D,MAAOyN,IAC/C,GAAItB,EAAOnK,OAEV,YADA8B,EAAK9D,MAAQkM,GAAcpI,EAAK9D,MAAOmM,EAAQ8B,KAKjB,MAA5BnK,EAAK/D,KAAK4L,eAAyB7H,EAAKf,aAAa,WAEpD2K,GAAMjG,KAAKwG,GACdnK,EAAK9C,aAAa,QAAS4M,GAAQnG,KAAKwG,GAAW,GAAK,WAAaA,GAC3DN,GAAQlG,KAAKwG,IACvBnK,EAAK9C,aAAa,OAAQ,UAAYiN,IAIxCnK,EAAK9D,MAAQiO,EAGdxQ,IAAMG,IACL+Q,QAAS,KACTC,SAAU,KAGLC,GAAa,8BACbC,GAAa,+BACbC,YAAmBC,SAAa,YAAYvH,KAAKuH,IACjDC,YAAmBD,SAAa,UAAUvH,KAAKuH,IAyHrD,SAASE,GAAapL,EAAMqL,EAAQC,GAKnC,IAJA3P,IAAI4P,EAAQD,EAAOpN,OAAS,EAAIoN,EAAOpN,OAAS,EAIzC8B,EAAKrD,QAAUqD,EAAKrD,OAAOA,QAAU4O,KAC3CvL,EAAOA,EAAKrD,OAGb,OAAO0O,EAAOhF,IAAIrG,IAAS,GAG5B,SAASwL,GAAK9N,EAAKkB,GAClB,IAAIjD,IAAI8B,EAAI,EAAGA,EAAIC,EAAIQ,UAClB6M,GAAUpH,KAAKjG,EAAID,MAAOuN,GAAWrH,KAAKjG,EAAID,KADpBA,IAI9B,GAAImB,EAAOlB,EAAID,IACd,OAAOC,EAAID,GAiBd,SAASgO,GAAQzL,EAAM0L,EAASvM,GAC/BxD,IAAIsB,EAAO+C,EAAKtB,aAAagN,GACzBzO,IACHA,EAAKhB,KAAOkD,GAIdxF,IAAMgS,GAAmB,gCAenBC,QA1KI,SAAS7G,EAAM5K,GACxBA,EAAUC,OAAOC,UAAWP,GAAgBK,GAE5C4K,EAAKpE,cAAKX,UAgBX,SAA0BA,EAAM7F,GAC/BR,IAAMoM,EAAa/F,EAAKvB,UAAUX,gBAAQC,EAAK8N,GAE9ClS,IAAM0F,EAAKwM,EAAGlO,QAAQ,KACtB,OAAI0B,EAAK,IAAMwM,EAAGC,WAAW,MAC5B/N,EAAI4H,IAAIkG,EAAGvJ,MAAM,EAAGjD,IACjBtB,EAAI4H,IAAIkG,EAAGvJ,MAAMjD,IACbtB,GAGDA,EAAI4H,IAAIkG,IACb,IAAItG,KAEHQ,EAAWmC,MACdlI,EAAK9C,aAAa,QAASJ,MAAM5B,KAAK6K,GAAYlG,KAAK,MA9BtCkM,CAAiB/L,KAEnCrG,IAAM0R,EAkFP,SAA2BtG,GAC1BpL,IAAM0R,EAAS,IAAInF,IAcnB,OAZAnB,EAAKpE,cAAKX,GACTrG,IAAMoM,EAAa/F,EAAKvB,UACpBsH,EAAW7H,QAEdmN,EAAOlF,IAAInG,EACVwL,GAAKzF,EAAYkF,KACdO,GAAKzF,EAAYoF,KACjBE,EAAOhF,IAAIrG,EAAKrD,WAKf0O,EAjGQW,CAAkBjH,GAGjC,OAFAA,EAAKpE,cAAKX,UAqCX,SAA6BA,EAAMqL,EAAQlR,GAC1CR,IAAMoM,EAAa/F,EAAKvB,UAAUX,gBAAQC,EAAK8N,GAC9ClQ,IAAI2P,EAAQW,EACNC,EAAgBL,EA0BtB,OAvBII,EAAIJ,EAAG9J,MAAMgJ,OAChBO,EAASF,GAAapL,EAAMqL,EAAQY,EAAE,IAAM9R,EAAQ0Q,QAAUoB,EAAE,GAChElO,EAAI4H,IAAI2F,GACRO,EAAKA,EAAGvJ,MAAM2J,EAAE,GAAG/N,UAIhB+N,EAAIJ,EAAG9J,MAAMiJ,OACXM,IACJA,EAASF,GAAapL,EAAMqL,EAAQY,EAAE,IACtClO,EAAI4H,IAAI2F,IAGTvN,EAAI4H,OAAO2F,EAASnR,EAAgB,SAAG8R,EAAE,IACzCJ,EAAKA,EAAGvJ,MAAM2J,EAAE,GAAG/N,SAGhB2N,IAAOK,GAGVnO,EAAI4H,IAAIuG,GAGFnO,GACL,IAAIwH,KAED4G,EAAgBrP,MAAM5B,KAAK6K,GAAYnH,OAAOwN,SAChDD,EAAcjO,QACjB8B,EAAK9C,aAAa,QAASiP,EAActM,KAAK,MAvE7BwM,CAAoBrM,EAAMqL,EAAQlR,KAE7C4K,OAoIE,SAASA,GAKlB,OAJAA,EAAKpE,cAAKX,GACTyL,GAAQzL,EAAM,QAAS,aACvByL,GAAQzL,EAAM,MAAO,aAEf+E,OAgBE,SAASA,GAMlB,OALAA,EAAKpE,cAAKX,GACL2L,GAAiBhI,KAAK3D,EAAK/D,MAAQ,MAAQ+D,EAAKtD,SAASwB,QAAU8B,EAAK9D,QAC3E8D,EAAKT,gBAAgB,YAGhBwF,IAaJuH,GAAS,SAASvH,EAAMuH,GAQxB,OAPAlS,OAAO2J,KAAKuI,OAActP,iBAAQuP,GAC9B,GAAIA,KAAOX,GAAiB,CACxBjS,IAAM6S,EAAkC,iBAAhBF,EAAOC,GAAoBD,EAAOC,GAAO,KACjExH,EAAOA,EAAKhE,IAAI6K,GAAgBW,GAAMC,MAIvCzH,GASPF,GAAQ,SAASE,EAAMoF,EAASsC,GAQhC,MAPuB,iBAAZtC,EACPA,GAAWA,GACJA,GAA8B,iBAAZA,IAAyBrN,MAAMC,QAAQoN,KAChEsC,EAAgBtC,EAChBA,EAAU,MAGPpF,EACNhE,IAAI+G,IACJ/G,IAAIgJ,GAASjN,MAAMC,QAAQoN,GAAWA,EAAQjM,OAAS,MACvD6C,IAAI+H,IACJ/H,IAAImJ,GAAQC,GACZpJ,IAAIuL,GAAQG,ICxmBjB,SAASC,GAAiB3H,EAAM4H,GAG5B,OAFHA,EAAYA,MACT5H,EAAKpE,cAAKX,UAId,SAAuBA,EAAM2M,GAIzB,IAFAhT,IAAMyH,EAAQpB,EAAKzD,WAEVkB,EAAI,EAAG6G,EAAKlD,EAAMlD,OAAQT,EAAI6G,EAAI7G,IAAK,CAC5C9D,IAAMsD,EAAOmE,EAAM3D,GACO,iBAAfR,EAAKf,OACZ8D,EAAK9C,aAAaD,EAAKhB,KAAM2Q,GAAgB3P,EAAKf,MAAOyQ,IAI/C,MAAd3M,EAAK9D,QACL8D,EAAK9D,MAAQ0Q,GAAgB5M,EAAK9D,MAAOyQ,IAG7C,OAAO3M,EAnBW6M,CAAc7M,EAAM2M,KAC/B5H,EA4BX,SAAS6H,GAAgBlL,EAAQiL,GAK7B,IAJAhT,IAAMmT,EAyBV,SAAqBpL,GACjB/H,IASIsS,EATEc,EAAa,yBAEbJ,KAMAK,EAAS,IAAI9G,IAEnB,KAAO+F,EAAIc,EAAWE,KAAKvL,IACvBsL,EAAO7G,IAAI8F,EAAEpH,MAAOoH,GAGxB,GAAIe,EAAO9E,KAAM,CAGb,IAFAvM,IAAIrB,EAAQ,EAAGC,EAAM,EAAG4N,EAAMzG,EAAOxD,OACjCgP,EAAS,GACN3S,EAAM4N,GACT,GAjBe,KAiBXzG,EAAOI,WAAWvH,IAA2ByS,EAAOtH,IAAInL,EAAM,GAAlE,CAGIZ,IAAM+F,EAAQsN,EAAO3G,IAAI9L,EAAM,GAC/B2S,GAAUxL,EAAOY,MAAMhI,EAAOC,GAAOmF,EAAM,GAC3CpF,EAAQC,EAAMmF,EAAMmF,MAAQnF,EAAM,GAAGxB,OACrC8O,EAAOpH,OAAOrL,EAAM,QAIxBA,IAGJmH,EAASwL,EAASxL,EAAOY,MAAMhI,GAI/B,IADAX,IAAMwT,EAAerQ,MAAM5B,KAAK8R,EAAOzG,UAC9B9I,EAAI,EAAG6G,EAAK6I,EAAajP,OAAQT,EAAI6G,EAAI7G,IAAK,CACnD9D,IAAM+F,EAAQyN,EAAa1P,GAC3BkP,EAAU3N,MACN/C,KAAMyD,EAAM,GACZ0N,SAAU1N,EAAMmF,MAChB3G,OAAQwB,EAAM,GAAGxB,UAK7B,cAAQwD,YAAQiL,GAvEFU,CAAY3L,GACtBwB,EAAS,EACTgK,EAAS,GAEJzP,EAAI,EAAG6G,EAAKwI,EAAMH,UAAUzO,OAAQT,EAAI6G,EAAI7G,IAAK,CACtD9D,IAAM2T,EAAIR,EAAMH,UAAUlP,GACtBvB,EAAQoR,EAAErR,QAAQ0Q,EAAYA,EAAUW,EAAErR,MAAQqR,EAAErR,KACnC,mBAAVC,IACPA,EAAQA,EAAM4Q,EAAMpL,OAAQ4L,EAAGpK,EAASoK,EAAEF,WAG9CF,GAAUJ,EAAMpL,OAAOY,MAAMY,EAAQoK,EAAEF,UAAYlR,EACnDgH,EAASoK,EAAEF,SAAWE,EAAEpP,OAG5B,OAAOgP,EAASJ,EAAMpL,OAAOY,MAAMY,GCpDvCvJ,IAAM4T,GAAc,GACdC,GAAc,GACdzK,GAAc,GACd0K,GAAc,IACdC,GAAc,IAQpB,SAAStI,GAAM1D,GAMd,IALA/H,IAGIoB,EAAM4S,EAHJzT,EAAS,IAAIuH,EAAaC,GAC1BkM,KACFC,EAAc,GAAI3K,EAAS,EAAG3I,EAAM,GAGhCL,EAAOU,OACdG,EAAOb,EAAOO,OACdF,EAAML,EAAOK,IAETQ,IAASgI,IACZ7I,EAAOW,OACPX,EAAOW,SACG8S,EAAQG,GAAa5T,EAAQ2T,EAAY3P,OAAS3D,EAAM2I,KAClE0K,EAAO5O,KAAK2O,GACZE,GAAe3T,EAAOwH,OAAOY,MAAMY,EAAQ3I,GAAOoT,EAAMjE,YACxDxG,EAAShJ,EAAOK,KAEhBL,EAAOW,OAIT,OAAO,IAAIkT,GAAYF,EAAc3T,EAAOwH,OAAOY,MAAMY,GAAS0K,GA2CnE,SAASI,GAAYnJ,EAAO6E,GAC3B,OAAOA,OAAoB7E,MAAS6E,WAAuB7E,MAW5D,SAASiJ,GAAa5T,EAAQkT,GAC7BzT,IAAMW,EAAQJ,EAAOK,IAErB,GAAIL,EAAOQ,IAAI6S,IAAS,CAEvB5R,IAAIkJ,EAAQoJ,GAAa/T,GACrBwP,EAAc,GAGlB,GAAa,MAAT7E,EACH,OAAO,IAAIqJ,GAAMrJ,EAAO6E,EAAa0D,GAGtC,GAAIlT,EAAOQ,IAAI+S,KAED,OADb5I,EAAQoJ,GAAa/T,MAEhBA,EAAOQ,IAAI8S,MACd9D,EAoBL,SAA4BxP,GAC3ByB,IAAIZ,EACEc,KACN3B,EAAOI,MAAQJ,EAAOK,IAEtB,MAAQL,EAAOU,OAAO,CAGrB,IAFAG,EAAOb,EAAOO,UAEDgT,GACZ5R,EAAMmD,KAAK9E,EAAOK,UACZ,GAAIQ,IAAS2S,GAAa,CAChC,IAAK7R,EAAMqC,OACV,MAEDrC,EAAMsJ,MAEPjL,EAAOW,OAGR,GAAIgB,EAAMqC,OACT,MAAMhE,EAAOY,MAAM,kDAAoDe,EAAMsJ,OAG9E,OAAOjL,EAAOkI,UA3CI+L,CAAmBjU,IAG9BA,EAAOQ,IAAIgT,KACd,OAAO,IAAIQ,GAAMrJ,EAAO6E,EAAa0D,GAQzClT,EAAOK,IAAMD,EAuCd,SAAS2T,GAAa/T,GAErB,GADAA,EAAOI,MAAQJ,EAAOK,IAClBL,EAAO+H,SAASjH,GACnB,OAAO2N,OAAOzO,EAAOkI,WAIvB,IAAM8L,GACL,SAAYrJ,EAAO6E,EAAa0D,GAChCjR,KAAM0I,MAAQA,EACd1I,KAAMuN,YAAcA,EACpBvN,KAAMiR,SAAWA,EACjBjR,KAAM+B,OAAS/B,KAAKuN,YAAYxL,QAI3B6P,GAKL,SAAYrM,EAAQkM,GACpBzR,KAAMuF,OAASA,EACfvF,KAAMyR,OAASA,GAGhBG,aAACK,cAAK1O,GACL,OAtID,SAAcgC,EAAQkM,EAAQlO,GAC7BA,EAAQA,GAASsO,GAIjBrU,IAKIuJ,EAAS,EAQb,OAbgB0K,EACfvM,aAAKsM,EAAOU,gBAAYA,QAAOV,EAAOhM,IAAKgM,EAAMP,SAAWO,EAAMzP,UAClEoQ,cAAMlI,EAAGmI,UAAOnI,EAAEzE,IAAM4M,EAAE5M,KAASyE,EAAEiI,MAAQE,EAAEF,QAIzBhN,aAAI7D,GAC1B7D,IAAM+P,EAAchI,EAAO+G,OAAOjL,EAAKmQ,MAAMP,SAAU5P,EAAKmQ,MAAMzP,QAC5DoN,EAAS5J,EAAOY,MAAMY,EAAQ1F,EAAKmQ,MAAMP,UAE/C,OADAlK,EAAS1F,EAAKmE,IACP2J,EAAS5L,EAAMlC,EAAKmQ,MAAM9I,MAAO6E,KAG3B7J,KAAK,IAAM6B,EAAOY,MAAMY,GAoH9BkL,CAAKjS,KAAKuF,OAAQvF,KAAKyR,OAAQlO,IAGxCqO,aAAC5M,oBACA,OAAQhF,KAAKuF,QC7Ld/H,IAAM6U,YAAwBC,UAAQA,GAYhCC,GACL,SAAY1O,EAAM2O,EAAgBxU,GACH,iBAAnBwU,IACXxU,EAAWwU,EACXA,EAAkB,MAGnBxS,KAAM6D,KAAOA,EACb7D,KAAMyS,gBAAkBD,GAAkBH,GAE1CrS,KAAMV,KAAO,KACbU,KAAM0S,WAAa,GACnB1S,KAAM2S,UAAY,GAElB3S,KAAMT,MAAQ,KACdS,KAAM4S,YAAc,GACpB5S,KAAM6S,WAAa,GAEnB7S,KAAMsS,KAAO,KACbtS,KAAM8S,WAAa,GACnB9S,KAAM+S,UAAY,GAElB/S,KAAMgT,OAAS,GACfhT,KAAMiT,QAAU,GAEXjV,GACMC,OAAOC,OAAO8B,KAAMhC,IAIhCuU,aAACtS,iBACA,OAAQ,IAAID,KAAK0F,YAAY1F,KAAK6D,KAAM7D,OAOzCuS,aAACW,oBAAWZ,cACJa,EAiDR,SAAsBb,GACrB,OAAQA,GAAQ,IAAI9P,MAAM,eAlDX4Q,CAAad,GACrB,GAAqB,IAAjBa,EAAMpR,OAEN,OAAOuQ,EAKX9U,IAAM6V,EAAOrT,KAAKiT,SAAYjT,KAAKgT,OAAgBhT,KAAKiT,QAAX,IAC7C,OAAOE,EAAMjO,aAAKoO,EAAMhS,UAAMA,EAAItB,EAAKgT,OAASM,EAAOA,IAAM5P,KAAK2P,IAQ1Ed,aAACgB,sBAAajB,GACb,OAAQtS,KAAKyS,gBAAgBH,IAG9BC,aAACvN,kBAASzE,GACT,IAAOjB,EAAOU,KAAKwT,MAAMxT,KAAKV,KAAMU,KAAK0S,WAAY1S,KAAK2S,WACnDpT,EAAQS,KAAKwT,MAAMxT,KAAKT,MAAOS,KAAK4S,YAAa5S,KAAK6S,YAG7D,OAAQvT,EAFMU,KAAKwT,MAAMxT,KAAKsS,KAAMtS,KAAK8S,WAAY9S,KAAK+S,YAEvB,MAAZxS,EAAmBA,EAAW,IAAMhB,GAG5DgT,aAACiB,eAAMtS,EAAKwG,EAAQC,GAKZ,OAJPD,EAAoB,MAAVA,EAAiBA,EAAS,GACpCC,EAAkB,MAATA,EAAgBA,EAAQ,GAGf,MAAPzG,GACAA,EAAMwG,EAASxG,EAAIoO,QAAQ,OAAQ,IAAMpO,EACzCA,EAAMyG,EAAQzG,EAAIoO,QAAQ,OAAQ,IAAMpO,EACjCwG,EAAS1H,KAAKkT,WAAWhS,GAAOyG,GAGpC,IAmBfnK,IAAMiW,YAAgB/K,EAAO6E,UAAiBA,GAAe,IAiB7D,SAASmG,GAAO9K,EAAM4I,EAAOmC,QACA,IAAdA,IACPA,EAAYnC,EACZA,EAAQ,MAGZA,EAAQA,GAASiC,GAOpBjW,IAAMoW,GAAelL,MAAO,GAM5B,OAGD,SAASmL,EAAIC,EAAOH,EAAWnB,GAC9B,OAAOsB,EAAM5O,aAAIrB,GAChBrG,IAAMuW,EAAUJ,EAAU,IAAIpB,GAAW1O,EAAM2O,IAC/C,OAAOuB,EAAUA,EAAQ/O,SAAS6O,EAAIhQ,EAAKtD,SAAUoT,EAAWnB,IAAmB,KACjF9O,KAAK,IAPDmQ,CAAIjL,EAAKrI,SAAUoT,WAJArB,UAAgB,MAARA,EACzBd,EAAMoC,EAAWlL,SAoB3B,SAAwB4J,EAAMsB,GAC7BpW,IAAMmT,EAAwB,iBAAT2B,EAAoBA,EAAO0B,GAAY1B,GACrD2B,GAAgB,EAapB,OAXAtD,EAAMc,OAAO5Q,iBAAQ2Q,GACvBA,EAAM9I,OAASkL,EAAWlL,MACtB8I,EAAM9I,MAAQuL,IACjBA,EAAezC,EAAM9I,UAID,IAAlBuL,IACHL,EAAWlL,MAAQuL,EAAe,GAGzBtD,EAlCDuD,CAAe5B,EAAMsB,GAAY3B,KAAKT,KC/IhDhU,IAAM2W,GAAc,wBACdC,GAAc,GACdC,GAAc,GAgBpB,SAASC,GAASpT,EAAKqT,GACtB,GAAW,MAAPrT,EACH,OAAOA,EAaR,IARA1D,IAMIoB,EAAM4V,EANJ9U,KACA+U,WAAYvT,EAAKwT,EAAMnR,EAAOoR,UACpB,MAAfJ,EAAKhR,GAAiBmR,EAAOH,EAAKhR,GAASoR,EAAQ,IAEhD5D,EAAS,GACThK,EAAS,EAAGzF,EAAI,EAGbA,EAAIJ,EAAIa,SACdnD,EAAOsC,EAAIyE,WAAWrE,MACT8S,GACZ1U,EAAMmD,KAAKvB,GACD1C,IAASyV,KACnBG,EAAU9U,EAAMsJ,MACXtJ,EAAMqC,SACVgP,GAAU7P,EAAIiF,MAAMY,EAAQyN,GAC3BtT,EAAIiF,MAAMqO,EAAU,EAAGlT,GAAGgO,QAAQ6E,GAAOM,GAC1C1N,EAASzF,EAAI,IAIfA,IAGD,OAAOyP,EAAS7P,EAAIiF,MAAMY,GAY3B,SAASqM,GAAad,GACrB,OAAQA,GAAQ,IAAI9P,MAAM,eAQ3B,SAASoS,GAAa/Q,GACrB,OAAOA,EAAKrD,OAAOyB,aAAe4B,EAQnC,SAASgR,GAAOhR,GACf,OAAOA,IAASA,EAAKrD,OAStB,SAASsU,GAAgBjR,GACxB,OAAOA,EAAK7B,cAAgB6B,EAAKtD,SAASwB,OAe3C,SAASgT,GAAoBhB,GAC5BvW,IAAMqG,EAAOkQ,EAAQlQ,KAErB,GAAIiR,GAAgBjR,GAAO,CAC1BrG,IAAMwX,EAAchB,GAAYnQ,EAAK9D,OAC/ByR,EAA6BwD,EAqBvBvD,OAAO9P,gBAAQmF,EAAQ0K,UAClC1K,GAAU0K,EAAM9I,MAAQ5B,EAAO4B,MAAQ8I,EAAQ1K,GAC9C,MAtBF,GAAI0K,EAAO,CACVhU,IAAMyX,EA8BT,SAA0BtE,EAAOa,GAChChU,IAAM0F,EAAKyN,EAAMc,OAAOjQ,QAAQgQ,GAE1BkD,EAAO,IAAI/D,EAAMjL,YACtBiL,EAAMpL,OAAOY,MAAM,EAAGqL,EAAMP,UAC5BN,EAAMc,OAAOtL,MAAM,EAAGjD,IAGjByR,EAAQ,IAAIhE,EAAMjL,YACvBiL,EAAMpL,OAAOY,MAAMqL,EAAMP,SAAWO,EAAMzP,QAC1C4O,EAAMc,OAAOtL,MAAMjD,EAAK,IAGzB,OAAQwR,EAAMC,GA3CEO,CAAiBF,EAAaxD,GAC5CuC,EAAQzU,KAAOyU,EAAQR,aAAa0B,EAAM,IAC1ClB,EAAQxU,MAAQwU,EAAQR,aAAa0B,EAAM,SAE3ClB,EAAQzB,KAAOyB,EAAQR,aAAayB,GAGrC,OAAO,EAGR,OAAO,EAoCRxX,IAAM2X,IAELC,SAAS,EAITC,SAAU,KAAM,SAGhB3N,OAAQ,GAGRC,MAAO,mCAmFR,SAAS2N,GAAiBzR,EAAM0R,GAC/B,QAAKA,EAAQrL,IAAI,cAIbrG,EAAKrD,OAAOwB,YACoB,IAAhC6B,EAAKrD,OAAOD,SAASwB,SACrBiS,GAAYnQ,EAAKrD,OAAOT,OAAO0R,OAAO1P,WAMnCyT,GAAS3R,EAAM0R,IAUvB,SAA4B1R,EAAM0R,GACjC,IAAKC,GAAS3R,EAAM0R,GACnB,OAAO,EAGR,GAAIT,GAAgBjR,GACnB,OAAO,EAIR,GAAwB,IAApBA,EAAK1B,YAGR,IADA3C,IAAId,EAAOmF,EACJnF,EAAOA,EAAK0D,aAClB,IAAKoT,GAAS9W,EAAM6W,GACnB,OAAO,OAGH,IAAKC,GAAS3R,EAAKxB,gBAAiBkT,GAE1C,OAAO,EAGR,GAAIA,EAAQrL,IAAI,eAAgB,CAK/B,IAHA1K,IAAIiW,EAAiB,EACjB/N,EAAS7D,EAAM8D,EAAQ9D,EAEpB6R,GAAiBhO,EAASA,EAAOrF,gBAAkBkT,IACzDE,IAGD,KAAOC,GAAiB/N,EAAQA,EAAMvF,YAAcmT,IACnDE,IAGD,GAAIA,GAAkBF,EAAQrL,IAAI,eACjC,OAAO,EAKT,IAAK1K,IAAI8B,EAAI,EAAG6G,EAAKtE,EAAKtD,SAASwB,OAAQT,EAAI6G,EAAI7G,IAClD,GAAIgU,GAAiBzR,EAAKtD,SAASe,GAAIiU,GACtC,OAAO,EAIT,OAAO,EA1D0BI,CAAmB9R,EAAM0R,KA8H3D,SAASC,GAAS3R,EAAM0R,GACvB,OAAQ1R,GAAQA,EAAK7B,YAAe0T,GAAgB7R,EAAM0R,GAU3D,SAASG,GAAgB7R,EAAM0R,GAC9B,OAAO1R,GAAQ0R,EAAQC,SAAS3R,GAgEjCrG,IAAMoY,GAAO,QACPC,GAAU,WACVC,IACLC,iBAAS9Q,UAASA,EAAMvB,KAAK,KAC7BsS,mBAAW/Q,UAASA,EAAMC,aAAIpE,UAAQA,EAAKmV,UAAYnV,EAAKhB,KAAUgB,WAAaA,EAAU,QAAI4C,KAAK,QAGjGwS,IACL5W,KAAM,KACNC,MAAO,KACP4W,SAAU,SACV/V,WAAY0V,IAGb,SAASM,GAAarC,EAASwB,EAASvX,GACvCA,EAAUC,OAAOC,UAAWgY,GAAoBlY,GAChDR,IAAMqG,EAAOkQ,EAAQlQ,KAUrB,GARAkQ,EAAQf,OAASuC,EAAQvC,OA0E1B,SAA0BnP,GACzBrE,IAAI6W,EAAQxS,EAAKrD,OAAOwB,YAAc,GAAK,EACvC2C,EAAMd,EACV,KAAOc,EAAMA,EAAInE,QAChB6V,IAGD,OAAOA,EAAQ,EAAI,EAAIA,EAjFSC,CAAiBzS,IACjDkQ,EAAQd,QAAU,KAGb4B,GAAOhR,EAAKrD,SAAYoU,GAAa/Q,KACzCkQ,EAAQrB,WAAaqB,EAAQd,QAAUc,EAAQf,QAG5CnP,EAAK/D,KAAM,CACdtC,IAAM+W,EAAOtW,OAAOC,QACnBqY,KAAMhB,EAAQzV,KAAK+D,EAAK/D,MACxB0W,WAAY3S,EAAKvD,YAActC,EAAQyY,UAAY,MA2BtD,SAAuB1C,EAASwB,EAASvX,GACxCA,EAAUC,OAAOC,UAAW4X,GAAoB9X,GAChDR,IAAMuY,KAAcC,KAuBpB,OAtBajC,EAAQlQ,KAEhBzD,WAAWS,iBAAQC,GACvB,GAAIA,EAAK9C,QAAQoH,SAAyB,MAAdtE,EAAKf,MAChC,OAAO,KAGRvC,IAAMsC,EAAOyV,EAAQmB,UAAU5V,EAAKhB,MAC9BC,EAAQgU,EAAQR,aAAazS,EAAKf,OAExC,GAAI6V,GAAKpO,KAAK1H,GACbC,GAASgW,EAAQlT,SAAS9C,QACpB,GAAI8V,GAAQrO,KAAK1H,GACvBC,GAASgW,EAAQlT,SAAS9C,EAAMuP,QAAQ,OAAQ,UAC1C,CACN9R,IAAMyY,EAA0B,MAAdnV,EAAKf,QAClBe,EAAK9C,QAAQ6D,UAA6E,IAAlE0T,EAAQrL,IAAI,qBAAqB1I,QAAQ1B,EAAK4L,gBAE3EsK,EAAUnT,WAAO/C,QAAMC,YAAOkW,QAK/BU,cAAe3Y,EAAQ+X,QAAQA,IAAY,KAC3Ca,gBAAiB5Y,EAAQgY,UAAUA,IAAc,MArD9Ca,CAAc9C,EAASwB,EAASvX,EAAQoC,aAGvCpC,EAAQmY,UAAYnY,EAAQmY,SAAS3O,KAAK+M,EAAKgC,OAAShC,EAAKoC,gBAChEpC,EAAKgC,KAAO,MAGO,MAAhBvY,EAAQsB,OACXyU,EAAQzU,KAAOgV,GAAStW,EAAQsB,KAAMiV,IAGlB,MAAjBvW,EAAQuB,QACXwU,EAAQxU,MAAQ+U,GAAStW,EAAQuB,MAAOgV,IAI1C,OAAOR,EAwDRvW,IAAMsZ,GAAO,QA0FbtZ,IAAMuZ,GAAS,QACTC,IACLC,KAAQ,qBACRC,MAAQ,sBACRC,MAAQ,sBACRC,OAAQ,sBA2GT5Z,IAAM6Z,GAAS,QA2Ef7Z,IAAM8Z,SA1pBN,SAAc1O,EAAM2M,EAASvX,GAE5BR,IAAM+Z,EAuRP,SAA0BvZ,GACzBR,IAAM+Z,EAAStZ,OAAOC,UAAWF,GAAWA,EAAQuZ,QAEpD,OADAA,EAAOC,QAAUvZ,OAAOC,UAAWiX,GAAgBoC,EAAOC,SACnDD,EA1RQE,CADfzZ,EAAUC,OAAOC,UAAWF,IAG5B,OAAO0V,GAAO9K,EAAM5K,EAAQwT,eAAOuC,GAGlC,IAAKgB,GAFLhB,EAkCF,SAAuBA,EAASwB,GAC/B/X,IAAMqG,EAAOkQ,EAAQlQ,KAErB,GAAIyR,GAAiBzR,EAAM0R,GAAU,CACpCxB,EAAQf,OAASuC,EAAQvC,OA8L3B,SAAwBnP,EAAM0R,GAO7B,IAHA/X,IAAMka,EAAOnC,EAAQrL,IAAI,kBACrBmM,EAAQxS,EAAKrD,OAAOwB,YAAc,GAAK,EACvC2C,EAAMd,EACHc,EAAMA,EAAInE,SACwC,IAApDkX,EAAKlW,SAAUmD,EAAI7E,MAAQ,IAAI4L,gBAClC2K,IAIF,OAAOA,EAAQ,EAAI,EAAIA,EA3MUsB,CAAe9T,EAAM0R,IACrDxB,EAAQd,QAAU,KAClBzV,IAAM2R,EAAS4E,EAAQd,QAAUc,EAAQf,OAGpC6B,GAAOhR,EAAKrD,SAAYoU,GAAa/Q,KACzCkQ,EAAQrB,WAAavD,EACjBtL,EAAK7B,aACR+R,EAAQjB,WAAa3D,IAsGzB,SAA4BtL,EAAM0R,GAEjC/X,IAAMoa,GAAY/T,EAAK/D,MAAQ,IAAI4L,cACnC,IAAsD,IAAlD6J,EAAQrL,IAAI,eAAe1I,QAAQoW,GACtC,OAAO,EAKR,IAAKpY,IAAI8B,EAAI,EAAGA,EAAIuC,EAAKtD,SAASwB,OAAQT,IACzC,GAAIgU,GAAiBzR,EAAKtD,SAASe,GAAIiU,GACtC,OAAO,EAIT,OAAO,EAjHFsC,CAAmBhU,EAAM0R,KACvB1R,EAAK7B,aACT+R,EAAQjB,WAAa3D,EAASoG,EAAQvC,OAAO,IAE9Ce,EAAQnB,YAAczD,GAIxB,OAAO4E,EA1DI+D,CAAc/D,EAASwB,IAEE,CAClC/X,IAAMqG,EAAOkQ,EAAQlQ,KAErB,GAAIA,EAAK/D,KAAM,CACdtC,IAAMsC,EAAOyV,EAAQzV,KAAK+D,EAAK/D,MACzBmF,EAqKV,SAA0B8O,EAASwB,GAGlC,OAFaxB,EAAQlQ,KAETzD,WAAW8E,aAAIpE,GAC1B,GAAIA,EAAK9C,QAAQoH,SAAyB,MAAdtE,EAAKf,MAChC,OAAO,KAGRvC,IAAMua,EAAWxC,EAAQmB,UAAU5V,EAAKhB,MACpCkY,EAAY,KAGhB,GAAIlX,EAAK9C,QAAQ6D,UAAiF,IAAtE0T,EAAQrL,IAAI,qBAAqB1I,QAAQuW,EAASrM,eAAuB,CACpG,GAAI6J,EAAQrL,IAAI,6BAA6C,MAAdpJ,EAAKf,MACnD,UAAWgY,EACa,MAAdjX,EAAKf,QACfiY,EAAYD,GAQd,OAJiB,MAAbC,IACHA,EAAYjE,EAAQR,aAAazS,EAAKf,YAG5BgY,MAAYxC,EAAQlX,MAAM2Z,KACnCtU,KAAK,IA9LSuU,CAAiBlE,EAASwB,GAExCxB,EAAQzU,KAAO,IAAIQ,EAAOmF,GAAQpB,EAAKvD,YAAciV,EAAQkB,YAAc,QACtE5S,EAAKvD,cACTyT,EAAQxU,MAAQ,KAAKO,OA8O1B,SAAqBiU,EAAS/V,GAC7BR,IAAMqG,EAAOkQ,EAAQlQ,KAErB,GAAK7F,EAAQoX,SAAYpX,EAAQqX,SAAYxR,EAAK/D,KAalD,IATAtC,IAAMyH,EAAQ8O,EAAQlQ,KAAKzD,WAAWuB,gBAAQC,EAAKd,GAKlD,OAJIA,EAAKhB,MAAsB,MAAdgB,EAAKf,QACrB6B,EAAId,EAAKhB,KAAKoY,cAAc5I,QAAQ,KAAM,MAAQxO,EAAKf,OAGjD6B,OAICN,EAAI,EAAG6G,EAAKnK,EAAQqX,QAAQtT,OAAQT,EAAI6G,EAAI7G,IACpD,GAAItD,EAAQqX,QAAQ/T,GAAG4W,gBAAiBjT,EAAO,CAC9C8O,EAAQzU,KAAOgV,GAAStW,EAAQ0J,OAAQzC,GAAS8O,EAAQzU,KACrDyU,EAAQxU,QACXwU,EAAQxU,OAAS+U,GAAStW,EAAQ2J,MAAO1C,IAE1C,OAjQCkT,CAAYpE,EAASwD,EAAOC,UAKzB3T,EAAK9D,QAAW8D,EAAKtD,SAASwB,SAAW8B,EAAKvD,eACjDyT,EAAQzB,KAAOyB,EAAQR,aAAa1P,EAAK9D,QAI3C,OAAOgU,UAkXT,SAAcnL,EAAM2M,EAASvX,GAE5BR,IAAM4a,GACL9Y,KAAM,wDACNmX,UAAW,IACXrW,YACC4V,mBAAU/Q,GACT,OAAOA,EAAMC,aAAIpE,UAAQA,EAAKmV,UACxBnV,EAAS,MAAGyU,EAAQrL,IAAI,4BAA8B,GAAK,SAC3DpJ,WAAayU,EAAQlX,MAAMyC,EAAKf,SACpC2D,KAAK,QAKV,OAAOgQ,GAAO9K,GAdd5K,EAAUA,OAckBwT,eAAOuC,GAIlC,IAAKgB,GAFLhB,EAwBF,SAA0BA,EAASwB,GAClC/X,IAAMqG,EAAOkQ,EAAQlQ,KASrB,OAPKA,EAAK7B,YAAc6B,EAAK9D,QAE5BgU,EAAQjB,WAAagE,GAAKtP,KAAK3D,EAAK9D,OACjCgU,EAAQd,QAAUc,EAAQf,OAASuC,EAAQvC,OAAO,GAClD,KAGGe,EAlCIsE,CADVtE,EAAUqC,GAAarC,EAASwB,EAAS6C,GACL7C,IAED,CAClC/X,IAAMqG,EAAOkQ,EAAQlQ,MAIjBA,EAAK9D,QAAW8D,EAAKtD,SAASwB,SAAW8B,EAAKvD,eACjDyT,EAAQzB,KAAOyB,EAAQR,aAmC3B,SAAyB1P,EAAM0R,GAC9B,GAAkB,MAAd1R,EAAK9D,OAAiB+W,GAAKtP,KAAK3D,EAAK9D,OAAQ,CAChDvC,IAAM2V,EAAQC,GAAavP,EAAK9D,OAC1BiT,EAASuC,EAAQvC,OAAO,GACxBsF,EAAYnF,EAAMxR,gBAAQwC,EAAMmP,UAASiF,KAAKC,IAAIrU,EAAMmP,EAAKvR,SAAS,GAE5E,OAAOoR,EAAMjO,aAAKoO,EAAMhS,aAASA,EAAI0R,EAAS,IAMhD,SAAaV,EAAMtG,GAClB,KAAOsG,EAAKvQ,OAASiK,GACpBsG,GAAQ,IAGT,OAAOA,GAXiDgB,EAAMgF,UAAgB5U,KAAK,MAGnF,OAAOG,EAAK9D,MA5C2B0Y,CAAgB5U,EAAM0R,KAI5D,OAAOxB,UAmET,SAAcnL,EAAM2M,EAASvX,GAE5BR,IAAMoZ,GADN5Y,EAAUA,OACsB0a,eAC5B1B,GAAehZ,EAAQ0a,gBACvB1B,GAAeC,KAEb0B,EAAc/B,IAAoBI,GAAeC,cACpDnW,UAAWA,yBACXA,UAAQA,EAAKhB,MAEVsY,GACL9Y,6BAA8BsX,iBAC9BH,UAAW,IACXrW,YACC4V,mBAAU/Q,GACT,OAAOA,EAAMC,aAAIpE,UAAQA,EAAKmV,UAC3B0C,EAAY7X,GACTA,WAAayU,EAAQlX,MAAMyC,EAAKf,SACpC2D,KAAK,QAKV,OAAOgQ,GAAO9K,EAAM5K,EAAQwT,eAAOuC,GAIlC,IAAKgB,GAFLhB,EAwBF,SAA4BA,EAASwB,GACpC/X,IAAMqG,EAAOkQ,EAAQlQ,KACfrD,EAASqD,EAAKrD,OAgBpB,OAZmC,IAA/B+U,EAAQrL,IAAI,gBAqCjB,SAAoBrG,EAAM0R,GACzB,OAAO1R,IAASA,EAAK7B,YAAcuT,EAAQC,SAAS3R,IAtCZ+U,CAAW/U,EAAM0R,KACpDV,GAAOrU,IAA2B,MAAhBA,EAAOT,OAA4C,IAA3BS,EAAOD,SAASwB,SAC9DgS,EAAQrB,WAAa,OAGjB7O,EAAK7B,YAAc6B,EAAK9D,QAE5BgU,EAAQjB,WAAaiE,GAAOvP,KAAK3D,EAAK9D,OACnCgU,EAAQd,QAAUc,EAAQf,OAASuC,EAAQvC,OAAO,GAClD,KAGGe,EA1CI8E,CADV9E,EAAUqC,GAAarC,EAASwB,EAAS6C,GACH7C,IAEH,CAClC/X,IAAMqG,EAAOkQ,EAAQlQ,MAIjBA,EAAK9D,QAAW8D,EAAKtD,SAASwB,SAAW8B,EAAKvD,eACjDyT,EAAQzB,KAAOyB,EAAQR,aA4C3B,SAA2B1P,EAAM0R,GAChC,GAAkB,MAAd1R,EAAK9D,OAAiBgX,GAAOvP,KAAK3D,EAAK9D,OAAQ,CAClDvC,IAAMwV,EAASuC,EAAQvC,OAAO,GAC9B,OAAOI,GAAavP,EAAK9D,OAAOmF,aAAKoO,EAAMhS,UAAS0R,GAAS1R,EAAI,IAAM,SAAOgS,IAAQ5P,KAAK,MAG5F,OAAOG,EAAK9D,MAlD2B+Y,CAAkBjV,EAAM0R,KAI9D,OAAOxB,SAqET,SAAanL,EAAM2M,EAASvX,GAE3BR,IAAM4a,GACL9Y,KAAM,2CACNc,YACC4V,mBAAU/Q,GACT,OAAOA,EAAMC,aAAIpE,UAAQA,EAAKmV,UAAYnV,EAAKhB,KAAUgB,WAAayU,EAAQlX,MAAMyC,EAAKf,SAAU2D,KAAK,SAK3G,OAAOgQ,GAAO9K,GAVd5K,EAAUA,OAUkBwT,eAAOuC,GAIlC,IAAKgB,GAFLhB,EAuBF,SAA4BA,EAASwB,GACpC/X,IAAMqG,EAAOkQ,EAAQlQ,KASrB,OAPKA,EAAK7B,YAAc6B,EAAK9D,QAE5BgU,EAAQjB,WAAauE,GAAO7P,KAAK3D,EAAK9D,OACnCgU,EAAQd,QAAUc,EAAQf,OAASuC,EAAQvC,OAAO,GAClD,KAGGe,EAjCIgF,CADVhF,EAAUqC,GAAarC,EAASwB,EAAS6C,GACH7C,IAEH,CAClC/X,IAAMqG,EAAOkQ,EAAQlQ,MAGjBA,EAAK9D,QAAW8D,EAAKtD,SAASwB,SAAW8B,EAAKvD,eACjDyT,EAAQzB,KAAOyB,EAAQR,aAoC3B,SAA2B1P,EAAM0R,GAChC,GAAkB,MAAd1R,EAAK9D,OAAiBsX,GAAO7P,KAAK3D,EAAK9D,OAAQ,CAClDvC,IAAMwV,EAASuC,EAAQvC,OAAO,GAC9B,OAAOI,GAAavP,EAAK9D,OAAOmF,aAAIoO,UAAWN,OAAWM,IAAQ5P,KAAK,MAGxE,OAAOG,EAAK9D,MA1C2BiZ,CAAkBnV,EAAM0R,KAI9D,OAAOxB,MA6DT,SAASrL,GAAME,EAAM2M,EAAS0D,EAAQjb,GAWrC,MAVsB,iBAAXib,IACVjb,EAAUib,EACVA,EAAS,MAgBX,SAAkBA,GACjB,QAASA,GAAUA,KAAU3B,GAdxB4B,CAASD,KAEbA,EAAS,QAGH3B,GAAkB2B,GAAQrQ,EAAM2M,EAASvX,GC12BjD,IAAMmb,GACL,WACAnZ,KAAMoZ,KAAO,YACbpZ,KAAMD,yCAGFgM,oBACJ,OAAQ/L,KAAKD,MAAMgC,QAGpBoX,aAAC3P,aAAIzJ,GACJC,KAAMD,MAAM8C,KAAK9C,IAGlBoZ,aAAC5P,aAAIxJ,GACJ,OAAuC,IAA/BC,KAAKD,MAAMyB,QAAQzB,IAG5BoZ,aAACnU,oBACA,OAAQhF,KAAKD,MAAM2D,KAAK,+CAIzBlG,IAAMsK,GAAO,GACPb,GAAO,GAOb,SAASoS,GAAatb,GAMrB,GAAIA,EAAOO,SAAWwJ,GAAM,CAC3B/J,EAAOI,MAAQJ,EAAOK,IACtBL,EAAOW,OAEPX,EAAOQ,IAAI,MAAgBR,EAAO+H,SAASwT,IAC3C9b,IAAM+b,EAAOxb,EAAOkI,UAIpB,GADAlI,EAAOI,MAAQJ,EAAOK,IAClBL,EAAOQ,IAAI0I,MAASlJ,EAAO+H,SAASjH,GACvC,MAAMd,EAAOY,MAAM,iDAGpB,OAAO,IAAI6a,GAAMD,EAAMxb,EAAOkI,YAIhC,IAAMuT,GACL,SAAYzZ,EAAO0Z,GACnBzZ,KAAMoZ,KAAO,QACbpZ,KAAM0Z,IAAM3Z,EACZC,KAAMyZ,MAAQjN,OAAgB,MAATiN,GAA2B,KAAVA,EAAeA,EAAQ,GAG7D,IAAKtN,EAAI,EAAGwN,EAAI,EAAGvH,EAAI,EAEvB,GAAe,OAJfrS,EAASA,EAAMoG,MAAM,IAKpBnG,KAAMyZ,MAAQ,OAEd,OAAS1Z,EAAMgC,QACd,KAAM,EACL,MAED,KAAM,EACLoK,EAAKwN,EAAIvH,EAAIrS,EAAQA,EACrB,MAED,KAAM,EACLoM,EAAKwN,EAAIvH,EAAIrS,EACb,MAED,KAAM,EACLoM,EAAKpM,EAAM,GAAKA,EAAM,GACtB4Z,EAAK5Z,EAAM,GAAKA,EAAM,GACtBqS,EAAKrS,EAAM,GAAKA,EAAM,GACtB,MAED,QAECoM,GADApM,GAAUA,GACCoG,MAAM,EAAG,GACpBwT,EAAK5Z,EAAMoG,MAAM,EAAG,GACpBiM,EAAKrS,EAAMoG,MAAM,EAAG,GAIvBnG,KAAMmM,EAAIM,SAASN,EAAG,IACtBnM,KAAM2Z,EAAIlN,SAASkN,EAAG,IACtB3Z,KAAMoS,EAAI3F,SAAS2F,EAAG,KAyCvB,SAASkH,GAAM1a,GACd,OAAOC,EAASD,IAASE,EAAQF,EAAM,GAAI,IAG5C,SAASgb,GAAWC,GACnB,QAASA,EAAM,IAGhB,SAASC,GAAWC,GACnB,OAAQA,GAAO,GAAG/U,SAAS,IAG5B,SAASgV,GAAMD,GACd,OAGD,SAAaha,EAAOiM,GACnB,KAAOjM,EAAMgC,OAASiK,GACrBjM,EAAQ,IAAMA,EAEf,OAAOA,EAPAka,CAAIF,EAAI/U,SAAS,IAAK,GAc9B,SAASkV,GAAmBtb,GAC3B,OAAOC,EAASD,IAASub,GAAYvb,GAOtC,SAASub,GAAYvb,GACpB,OAAgB,KAATA,GAAuBE,EAAQF,GArEvC4a,aAACQ,eAAMI,GACN,IAAO3V,EAAM2V,GAASR,GAAW5Z,KAAKmM,IAAMyN,GAAW5Z,KAAK2Z,IAAMC,GAAW5Z,KAAKoS,GAC9E0H,GAAaE,GAEjB,MAAQ,IAAMvV,EAAGzE,KAAKmM,GAAM1H,EAAGzE,KAAK2Z,GAAKlV,EAAGzE,KAAKoS,IAOlDoH,aAACa,iBACA,IAAOjQ,GAAUpK,KAAKmM,EAAGnM,KAAK2Z,EAAG3Z,KAAKoS,GAKtC,OAJoB,IAAfpS,KAAKyZ,OACTrP,EAAQvH,KAAK7C,KAAKyZ,MAAMa,QAAQ,GAAGhL,QAAQ,SAAU,MAGzB,IAAlBlF,EAAOrI,OAAe,MAAQ,YAAUqI,EAAO1G,KAAK,WAGhE8V,aAACxU,kBAASoV,GACT,OAAMpa,KAAKmM,GAAMnM,KAAK2Z,GAAM3Z,KAAKoS,GAAMpS,KAAKyZ,MAGrB,IAAfzZ,KAAKyZ,MAAczZ,KAAKga,MAAMI,GAASpa,KAAKqa,QAF3C,eAkDV7c,IAAM+c,GAAU,GACVxS,GAAY,GACZyS,GAAU,GAQhB,SAASC,GAAoB1c,GAE5B,GADAA,EAAOI,MAAQJ,EAAOK,IA+BvB,SAAmBL,GAClBP,IAAMW,EAAQJ,EAAOK,IAEfsc,GADW3c,EAAOQ,IAAIic,IACNzc,EAAOK,KAE7BL,EAAO+H,SAASjH,GAEhBrB,IAAMmd,EAAU5c,EAAOK,IACnBL,EAAOQ,IAAIwJ,MAAWhK,EAAO+H,SAASjH,KAEzCd,EAAOK,IAAMuc,GAIV5c,EAAOK,MAAQsc,IAClB3c,EAAOK,IAAMD,GAGd,OAAOJ,EAAOK,MAAQD,EAhDlByc,CAAU7c,GAAS,CACtBP,IAAMuc,EAAMhc,EAAOkI,UAKnB,OAJAlI,EAAOI,MAAQJ,EAAOK,IAGtBL,EAAOQ,IAAIgc,KAAYxc,EAAO+H,SAASqU,IAChC,IAAIU,GAAad,EAAKhc,EAAOkI,YAOtC,IAAM4U,GACL,SAAY9a,EAAO+a,GACnB9a,KAAMoZ,KAAO,UACbpZ,KAAMD,MAAQyM,OAAOzM,GACrBC,KAAM8a,KAAOA,GAAQ,IAGtBD,aAAC7V,oBACA,SAAWhF,KAAU,MAAGA,KAAS,MA8BlCxC,IAAM4T,GAAS,GACT2J,GAAW,GACXC,GAAS,GAYf,SAASC,GAAeld,EAAQqc,GAY/B,OAXArc,EAAOI,MAAQJ,EAAOK,IAElBL,EAAOQ,IAAI6S,KAAWrT,EAAOQ,IAAIyc,IAEpCjd,EAAO+H,SAASoV,IACNd,EACVrc,EAAO+H,SAASqU,IAEhBpc,EAAO+H,SAASqV,IAGVpd,EAAOI,QAAUJ,EAAOK,IAAM,IAAIgd,GAAQrd,EAAOkI,WAAa,KAGtE,IAAMmV,GACL,SAAYrb,GACZC,KAAMoZ,KAAO,UACbpZ,KAAMD,MAAQA,GAQf,SAASob,GAAUvc,GAClB,OAAOsb,GAAmBtb,IAASA,IAASmc,GAG7C,SAASG,GAAetc,GACvB,OAAgB,KAATA,GAAuBsb,GAAmBtb,GAVlDwc,aAACpW,oBACA,OAAQhF,KAAKD,OAYdvC,IAAM2H,IAAQtH,QAAQ,GAOtB,SAAS4I,GAAc1I,GACtB,GAAID,EAAUC,EAAQoH,IACrB,OAAO,IAAIkW,GAAatd,EAAOkI,WAIjC,IAAMoV,GACL,SAAYtb,GACZC,KAAMoZ,KAAO,SACbpZ,KAAMD,MAAQA,GAGfsb,aAACrW,oBACA,OAAQhF,KAAKD,OAIdvC,IAAM8d,GAAS,GACTC,GAAS,GACTC,GAAS,GASf,SAASC,GAAoB1d,GAC5B,IAAKA,EAAOQ,IAAI+c,IAEf,OAAO,KAMR,IAHA9b,IAAIkc,EACEC,MAEE5d,EAAOU,OACd,GAAIid,EAAME,GAAgB7d,GACzB4d,EAAS9Y,KAAK6Y,OACR,CAIN,GAFA3d,EAAO+H,SAAS5G,GAEZnB,EAAOQ,IAAIgd,IAEd,MAGD,IAAKxd,EAAOQ,IAAIid,IACf,MAAMzd,EAAOY,MAAM,mBAKtB,OAAOgd,EASR,SAASC,GAAgB7d,GAIxB,IAHAP,IACIuC,EADE+G,EAAS,IAAIqS,IAGXpb,EAAOU,QACdV,EAAO+H,SAAS5G,GAChBa,EAAQ0a,GAAoB1c,IAAWsb,GAAatb,IAChD0I,GAAc1I,IAAW8d,GAAyB9d,KAMtD+I,EAAO0C,IAAIzJ,GAGZ,OAAO+G,EAAOiF,KAAOjF,EAAS,KAQ/B,SAAS+U,GAAyB9d,GACjCP,IAAMse,EAAKb,GAAeld,GAC1B,GAAI+d,EAAI,CACPte,IAAMqH,EAAO4W,GAAoB1d,GACjC,OAAO8G,EAAO,IAAIkX,GAAaD,EAAG9W,WAAYH,GAAQiX,GAIxD,IAAMC,GAKL,SAAYjc,EAAM+E,GAClB7E,KAAMoZ,KAAO,WACbpZ,KAAMF,KAAOA,EACbE,KAAM6E,KAAOA,OAGdkX,aAAC/W,oBACA,OAAWhF,cAAaA,KAAK6E,KAAKnB,KAAK,WAIxClG,IAAMwJ,GAAS,GACTgV,GAAW,GACXC,GAAS,GACTC,GAAW,GACX7K,GAAS,GACT8K,GAAW,GAkDjB,SAASC,GAAare,GAIrB,OAHAA,EAAOI,MAAQJ,EAAOK,IACtBL,EAAO+H,SAASuW,IAChBte,EAAO+H,SAASwW,IACTve,EAAOI,QAAUJ,EAAOK,IAAML,EAAOkI,UAAY,KAQzD,SAASsW,GAAaxe,GAIrB,IAHAP,IACIuC,EADEqK,EAAS,IAAI+O,IAGXpb,EAAOU,QAEdV,EAAOQ,IAAI8S,KACPtR,EAAQ0a,GAAoB1c,IAAWsb,GAAatb,IAGlDgC,EAAM+a,MACV/c,EAAOQ,IAAI2d,KAGZne,EAAOQ,IAAI2d,IACXnc,EAAQkb,GAAeld,GAAQ,IAG3BgC,IAILqK,EAAOZ,IAAIzJ,GAGZ,OAAOqK,EAOR,SAASkS,GAAQ1d,GAChB,OAAOub,GAAYvb,GAOpB,SAASyd,GAAczd,GACtB,OAAOA,IAASud,IAAQvd,IAASod,IAAYpd,IAASoI,GCvgBvDxJ,IAAMgd,GAAO,GASb,SAASgC,GAAY7T,EAAMpD,GAI1B,IAHAoD,EAAOA,EAAK+C,kBACZnG,EAASA,EAAOmG,eAGf,OAAO,EAIR,IAAKnG,GAAUoD,EAAKhD,WAAW,KAAOJ,EAAOI,WAAW,GACvD,OAAO,EAQR,IALAnI,IAGIif,EAAKC,EAAKC,EAAOC,EAoCT5W,EAvCN6W,EAAalU,EAAK5G,OAClB+a,EAAevX,EAAOxD,OACxBT,EAAI,EAAGyb,EAAI,EAAGC,EAAQF,EAGnBxb,EAAIub,GAAY,CAKtB,IAJAJ,EAAM9T,EAAKhD,WAAWrE,GACtBqb,GAAQ,EACRC,GAAU,EAEHG,EAAID,GAAc,CAGxB,GAAIL,KAFJC,EAAMnX,EAAOI,WAAWoX,IAEP,CAChBJ,GAAQ,EACRK,IAAUF,EAAeC,IAAMH,EAAU,EAAI,GAC7C,MAIDA,EAAUF,IAAQlC,GAClBuC,IAGD,IAAKJ,EACJ,MAGDrb,IAGD,OAAO0b,GAASA,GAAS1b,EAAIub,KAQjB7W,EARmC8W,IASnC9W,EAAI,GAAK,GAGtBxI,IAAMyf,GAAa,oCACblC,GAAS,GAaf,SAASmC,GAAYC,GACpB,OAyED,SAAcA,GACbA,EAAWA,EAAShL,KAAKiL,IAMzB,IALA5f,IAAMkC,KAKG4B,EAAI,EAAG+b,SAAKlZ,SAAM7C,EAAI6b,EAASpb,OAAQT,IAG/C,IAFA+b,EAAMF,EAAS7b,IAENgc,SAAT,CAQA,KAAO5d,EAAMqC,QAAQ,CAGpB,GAFAoC,EAAOzE,EAAMA,EAAMqC,OAAS,GAEgB,IAAxCsb,EAAIC,SAAS9b,QAAQ2C,EAAKmZ,WAC1BD,EAAIC,SAAS3X,WAAWxB,EAAKmZ,SAASvb,UAAYgZ,GAAQ,CAC7D5W,EAAKoZ,cAAcF,GACnB3d,EAAMmD,KAAKwa,GACX,MAGD3d,EAAMsJ,MAGFtJ,EAAMqC,QACVrC,EAAMmD,KAAKwa,GAIb,OAAOF,EA7GAK,CAAML,EAASjY,aAAIoE,UAAW,IAAImU,GAAWnU,EAAQ8G,IAAK9G,EAAQvJ,UAG1E,IAAM0d,GACL,SAAYrN,EAAKrQ,GACjBC,KAAMoQ,IAAMA,EACZpQ,KAAMD,MAAQA,EACdC,KAAMsd,SAAW,KAGjB,IAAOxN,EAAI/P,GAASA,EAAM6F,MAAMqX,IAC3BnN,IACJ9P,KAAMsd,SAAWxN,EAAE,GACnB9P,KAAMD,MAAQ+P,EAAE,IAGjB9P,KAAM0d,qDAsGP,SAASN,GAAanT,EAAGmI,GACxB,OAAInI,EAAEmG,MAAQgC,EAAEhC,IACR,EAGDnG,EAAEmG,IAAMgC,EAAEhC,KAAO,EAAI,EAQ7B,SAAS+K,GAAUja,GAClB,MAAO,aAAasG,KAAKtG,GAG1B,SAASyc,GAAW5d,GACnB,OAAOJ,OAAOI,GAAOyC,MAAM,KArH5Bib,aAACF,uBAAcK,GACd5d,KAAM0d,aAAa7a,KAAK+a,OAGpBC,4BACJ,OAAsB,MAAd7d,KAAKD,MAAgB4d,GAAW3d,KAAKD,OAAO,GAAK,MAO1D0d,aAACK,oBACA,IAEYzc,EAAM0c,EAFXre,KACAoe,EAAW,IAAI1U,IACjB9H,EAAI,EAOT,IALKtB,KAAKsd,UAET5d,EAAOmD,KAAK7C,MAGLsB,EAAI5B,EAAMqC,QAKjB,IAFAV,EAAQ3B,EAAM4B,MAEJvB,MAAO,CAChBge,EAAcJ,GAAWtc,EAAKtB,OAAO0C,OAAO0Y,IAG5C,IAAM3b,IAAIud,EAAI,EAAGA,EAAIgB,EAAWhc,OAAQgb,IACvCe,EAAUtU,IAAIuU,EAAWhB,GAAG5b,QAI7B,IAAM3B,IAAIud,EAAI,EAAGiB,EAAO3c,EAAKqc,aAAcX,EAAIiB,EAAKjc,OAAQgb,KAC1B,IAA5Brd,EAAM8B,QAAQwc,EAAKjB,KACvBrd,EAAOmD,KAAKmb,EAAKjB,IAMrB,OAAQpc,MAAM5B,KAAK+e,6CA4EpBtgB,IAAMygB,IAAkB,OAAQ,UAAW,SACrCC,IACL,UAAW,cAAe,UAAW,cAAe,OACpD,OAAQ,YAAa,eAGhBvgB,IACLwgB,QAAS,KACTC,UAAW,KACXC,aACCC,EAAG,KACH5T,EAAG,IACH6T,EAAG,KACHpS,EAAG,OAEJqS,oBAAqB,GAWtB,SAAS9V,GAAME,EAAMO,EAAUnL,IAC9BA,EAAUC,OAAOC,UAAWP,GAAgBK,IACpCqgB,YAAcpgB,OAAOC,UAAWP,GAAe0gB,YAAargB,GAAWA,EAAQqgB,aAEvF7gB,IAAM2f,EAMP,SAA8BhU,GAC7B,OAAO+T,GAAY/T,EAASsV,KAAKrF,KAAM,YAPtBsF,CAAqBvV,GAGtC,OADAP,EAAKpE,cAAKX,UAgBX,SAAqBA,EAAMsZ,EAAUnf,GACpC,GAAIA,EAAQsf,SAEX,OAwFF,SAAgCzZ,EAAMyF,EAAStL,GAK9CwB,IAAIse,EAAWG,GAAe9X,QAC1BmD,IACHwU,EAAWA,EAASra,OAAO6F,EAAQwU,aAGpCtgB,IAAM4M,GAAUvG,EAAK/D,MAAM2D,OAAOI,EAAK9D,MAAMA,OAC3C0C,OAAOwN,SACP/K,aAAInF,GACJ,OAAqB,iBAAVA,GAAqC,YAAfA,EAAMqZ,OAE/BuF,GADP5e,EAAQJ,OAAOI,GACa+d,EAAU,KAAM9f,EAAQwgB,sBAG9Cze,IAMT,OAHA8D,EAAK/D,KAAO,KACZ+D,EAAK9D,MAAMA,MAAQqK,EAEZvG,EAhHC+a,CAAuB/a,EAAMsZ,EAAS9N,cAAK/F,UAAWA,EAAQgU,WAAatf,EAAQsf,WAAWtf,GAGtGR,IAAM8L,EAAUqV,GAAc9a,EAAK/D,KAAMqd,EAAU,MAAOnf,EAAQwgB,qBAElE,IAAKlV,EAEJ,MAAqB,MAAdzF,EAAK/D,KAAe+e,GAAchb,EAAM,cAAgBA,EAGhE,OAAOyF,EAAQgU,SAYhB,SAA2BzZ,EAAMyF,EAASwV,GACzCthB,IAAMmL,EAAO9E,EAAK/D,KAGlB,GAFA+D,EAAK/D,KAAOwJ,EAAQgU,SAEhBzZ,EAAK9D,OAA+B,iBAAf8D,EAAK9D,MAAoB,CAEjDvC,IAAMsgB,EAAWxU,EAAQwU,WAEzB,GAAKja,EAAK9D,MAAMgM,KAmBf,IAAKvM,IAAI8B,EAAI,EAAGiC,SAAOjC,EAAIuC,EAAK9D,MAAMA,MAAMgC,OAAQT,IAGrC,OAFdiC,EAAQM,EAAK9D,MAAMA,MAAMuB,IAGxBiC,GAAYjC,EAAc,GAAV,sBACNyd,GAAYxb,GACtBA,EAAQob,GAAcpb,EAAMxD,MAAO+d,IAC/Ba,GAAcpb,EAAMxD,MAAOke,KAC3B1a,EACMyb,GAAezb,KACzBA,EAAQ0b,GAAoBpb,EAAK/D,KAAMyD,EAAOub,IAG/Cjb,EAAK9D,MAAMA,MAAMuB,GAAKiC,MAhCF,CAErB/D,IAAIsc,EAAK6C,GAiJZ,SAA0BhW,EAAMpD,GAC/B,IAAK/F,IAAI8B,EAAI,EAAGkT,EAAU,EAAGlT,EAAIqH,EAAK5G,OAAQT,IAAK,CAElD,IAAiB,KADjBkT,EAAUjP,EAAO/D,QAAQmH,EAAKrH,GAAIkT,IAEjC,OAAO7L,EAAKxC,MAAM7E,GAEnBkT,IAGD,MAAO,GA1JkB0K,CAAiBvW,EAAMW,EAAQ8G,KAAM0N,GAEvDhC,IAEJA,EAAKxS,EAAQuU,gBACmB,IAAtB/B,EAAGta,QAAQ,QAGpBsa,EAAK,OAAQA,OAIXA,GACHjY,EAAK9D,MAAMyJ,IAAIsS,IAsBlB,OAAOjY,EAxDJsb,CAAkBtb,EAAMyF,EAAStL,GAiErC,SAA0B6F,EAAMyF,GAC/B,OAAOuV,GAAchb,EAAMyF,EAAQvJ,OAjEhCqf,CAAiBvb,EAAMyF,GA/BRiB,CAAY1G,EAAMsZ,EAAUnf,KACvC4K,EA2IR,SAASiW,GAAchb,EAAMyO,GAG5B,OAFAzO,EAAK/D,KAAO,KACZ+D,EAAK9D,MAAQuS,EACNzO,EAYR,SAAS8a,GAAchW,EAAM0W,EAAOjP,EAAKoO,GACxC,IAAK7V,EACJ,OAAO,KAGRnJ,IAAI8f,EAAc,KACdC,EAAW,EACff,EAAsBA,GAAuB,EAE7C,IAAKhf,IAAI8B,EAAI,EAAGD,SAAMC,EAAI+d,EAAMtd,OAAQT,IAAK,CAE5C9D,IAAMwf,EAAQR,GAAY7T,EAAM6W,GADhCne,EAAOge,EAAM/d,GACwC8O,IAErD,GAAc,IAAV4M,EAEH,OAAO3b,EAGJ2b,GAASA,GAASuC,IACrBA,EAAWvC,EACXsC,EAAcje,GAIhB,OAAOke,GAAYf,EAAsBc,EAAc,KAGxD,SAASE,GAAene,EAAM+O,GAC7B5S,IAAMuC,EAAQsB,GAAwB,iBAATA,EAAoBA,EAAK+O,GAAO/O,EACvDyO,GAAK/P,GAAS,IAAI6F,MAAM,YAC9B,OAAOkK,EAAIA,EAAE,GAAK/P,EA4BnB,SAASgf,GAAYxb,GACpB,OAAOkc,GAAYlc,EAAO,WAQ3B,SAASyb,GAAezb,GACvB,OAAOkc,GAAYlc,EAAO,WAG3B,SAASkc,GAAYlc,EAAO6V,GAC3B,OAAO7V,GAA0B,iBAAVA,GAAsBA,EAAM6V,OAASA,EAU7D,SAAS6F,GAAoB3B,EAAU/Z,EAAOub,GAS7C,OARIvb,EAAMuX,KACTvX,EAAMuX,KAAOgE,EAAcT,YAAY9a,EAAMuX,OAASvX,EAAMuX,KAClC,IAAhBvX,EAAMxD,QAAyD,IAA1Cme,GAAmB1c,QAAQ8b,KAG1D/Z,EAAMuX,KAAOvX,EAAMxD,SAAuB,EAAZwD,EAAMxD,OAAW+e,EAAcX,QAAUW,EAAcV,WAG/E7a,EC9eR/F,IAAMkiB,IACLC,UAAU,EACVC,QAAS,KACTjY,MAAO,KAWR,SAASkY,GAAIjX,EAAM2M,EAASvX,GAC3BA,EAAUA,MACVR,IAAMsiB,EAAY7hB,OAAOC,UAAWwhB,GAAsB1hB,GAAWA,EAAQuZ,QAE7E,OAAO7D,GAAO9K,EAAM5K,EAAQwT,eAAOuC,GAClCvW,IAAMqG,EAAOkQ,EAAQlQ,KACjB9D,EAAQggB,GAAelc,EAAMic,GAE7Bjc,EAAKzD,WAAW2B,SAEnBhC,EA4BH,SAAsBwF,EAAQ6E,GAC7B5M,IAAMwX,EAAchB,GAAYzO,GAC1Bya,EAAehL,EAAYvD,OAAO1P,OAExC,GAAIie,EASH,KARA5V,EAASA,EAAOjE,SACLpE,OAASie,IAGnB5V,EAASA,EAAOjE,MAAM,EAAG6Z,EAAe,GACtCvc,OAAO2G,EAAOjE,MAAM6Z,EAAe,GAAGtc,KAAK,QAGvC0G,EAAOrI,QAAQ,CACrBvE,IAAMuC,EAAQqK,EAAO6V,QACfzO,EAAQwD,EAAYvD,OAAOwO,QAC3BC,EAAQngB,EAAMgC,OAASyP,EAAMzP,OAEnCiT,EAAYzP,OAASyP,EAAYzP,OAAOY,MAAM,EAAGqL,EAAMP,UACpDlR,EACAiV,EAAYzP,OAAOY,MAAMqL,EAAMP,SAAWO,EAAMzP,QAGnD,IAAKvC,IAAI8B,EAAI,EAAG6G,EAAK6M,EAAYvD,OAAO1P,OAAQT,EAAI6G,EAAI7G,IACvD0T,EAAYvD,OAAOnQ,GAAG2P,UAAYiP,EAKrC,OAAOlL,EAzDGmL,CAAapgB,EADD8D,EAAKzD,WAAW8E,aAAIpE,UAAQif,GAAejf,EAAMgf,OAmBtE,OAfA/L,EAAQzU,KAAOuE,EAAK/D,MAAQyV,EAAQzV,KAAK+D,EAAK/D,MAC9CiU,EAAQpB,UAAYmN,EAAUF,QAC9B7L,EAAQzB,KAAOyB,EAAQR,aAAaxT,GAAS,OAEzCgU,EAAQzU,MAAUyU,EAAQzB,MAASyB,EAAQzB,KAAK8N,SAAS,OAC5DrM,EAAQhB,UAAY+M,EAAUnY,OAG3B4N,EAAQrL,IAAI,YACf6J,EAAQd,QAAU,KACdrK,EAAK1G,YAAc2B,IACtBkQ,EAAQhB,WAAagB,EAAQd,UAIxBc,IA0CT,SAASgM,GAAelc,EAAM7F,GAC7B,OAAI6F,EAAK9D,OAA+B,iBAAf8D,EAAK9D,OAA0C,cAApB8D,EAAK9D,MAAMqZ,KACvDvV,EAAK9D,MAAMA,MACjBmF,aAAI3B,GACJ,OAAIA,GAA0B,iBAAVA,EACG,UAAfA,EAAM6V,KACV7V,EAAMyB,SAAShH,EAAQ2hB,UACvBpc,EAAMyB,WAGHrF,OAAO4D,KAEdG,KAAK,KAGc,MAAdG,EAAK9D,MAAgBJ,OAAOkE,EAAK9D,OAAS,GAGlDvC,IAAM6iB,IACLR,KACCD,QAAS,KACTjY,MAAO,KAER2Y,KAAM,MACNC,KAAM,MACNC,MACCZ,QAAS,KACTjY,MAAO,IAER8Y,QACCb,QAAS,IACTjY,MAAO,KAsBT,SAASe,GAAME,EAAM2M,EAAS0D,EAAQjb,GAiBrC,MAhBsB,iBAAXib,IACVjb,EAAUib,EACVA,EAAS,MAsBX,SAAkBA,GACjB,QAASA,GAAUA,KAAUoH,GApBxBnH,CAASD,KAEbA,EAAS,OASH4G,GAAIjX,EAAM2M,EANjBvX,EAAUC,OAAOC,UAAWF,GAC3BuZ,OAuBF,SAAmB0B,EAAQjb,GAC1BwB,IAAI+X,EAAS8I,GAAapH,GACJ,iBAAX1B,IACVA,EAAS8I,GAAa9I,IAGvB,OAAOtZ,OAAOC,UAAWqZ,EAAQvZ,GAAWA,EAAQuZ,QA7B3CmJ,CAAUzH,EAAQjb,MCxJ5B,IAwYI0K,UAvYHuB,EAAK,UACL0W,SAAU,wBACVC,SAAU,wBACVC,QAAS,sBACTlY,KAAQ,cACRmY,cAAe,iBACfvH,KAAQ,cACRwH,SAAY,YACZC,GAAM,MACNC,MAAS,SACTC,GAAM,MACNC,IAAO,WACPC,QAAS,eACTC,QAAS,eACTC,IAAO,OACPC,KAAQ,6BACRC,WAAY,8BACZC,aAAc,0CACdC,eAAgB,sEAChBC,aAAc,qDACdC,WAAY,6EACZC,YAAa,gFACbC,sBAAuB,8CACvBC,KAAQ,QACRC,WAAY,kEACZC,UAAW,gFACXC,cAAe,uDACfC,YAAa,sCACbC,gBAAiB,oEACjBC,MAAS,QACTC,OAAU,eACVC,aAAc,cACdC,IAAO,gBACPC,mBAAoB,sBACpBC,kBAAmB,4BACnBC,QAAW,UACXC,aAAc,UACdC,oBAAqB,mBACrBC,sBAAuB,iBACvBC,oBAAqB,oCACrBC,qBAAsB,uBACtBC,qBAAsB,4CACtBC,2BAA4B,mCAC5BC,4BAA6B,6BAC7BC,2BAA4B,0CAC5BC,OAAU,4BACVC,MAAS,mBACT/X,OAAU,oBACVgY,MAAS,qBACTre,IAAO,YACPse,KAAQ,+BACRC,SAAU,sBACVC,SAAU,qBACVC,SAAU,mBACVC,SAAU,mBACVC,KAAQ,eACRC,WAAY,mBACZC,YAAa,oBACbC,MAAS,aACTC,MAAS,yBACTC,IAAO,2BACPC,uBAAwB,0BACxBC,qBAAsB,iBACtBC,eAAgB,mBAChBC,cAAe,kBACfC,YAAa,gBACbC,yBAA0B,qBAC1BC,iBAAkB,qBAClBC,aAAc,iBACdC,uBAAwB,2BACxBC,cAAe,kBACfC,aAAc,iBACdC,aAAc,iBACdC,YAAa,gBACbC,eAAgB,mBAChBC,cAAe,kBACfC,yBAA0B,qBAC1BC,sBAAuB,kBACvBC,cAAe,kBACfC,qBAAsB,iBACtBC,uBAAwB,2BACxBC,sBAAuB,4BACvBC,uBAAwB,2BACrBC,cAAe,2BAClBC,QAAW,WACXva,OAAU,4BACVwa,2BAA4B,oBAC5BC,aAAc,gBACdC,SAAY,wDACZC,QAAW,8BACXC,sBAAuB,qBACvBC,sBAAuB,qBACvB1a,MAAS,aACTD,MAAS,aACT4a,WAAY,2CACZC,OAAU,UACVC,QAAW,WACXC,+BAAiC,sBACjCC,8BAAgC,qBAChCC,iCAAmC,oBACnCC,4CAA8C,sBAE9CC,GAAM,aACNC,IAAO,SACPC,KAAQ,aACRC,IAAO,UACPC,IAAO,SACPC,IAAO,QACPC,IAAO,SACPC,IAAO,UACPC,KAAQ,WACRC,IAAO,WACPC,IAAO,SACPC,KAAQ,WACRC,MAAS,WACTC,IAAO,SACPC,KAAQ,UACRC,IAAO,UACPC,IAAO,SACPC,IAAO,SACPC,IAAO,UACPC,IAAO,SACPzmB,IAAO,SACP0mB,KAAQ,WACRC,GAAM,OACNC,IAAO,WACPC,KAAQ,WACRC,MAAS,WACTC,MAAS,WACTC,GAAM,SACNtmB,IAAO,SACPumB,IAAO,UACPC,IAAO,UAEPC,cAAe,QACfC,mBAAoB,QACpBC,cAAe,gBACfC,eAAgB,gBAEhBC,MAAO,oBACPC,IAAO,iGACPC,WAAY,UAEZC,EAAK,wBACLC,QAAS,uCACTC,UAAW,gEAIXC,KAAM,2DACNC,MAAO,kXACPC,aAAc,qBACdC,MAAO,0CACPC,YAAa,kCACbC,GAAM,8EACNC,GAAM,0DACNC,KAAQ,uHACRC,QAAW,4BACXC,QAAW,iEACXC,QAAW,6BACXC,OAAU,8CACVC,OAAU,uCACVC,MAAS,iBACTC,OAAU,sCACVC,OAAU,0HACVC,GAAM,kBACNC,GAAM,8DACN5X,EAAK,SACL6X,GAAM,uCACNC,IAAO,8CACPC,KAAQ,gCACRC,KAAQ,gCACRC,KAAQ,qBACRC,MAAS,8CACTC,OAAU,4BACVC,MAAS,+CACTC,OAAU,6BACVC,KAAQ,sBACRC,KAAQ,sBACRC,IAAO,yBACPC,KAAQ,yCACRC,KAAQ,oCACRC,IAAO,gEACPC,IAAO,yBACPC,IAAO,4CACPC,KAAQ,8BACRC,MAAS,gBACTC,KAAQ,8BACRC,KAAQ,oBACRC,KAAQ,oBACRC,IAAO,6CACPC,KAAQ,+BACRC,KAAQ,+BACRC,KAAQ,gBACRC,MAAS,qBACTC,KAAQ,qBACRC,IAAO,2GACPC,KAAQ,iBACRC,IAAO,2CACPC,KAAQ,6BACRC,KAAQ,6BACRC,MAAS,2CACTC,OAAU,yBACVC,MAAS,4CACTC,OAAU,0BACVC,KAAQ,mBACRC,KAAQ,mBACRC,IAAO,eACPC,IAAO,qCACPC,GAAM,uBACNC,IAAO,qCACPC,KAAQ,oDACRC,IAAO,6BACPC,KAAQ,6DACRC,IAAO,6BACPC,IAAO,uDACPC,IAAO,oCACPC,KAAQ,wBACRC,KAAQ,wBACRC,IAAO,4DACPC,KAAQ,gCACRC,KAAQ,qEACRC,KAAQ,+CACR3E,EAAK,kBACLlZ,GAAM,6BACN8d,GAAM,aACNC,IAAO,oHACPC,IAAO,oBACPC,KAAQ,UACRC,MAAS,eACTC,MAAS,cACTC,MAAS,aACTC,MAAS,cACTC,OAAU,oBACVC,OAAU,oBACVC,OAAU,oBACVC,MAAS,cACTC,MAAS,eACTC,IAAO,gBACPC,GAAM,4DACNC,IAAO,0BACPlR,IAAO,oEACPmR,EAAK,wRACLC,GAAM,wBACNC,EAAK,gCACLC,IAAO,0CACPC,IAAO,iBACPC,KAAQ,uCACRC,KAAQ,mDACRC,GAAM,yDACNC,GAAM,wBACNC,GAAM,mCACNC,IAAO,uDACPjI,IAAO,oIACPkI,GAAM,iCACNC,GAAM,yCACNC,GAAM,OACNC,IAAO,8DACPC,IAAO,uDACPC,IAAO,YACPC,IAAO,YACPC,KAAQ,cACRC,IAAO,qCACPC,GAAM,YACNC,IAAO,mBACPC,EAAK,SACLC,GAAM,wEACNC,EAAK,OACLC,GAAM,yCACNC,GAAM,cACNC,IAAO,aACPC,KAAQ,mBACRC,KAAQ,qCACRC,KAAQ,0FACRC,IAAO,wBACPzgB,EAAK,SACL0gB,IAAO,aACPC,IAAO,iBACPC,IAAO,YACPC,GAAM,gBACNC,IAAO,aACPC,IAAO,iBACPC,IAAO,YACPC,GAAM,cACNC,GAAM,eACNC,GAAM,aACNrmB,GAAM,UACNsmB,IAAO,iCACPC,IAAO,iBACPC,IAAO,0EACPC,IAAO,kCACPC,GAAM,UACNC,IAAO,QACPC,IAAO,iCACPC,IAAO,UACPC,GAAM,6CACNC,IAAO,8DACPC,IAAO,+CACPC,IAAO,+CACPnnB,EAAK,UACLonB,GAAM,iBACNC,KAAQ,0CACRC,KAAQ,2CACRC,KAAQ,+BACRC,GAAM,eACN9zB,IAAO,mDACP+zB,GAAM,gBACNC,GAAM,cACNC,EAAK,SACLC,IAAO,6CACPC,IAAO,6CACPpmB,EAAK,QACLqmB,IAAO,uCACPC,EAAK,MACLC,GAAM,uCACNC,IAAO,oCACPC,IAAO,qBACPC,GAAM,uDACNC,GAAM,yDACNC,GAAM,gDACNC,GAAM,cACNC,GAAM,wFACNj0B,GAAM,uCACNk0B,IAAO,8BACPpoB,GAAM,eACNqoB,IAAO,iWACPC,KAAQ,mBACRC,KAAQ,8BACRC,IAAO,iCACPC,MAAS,6BACTC,MAAS,gCACTC,KAAQ,gCACRC,MAAS,qCACTC,IAAO,sDACPC,GAAM,qDACNC,GAAM,8CACNC,GAAM,mBACN3iB,EAAK,qCACL4iB,GAAM,2EACNC,EAAK,QACLC,IAAO,kDACPC,KAAQ,oEACRC,IAAO,SACPC,GAAM,qEACNC,IAAO,uCACPC,IAAO,eACPC,IAAO,yDACPC,EAAK,UACLC,IAAO,eAIJC,YAAa,2BACbC,WAAY,qBACZC,KAAQ,0BACR7K,GAAM,mCACN8K,IAAO,oBACPC,IAAO,mBACPC,IAAO,oBACPt1B,GAAM,aACNu1B,cAAe,iBACfC,GAAM,gBACNC,GAAM,eACNC,IAAO,kBACPC,KAAQ,yBACRC,IAAO,qBACPC,KAAQ,4BACRC,GAAM,8BACNnlB,IAAO,0BACPolB,KAAQ,oBACR10B,KAAQ,sBACRmE,MAAS,0BACTqpB,GAAM,mBACNmH,GAAM,sBACNC,IAAO,uBACPC,WAAY,uBACZC,IAAO,WACPC,IAAO,cACPC,IAAO,4BACPC,KAAQ,eACRhc,IAAO,oBACPic,IAAO,mDACPC,KAAQ,+BACRC,MAAS,4BACTC,KAAQ,mCACRhkB,KAAQ,yBACRikB,OAAU,oCACVC,IAAO,uFACP5N,MAAO,6CCnSL6N,WA/FLC,QAAW,QAAS,QAAS,QAAS,MAAO,OAAQ,cAAe,cAAe,QACnFC,OAAU,iBAAkB,cAAe,eAAgB,UAAW,UACrE,OAAQ,OAAQ,MAAO,QAAS,MAAO,MAAO,WAAY,YAC1D,OAAQ,cAAe,QAAS,MAAO,WAAY,MAAO,WAC1D,SAAU,MAAO,OAAQ,UAAW,UAAW,cAC/C,UAAW,QAAS,QAAS,WAAY,QAAS,OAAQ,QAC1D,OAAQ,QAAS,SAAU,WAAY,QAAS,OAAQ,QACxD,QAAS,QAAS,QAAS,OAAQ,MAAO,KAAM,KAAM,eACtD,UAAW,YAAa,UAAW,YAAa,WAAY,UAC5D,UAAW,UAAW,OAAQ,YAAa,cAAe,MAC1D,iBAAkB,WAAY,WAAY,SAAU,WACpD,WAAY,UAAW,OAAQ,cAAe,OAAQ,WACtD,YAAa,MAAO,aAAc,aAAc,SAAU,OAC1D,MAAO,UAAW,QAAS,QAAS,SAAU,OAAQ,QACtD,aAAc,WAAY,YAAa,QAAS,UAAW,SAC3D,UAAW,cAAe,QAAS,YAAa,QAAS,OACzD,QAAS,WAAY,UAAW,OAAQ,aAAc,UACtD,YAAa,QAAS,UAAW,OAAQ,aAAc,YACvD,QAAS,aAAc,QAAS,QAAS,UAAW,aAAc,KAClE,OAAQ,OAAQ,WAAY,OAAQ,aAAc,QAAS,WAC3D,aAAc,QAAS,eAAgB,MAAO,aAC9C,YAAa,YAAa,KAAM,QAAS,QAAS,QAAS,OAC3D,KAAM,KAAM,OAAQ,QAAS,UAAW,KAAM,KAAM,KAAM,OAC1D,gBAAiB,UAAW,OAAQ,SAAU,MAAO,YACrD,SAAU,cAAe,SAAU,aAAc,OAAQ,YACzD,aAAc,UAAW,cAAe,aAAc,UACtD,QAAS,QAAS,SAAU,aAAc,WAAY,SACtD,aAAc,MAAO,OAAQ,WAAY,QAAS,IAAK,YACvD,MAAO,QAAS,SAAU,UAAW,WAAY,QAAS,SAC1D,SAAU,iBAIXD,QAAW,gBAAiB,KAAM,aAAc,SAAU,WAAY,UAAW,cAAe,QAAS,SAAU,UACnHC,OAAU,QAAS,UAAW,MAAO,YAAa,QAAS,YAAa,YACvE,WAAY,YAAa,SAAU,YAAa,SAAU,OAC1D,SAAU,UAAW,eAAgB,KAAK,QAAS,eACnD,YAAa,MAAO,oBAAqB,SAAU,UAAW,WAC9D,cAAe,WAAY,QAAS,MAAO,OAAQ,aACnD,aAAc,KAAM,QAAS,SAAU,MAAO,UAAW,WACzD,WAAY,mBAAoB,QAAS,QAAS,UAAW,OAC7D,YAAa,UAAU,UAAW,SAAU,QAAS,QAAS,QAC9D,SAAU,QAAS,UAAW,MAAO,aAAc,UAAW,UAC9D,eAAgB,IAAK,OAAQ,UAAW,QAAS,SAAU,UAC3D,WAAY,SAAU,UAAW,KAAM,QAAS,MAAO,QACvD,OAAQ,QAAS,KAAM,SAAU,OAAQ,QAAS,YAAa,OAC/D,YAAa,UAAW,KAAM,OAAQ,WAAY,SAClD,cAAe,SAAU,UAAW,YAAa,MAAO,SACxD,YAAa,SAAU,QAAS,SAAU,SAAU,UAAW,SAC/D,YAAa,YAAa,UAAW,UAAW,eAAgB,SAChE,WAAY,WAAY,eAAgB,SAAU,WAAY,MAC9D,OAAQ,YAAa,OAAQ,OAAQ,SAAU,WAAY,WAC3D,MAAO,eAAiB,OAAQ,MAAO,iBAAkB,YACzD,MAAO,eAAgB,MAAO,OAAQ,WAAY,MAAO,YACzD,cAAe,KAAM,QAAS,OAAQ,aAAc,SAAU,eAC9D,WAAY,MAAO,YAAa,OAAQ,OAAQ,SAAU,MAC1D,eAAgB,WAAY,cAAe,YAAa,UACxD,YAAa,SAAU,QAAS,aAAc,OAAQ,YACtD,UAAW,eAAgB,QAAS,QAAS,QAAS,WACtD,OAAQ,aAAc,KAAM,QAAS,MAAO,KAAM,MAAO,YAI1DD,QAAW,QAAS,MAAO,QAAS,MAAO,KAAM,QAAS,QAAS,MACnEC,OAAU,YAAa,cAAe,cAAe,UAAW,OAC/D,WAAY,QAAS,UAAW,YAAa,QAAS,QAAS,aAAc,YAC7E,OAAQ,eAAgB,OAAQ,OAAQ,YAAa,OAAQ,SAC7D,SAAU,KAAM,OAAQ,WAAY,SAAU,YAC9C,YAAa,QAAS,YAAa,aAAc,OAAQ,WAAY,SACrE,OAAQ,SAAU,OAAQ,QAAS,UAAW,OAAQ,YACtD,QAAS,SAAU,UAAW,QAAS,MAAO,KAAM,IAAK,aACzD,eAAgB,WAAY,WAAY,WAAY,YAAa,WACjE,WAAY,WAAY,OAAQ,WAAY,eAAgB,QAC5D,iBAAkB,aAAc,aAAc,UAAW,SACzD,UAAW,SAAU,SAAU,YAAa,QAAS,YACrD,UAAW,QAAS,eAAgB,QAAS,aAAc,SAC3D,MAAO,QAAS,WAAY,QAAS,aAAc,QAAS,UAC5D,cAAe,cAAe,QAAS,UAAW,cAAe,SACjE,UAAW,aAAc,QAAS,WAAY,UAAW,SACzD,QAAS,YAAa,SAAU,SAAU,aAAc,UACxD,UAAW,SAAU,YAAa,cAAe,WAAY,YAC7D,YAAa,aAAc,OAAQ,WAAY,QAAS,QAAS,IACjE,UAAW,YAAa,WAAY,OAAQ,aAAc,SAAU,WACpE,iBAAkB,WAAY,aAAc,OAAQ,gBACpD,eAAgB,QAAS,IAAK,WAAY,QAAS,QAAS,SAC5D,SAAU,aAAc,OAAQ,YAAa,SAAU,KAAM,WAAY,MAAO,MAChF,YAAa,UAAW,SAAU,YAAa,QAAS,WACxD,UAAW,YAAa,QAAS,WAAY,SAAU,YACvD,SAAU,WAAY,SAAU,aAAc,YAC9C,MAAO,aAAc,UAAW,WAAY,UAAW,WACvD,aAAc,UAAW,OAAQ,aAAc,OAAQ,IAAK,YAC5D,WAAY,QAAS,OAAQ,UAAW,aAAc,UAAW,OACjE,SAAU,cAKN74B,IACL84B,UAAW,GACXC,YAAY,EACZC,KAAM,SASHjuB,GAAQ,SAAS7E,EAAM7F,GAC1BA,EAAUC,OAAOC,UAAWP,GAAgBK,GAC5CR,IAAMo5B,EAAON,GAAMt4B,EAAQ24B,OAASL,GAAMO,MACjCC,GAAmB94B,EAAQ04B,aAkIrC,SAAqB7yB,GACjB,KAAOA,EAAKrD,QAAQ,CAChB,GAAIqD,EAAKxD,QAAUwD,EAAKxD,OAAON,OAAS8D,EAAKxD,OAAON,MAAQ,EACxD,OAAO,EAGX8D,EAAOA,EAAKrD,OAGhB,OAAO,EA3IyCu2B,CAAYlzB,GAa/D,OAXKA,EAAKxD,QAcX,SAAgBwD,GACf,OAAQA,EAAKrD,OAfQqU,CAAOhR,EAAKrD,SAOhCqD,EAAK9D,MAAQi3B,GAAUJ,EAAM54B,EAAQy4B,UAAWK,GAChDjzB,EAAK/D,KAAO+D,EAAKrD,OAAOV,KAAO8L,EAAmB/H,EAAKrD,OAAOV,MAAQ,OALtE+D,EAAKrD,OAAOT,MAAQi3B,GAAUJ,EAAM54B,EAAQy4B,UAAWK,GACvDjzB,EAAKO,UAOCP,GAaR,SAASozB,GAAKl4B,EAAMC,GACnB,OAAOuZ,KAAK2e,MAAM3e,KAAK4e,UAAYn4B,EAAKD,GAAQA,GAQjD,SAASq4B,GAAO71B,EAAK8D,GAKpB,IAJA7H,IAAMwO,EAAMzK,EAAIQ,OACVs1B,EAAa9e,KAAK+e,IAAItrB,EAAK3G,GAC3ByB,EAAS,IAAIsC,IAEZtC,EAAOiF,KAAOsrB,GACpBvwB,EAAO0C,IAAIjI,EAAI01B,GAAK,EAAGjrB,KAGxB,OAAOrL,MAAM5B,KAAK+H,GAOnB,SAASywB,GAASf,EAAOhxB,GAQzB,IAAoBgyB,EAZJ9B,EASf,OAJIc,EAAMz0B,SACTy0B,IAMkBgB,EANEhB,EAAM,GAOpBgB,EAAK,GAAGtf,cAAgBsf,EAAKrxB,MAAM,KAPV1C,OAAO+yB,EAAMrwB,MAAM,KAG5CqwB,EAAM9yB,KAAK,MAAQ8B,IATXkwB,EASyB,SAR7BuB,GAAK,EAAGvB,EAAI3zB,OAAS,KAoBjC,SAAS01B,GAAajB,GACrB,GAAIA,EAAMz0B,OAAS,EAClB,OAAOy0B,EAIRh5B,IAAMwO,GADNwqB,EAAQA,EAAMrwB,SACIpE,OACZ21B,EAAW,KACbC,EAAc,EAGjBA,EADG3rB,EAAM,GAAKA,GAAO,EACPirB,GAAK,EAAG,GACZjrB,EAAM,GAAKA,GAAO,GACdirB,GAAK,EAAG,GAERA,GAAK,EAAG,GAGvB,IAAKz3B,IAAI8B,EAAI,EAAGlD,SAAWkD,EAAIq2B,EAAar2B,IAC3ClD,EAAM64B,GAAK,EAAGjrB,EAAM,GACf0rB,EAASlwB,KAAKgvB,EAAMp4B,MACxBo4B,EAAMp4B,IAAQ,KAIhB,OAAOo4B,EAWR,SAASQ,GAAUJ,EAAMH,EAAWK,GACnCt5B,IAEIg5B,EAFE1vB,KACF8wB,EAAa,EASjB,IANId,GAAmBF,EAAKL,SAE3BqB,IADApB,EAAQI,EAAKL,OAAOpwB,MAAM,EAAGswB,IACT10B,OACpB+E,EAAOjE,KAAK00B,GAASE,GAAajB,GAAQ,OAGpCoB,EAAanB,GAEnBmB,IADApB,EAAQY,GAAOR,EAAKJ,MAAOje,KAAK+e,IAAIL,GAAK,EAAG,IAAKR,EAAYmB,KACzC71B,OACpB+E,EAAOjE,KAAK00B,GAASE,GAAajB,KAGnC,OAAO1vB,EAAOpD,KAAK,KC5OpB,IAAMm0B,GACF,SAAYznB,EAAKrQ,GACjBC,KAASoQ,IAAMA,EACfpQ,KAASD,MAAQA,GAIf+3B,GACF,SAAYvjB,GACZvU,KAAS+3B,QAAU,IAAIhuB,IACvB/J,KAASg4B,QAAU,IAAIjuB,IACvB/J,KAASi4B,WAAY,EAErBj4B,KAASk4B,KAAK3jB,uCAGV4jB,wBACJ,OAAWn4B,KAAKi4B,WAOpBH,aAAIM,mBACAp4B,KAASi4B,WAAY,GAMzBH,aAAIO,kBACAr4B,KAASi4B,WAAY,GAQzBH,aAAI9tB,aAAIoG,EAAKrQ,cACT,GAAuB,iBAARqQ,EACXA,EAAQ5N,MAAM,KAAK3B,iBAAQy3B,UAAKt4B,EAAK+3B,QAAQ/tB,IAAIsuB,EAAG,IAAIT,GAAQS,EAAGv4B,UAC5D,CAAA,KAAIqQ,aAAemoB,QAG1B,MAAU,IAAIr0B,MAAM,uBAAyBkM,GAF7CpQ,KAASg4B,QAAQhuB,IAAIoG,EAAK,IAAIynB,GAAQznB,EAAKrQ,IAK/C,OAAWC,MASf83B,aAAI5tB,aAAIkG,GACJ,IAAQpQ,KAAKm4B,SAAb,CAIA,GAAQn4B,KAAK+3B,QAAQxuB,IAAI6G,GACrB,OAAWpQ,KAAK+3B,QAAQ7tB,IAAIkG,GAIhC,IADA,IAAUxI,EAAOjH,MAAM5B,KAAKiB,KAAKg4B,QAAQpwB,QAC5BtG,EAAI,EAAG6G,EAAKP,EAAK7F,OAAQT,EAAI6G,EAAI7G,IAC1C,GAAQsG,EAAKtG,GAAGkG,KAAK4I,GACjB,YAAgB4nB,QAAQ9tB,IAAItC,EAAKtG,MAS7Cw2B,aAAII,cAAK3jB,cACLvU,KAASw4B,QACDjkB,aAAgBxK,IACpBwK,EAAS1T,iBAASd,EAAOqQ,UAAQpQ,EAAKgK,IAAIoG,EAAKrQ,KACpCwU,GAAwB,iBAATA,GAC1BtW,OAAW2J,KAAK2M,GAAM1T,iBAAQuP,UAAOpQ,EAAKgK,IAAIoG,EAAKmE,EAAKnE,OAOhE0nB,aAAIU,iBACAx4B,KAAS+3B,QAAQU,QACjBz4B,KAASg4B,QAAQS,SAMrBX,aAAI1tB,kBACA,GAAQpK,KAAKm4B,SACT,SAGJ,IAAU5yB,EAAS5E,MAAM5B,KAAKiB,KAAK+3B,QAAQ3tB,UACjCsuB,EAAS/3B,MAAM5B,KAAKiB,KAAKg4B,QAAQ5tB,UAC3C,OAAW7E,EAAO9B,OAAOi1B,6CAS7B,IAAMC,GAMF,SAAYpkB,cACZvU,KAAS44B,aAEDj4B,MAAMC,QAAQ2T,GAClBA,EAAS1T,iBAASsc,EAAU9G,UAAUrW,EAAKwJ,IAAI6M,EAAO8G,KAC3B,iBAAT5I,GAClBvU,KAASwJ,IAAI+K,IASrBokB,aAAIzuB,aAAImM,GACJ,QAAa/U,EAAI,EAAGA,EAAItB,KAAK44B,UAAU72B,OAAQT,IAAK,CAChD,IAAUD,OAAYu3B,UAAUt3B,GAChC,GAAQD,EAAKgV,QAAUA,EACnB,OAAWhV,EAAKw3B,QAY5BF,aAAInvB,aAAI6M,EAAO8G,GACM,MAAT9G,GAAkC,iBAAVA,IAC5B8G,EAAe9G,EACfA,EAAY,GAGhB,IAAUwiB,EAAQ,IAAIf,GAAgB3a,GAQtC,OALAnd,KAASoE,OAAOiS,GAEhBrW,KAAS44B,UAAU/1B,YAAMwT,QAAOwiB,IAChC74B,KAAS44B,UAAUzmB,cAAMlI,EAAGmI,UAAMA,EAAEiE,MAAQpM,EAAEoM,QAEnCwiB,GAOfF,aAAIv0B,gBAAOmQ,GACPvU,KAAS44B,UAAY54B,KAAK44B,UACrBn2B,gBAAOpB,UAAQA,EAAKgV,QAAU9B,GAAQlT,EAAKw3B,QAAUtkB,KAQ9DokB,aAAItvB,iBAAQvJ,GACR,QAAawB,EAAI,EAAGA,EAAItB,KAAK44B,UAAU72B,OAAQT,IAAK,CAChD,IAAUgI,OAAesvB,UAAUt3B,GAAGu3B,MAAM3uB,IAAIpK,GAChD,GAAQwJ,EACJ,OAAWA,IAavBqvB,aAAIla,aAAIzgB,GACJA,EAAcA,MACd,IAAU8I,EAAS,IAAIiD,IAEb+uB,WAAaxvB,GACnB,IAAU8P,EAAO9P,EAAQ8G,eAAemoB,OAAS,SAAW,SAClDv6B,EAAQob,MAAQpb,EAAQob,OAASA,GAAUtS,EAAOyC,IAAID,EAAQ8G,MACpEtJ,EAAWkD,IAAIV,EAAQ8G,IAAK9G,IAQpC,OAJAtJ,KAAS44B,UAAU/3B,iBAAQQ,GACvBA,EAASw3B,MAAMzuB,SAASvJ,QAAQi4B,KAGzBn4B,MAAM5B,KAAK+H,EAAOsD,WAMjCuuB,aAAIF,iBACAz4B,KAAS44B,UAAU72B,OAAS,GC3NhC,IAAIpE,IACHqV,OAAQ,KACR+lB,QAAS,GACTC,cAAe,GACfC,gBAAiB,SACjB1hB,QAAQ,EACR2hB,YAAa,QACbC,aAAc,QACdC,YAAa,EACbC,0BAA0B,EAC1BC,mBAAoB,kBAAmB,WAAY,QAAS,YAC3D,WAAY,UAAW,WAAY,QAAS,WAAY,iBACxD,SAAU,QAAS,OAAQ,WAAY,QAAS,aAAc,WAC9D,WAAY,WAAY,WAAY,iBACrCC,iBAAkB,OAClB/uB,gBAAiB,IAAK,OAAQ,UAAW,SAAU,IAAK,WAAY,MACnE,MAAO,KAAM,SAAU,OAAQ,OAAQ,MAAO,MAAO,KAAM,OAAQ,IACnE,SAAU,MAAO,QAAS,MAAO,MAAO,QAAS,MAAO,SAAU,IAClE,IAAK,OAAQ,SAAU,QAAS,OAAQ,SAAU,SAAU,MAAO,MACnE,WAAY,KAAM,IAAK,QAMnBgvB,GAIF,SAAYx7B,GAEfgC,KAAMhC,QAAUC,OAAOC,UAAWP,GAAgBK,GAClDgC,KAAMy5B,UAA6C,WAAjCz5B,KAAKhC,QAAQi7B,gBAA+B,IAAO,KAoGtE,SAASS,GAAQn0B,EAAQ6T,GACrB,OAAIA,EACgB,UAATA,EAAmB7T,EAAO2S,cAAgB3S,EAAOmG,cAGrDnG,ECxGX,SAAS0D,GAAMN,EAAMgxB,GACpB,OAAOC,EAAkBjxB,GACvB/D,IAAIi1B,EAAiBF,EAAOxc,UAC5BvY,IAAIk1B,GAAkBH,EAAOnpB,WAC7B5L,IAAIm1B,GAAWJ,EAAOrnB,KAAMqnB,EAAO37B,SA0BtC,SAASg8B,GAAQrxB,EAAMgxB,GAKtB,MAJoB,iBAAThxB,IACVA,EPmWF,SAAeA,GAId,IAHAnL,IAAMqL,EAAO,IAAI1I,EACXpC,EAAS,IAAIuH,EAAaqD,IAExB5K,EAAOU,OAAO,CACrBe,IAAIqE,EAAO,IAAI1D,EAAKic,GAAare,IACjC8F,EAAK9D,MAAQwc,GAAaxe,GAE1BP,IAAMqH,EAAO4W,GAAoB1d,GACjC,GAAI8G,EAIH,IAAKrF,IAAI8B,EAAI,EAAGA,EAAIuD,EAAK9C,OAAQT,IAChCuC,EAAK9C,aAAapB,OAAO2B,GAAIuD,EAAKvD,IAYpC,GAPIvD,EAAOQ,IAAIyI,KACdnD,EAAK9D,MAAMyJ,IAAI,KAGhBX,EAAKjF,YAAYC,IAGZ9F,EAAOQ,IAAI0d,IACf,MAIF,IAAKle,EAAOU,MACX,MAAMV,EAAOY,MAAM,wBAGpB,OAAOkK,EOtYCoxB,CAAoBtxB,IAGrBA,EAAK/D,IAAIs1B,GAAmBP,EAAOxc,SAAUwc,EAAO37B,SD5B5Dw7B,aAACtvB,aAAIpK,GACJ,OAAQE,KAAKhC,QAAQ8B,iBAQlBzB,eAAM6C,GACF,SAAUlB,KAAc,WAAU,MAAPkB,EAAcA,EAAM,IAAKlB,KAAc,wBAQtEF,cAAKA,GACD,OAAO45B,GAAQ55B,EAAME,KAAKhC,QAAQ+6B,uBAQtCriB,mBAAU5V,GACN,OAAO44B,GAAQ54B,EAAMd,KAAKhC,QAAQg7B,6BAQtCmB,4BAAmBr5B,GACf,OAAOA,EAAK9C,QAAQ6D,UACsD,IAA5E7B,KAAKkK,IAAI,qBAAqB1I,SAASV,EAAKhB,MAAQ,IAAI4L,gBAO9D8tB,aAAC/iB,qBACA,OAASzW,KAAKhC,QAAQu7B,kBACrB,IAAM,QAAS,MAAO,KACtB,IAAM,MAAS,MAAO,IACtB,QAAe,MAAO,KASxBC,aAACxmB,gBAAOqD,GACPA,EAASA,GAAS,EAElB,IADA,IAAKtF,EAAS,GACNsF,KACPtF,QAAgB/S,QAAQgV,OAGzB,OAAQjC,GAQTyoB,aAAChkB,kBAAS3R,GACF,MAAoB,iBAATA,GAC4D,IAA5D7D,KAAKkK,IAAI,kBAAkB1I,QAAQqC,EAAK6H,eAI/B,MAAb7H,EAAK/D,KAAeE,KAAKwV,SAAS3R,EAAK/D,MAAQ+D,EAAK7B,YASnEw3B,aAAChoB,eAAM9I,EAAO6E,GACb,OAAQvN,KAAKhC,QAAQwT,MAAM9I,EAAO6E,IC1DnC/P,IAAM48B,GAAU,wBAyChB,SAASC,GAAex2B,GACvBrG,IAAMQ,KACA8R,EAAIjM,EAAK/D,KAAK8F,MAAMw0B,IAS1B,OARItqB,EAAE,KACL9R,EAAQ24B,KAAO7mB,EAAE,IAGdA,EAAE,KACL9R,EAAQy4B,WAAa3mB,EAAE,IAGjBwqB,GAAMz2B,EAAM7F,GAOpBR,IAAM+8B,IACL5D,KAAM,KACN6D,OAAQ,QACRC,QAAS,SAQJC,IAAsB,MAAO,OAAQ,OAAQ,OAAQ,SAAU,OAE/D/8B,IAKLyb,KAAM,KAMNH,OAAQ,OAcRzH,eAAQ9I,EAAO6E,UAAgBA,GAAe,IAQ9C+E,KAAM,KAONiD,QAAS,KAOT/E,aAWA2M,YAeAnf,QAAS,KAOTuZ,OAAQ,MAWT,SAASojB,GAAShyB,EAAMgxB,GAGvB,MAA+C,eAAxCiB,IAFPjB,EAASkB,GAAclB,IAEDvgB,KAAMugB,EAAO1gB,QA/LpC,SAAkBtQ,EAAMgxB,GAOvB,OANAA,EAASA,MAEW,iBAAThxB,IACVA,EAAOqxB,GAAQrxB,EAAMgxB,IAGfmB,GAASnyB,EAAMgxB,EAAOpkB,QAASokB,EAAO1gB,OAAQ0gB,GAyLlDoB,CAASpyB,EAAMgxB,GA9NnB,SAAgBhxB,EAAMgxB,GAOrB,OANAA,EAAS17B,OAAOC,UAAWy7B,GAEP,iBAAThxB,IACVA,EAAOM,GAAMN,EAAMgxB,IAGbpiB,GAAO5O,EAAMgxB,EAAOpkB,QAASokB,EAAO1gB,OAAQ0gB,GAwNhDqB,CAAOryB,EAAMgxB,GA0BjB,SAASsB,GAAuB7hB,EAAMH,EAAQkE,GAQ7C,OANI/D,GAAiB,WAATA,GAA8B,eAATA,IAChC+D,EAAWlE,EACXA,EAASG,EACTA,EAAO,UAGD+D,aAAoBwb,GACxBxb,EAnMJ,SAAiC/D,EAAMH,EAAQkE,GAC9C3f,IAAM09B,KAEO,WAAT9hB,EACH8hB,EAAiBr4B,KAAKs4B,GAAgBC,MACnB,eAAThiB,GACV8hB,EAAiBr4B,KAAKs4B,GAAgBtb,KAGnC5G,KAAUkiB,KAA0E,IAAvDD,EAAiB15B,QAAQ25B,GAAgBliB,KACzEiiB,EAAiBr4B,KAAKs4B,GAAgBliB,IAGnCtY,MAAMC,QAAQuc,GACjBA,EAAStc,iBAAQQ,GAGhB65B,EAAiBr4B,KAAqB,iBAATxB,EAAoB85B,GAAgB95B,GAAQA,KAE5C,iBAAb8b,GACjB+d,EAAiBr4B,KAAKsa,GAGvB3f,IAAM2L,EAAW,IAAIwvB,GAAiBuC,EAAiBz4B,OAAOwN,UAO9D,MAJa,eAATmJ,GACHjQ,EAASe,IAAI,GAAGF,IAAIowB,GAASC,IAGvBlxB,EAsKJkyB,CAAwBjiB,EAAMH,EAAQkE,GAG1C,SAAS0d,GAAc78B,GAetB,MAduB,iBAAZA,IACVA,GAAYib,OAAQjb,IAID,OADpBA,EAAUC,OAAOC,UAAWP,GAAgBK,IAChCob,MAAgBpb,EAAQib,SACnCjb,EAAQob,KAAOkiB,GAAat9B,EAAQib,QAAU,aAAe,UAG9Djb,EAAQuZ,OAAStZ,OAAOC,QAAQsT,MAAOxT,EAAQwT,OAAQxT,EAAQuZ,QAC/DvZ,EAAQuX,QAwBT,SAAuBvX,GACtB,OAAOA,EAAQuX,mBAAmBikB,GAC/Bx7B,EAAQuX,QACR,IAAIikB,GAAQx7B,EAAQuX,SA3BLgmB,CAAcv9B,GAChCA,EAAQwS,UAAYvS,OAAOC,UAAWq8B,GAAkBv8B,EAAQwS,WAChExS,EAAQmf,SAAW8d,GAAuBj9B,EAAQob,KAAMpb,EAAQib,OAAQjb,EAAQmf,UAEzEnf,EAWR,SAASs9B,GAAariB,GACrB,OAA+C,IAAxCyhB,GAAmBl5B,QAAQyX,GAmBnC,SAAS2hB,GAAQxhB,EAAMH,GACtB,OAAIG,EACa,eAATA,EAAwB,aAAe,SAGxCkiB,GAAariB,GAAU,aAAe,SCzU9C,IAAM3T,GACL,SAAYC,EAAQpH,GACpB6B,KAAMuF,OAASA,EACfvF,KAAM7B,MAAQA,GAAS,EACvB6B,KAAM5B,IAAM4B,KAAKuF,OAAOxD,qBAGxBy5B,eACA,OAAQx7B,KAAK5B,MAAQ4B,KAAK7B,oBAG1BG,cAAKyI,GACL,OAAQ/G,KAAKuF,OAAOI,WAAW3F,KAAK5B,IAAM,GAAK2I,GAAU,kBAGzD5C,gBACA,IAAMnE,KAAKw7B,MACV,OAAQx7B,KAAKuF,OAAOI,aAAa3F,KAAK5B,mBAIvCG,aAAIqH,GACJ,GAAK5F,KAAKw7B,MACT,OAAQ,EAGT,IAAO31B,EAAsB,mBAAVD,EACfA,EAAM5F,KAAK1B,QACXsH,IAAU5F,KAAK1B,OAMnB,OAJKuH,GACJ7F,KAAM5B,MAGCyH,gBAGRC,kBAASF,GAET,IADA,IAAOzH,EAAQ6B,KAAK5B,IACZ4B,KAAKzB,IAAIqH,KACjB,OAAQ5F,KAAK5B,IAAMD,GAQpBX,IAAMC,GAAe,GACfC,GAAe,GACfkJ,GAAe,GAOrB,SAASpI,GAAQoqB,GAChB,OAAOA,IAAMnrB,IAAgBmrB,IAAMlrB,GAwBpCF,IAAMi+B,GAAc,EACdC,GAAc,GACdlhB,GAAc,GAEdnJ,GAAc,GACdnK,GAAc,GAShBy0B,GAAc,SAAU59B,GAC3BP,IAAMW,EAAQJ,EAAOK,IAErB,IAAKL,EAAOQ,IAVO,IAWlB,OAAO,EAGRiB,IAAIqG,GAAK,EAGT,IAFA9H,EAAOQ,IAnBY,KAqBXR,EAAOy9B,OAAO,CAGrB,GAFAz9B,EAAO+H,SAAS5G,IAEZ08B,GAAS79B,GAAS,CAGrB,GAAIA,EAAOQ,IA3BM,IA2BM,CAEtBsH,EAAK9H,EAAOQ,IA1BI,IA2BhB,MACM,GAAIR,EAAOQ,IA5BD,IA4BkB,CAElCsH,GAAK,EACL,MACM,GAAI9H,EAAOQ,IAAIW,IAErB,SACM,GAAInB,EAAOQ,IAAI2I,IAAS,CAE9B,GAAI00B,GAAS79B,GACZ,SAED,MACM,GAAI89B,GAA8B99B,GAAS,CAEjD8H,GAAK,EACL,MAID,MAGD,IAAIi2B,GAAa/9B,GAIjB,MAID,OADAA,EAAOK,IAAMD,EACN0H,GAQR,SAASi2B,GAAa/9B,GACrB,OAOD,SAAqCA,GACpCP,IAAMW,EAAQJ,EAAOK,IACrB,GAnGD,SAAmBL,GAClBP,IAAMW,EAAQJ,EAAOK,IACfC,EAAQN,EAAOoG,OAErB,GAAI3F,GAAQH,GACX,MAAQN,EAAOy9B,OACd,GAAIz9B,EAAOoG,SAAW9F,GAASN,EAAOO,SAAWsI,GAChD,OAAO,EAMV,OADA7I,EAAOK,IAAMD,GACN,EAsFHL,CAAUC,IAAWA,EAAOQ,IAAI2I,KAAW00B,GAAS79B,GACvD,OAAO,EAIR,OADAA,EAAOK,IAAMD,GACN,EAdA49B,CAA4Bh+B,IAAW89B,GAA8B99B,GAqB7E,SAAS89B,GAA8B99B,GACtCP,IAAMW,EAAQJ,EAAOK,IACrB,SAAIL,EAAO+H,SAASk2B,KAAoBj+B,EAAOQ,IAAI2I,KAAW00B,GAAS79B,MAIvEA,EAAOK,IAAMD,GACN,GAQR,SAASy9B,GAAS79B,GACjB,OAAOA,EAAO+H,SAASwW,IAQxB,SAASA,GAAQsM,GAChB,OAAOA,IAAMvX,IAASuX,IAAMpO,IAQ7B,SAAiBoO,GAEhB,OADAA,IAAK,KACO,IAAMA,GAAK,GAVa9pB,CAAQ8pB,IAkB7C,SAAkBA,GACjB,OAAOA,EAAI,IAAMA,EAAI,GAnB6B/pB,CAAS+pB,GA2B5D,SAAS1pB,GAAa0pB,GACrB,OAAOA,IAAM8S,IAAS9S,IAAM6S,GAQ7B,SAASO,GAAgBpT,GACxB,OAAOA,GAAKA,IAAM1hB,KAAWhI,GAAa0pB,KAAOpqB,GAAQoqB,GAG1DprB,IAAMoB,YAAOa,UAAMA,EAAGkG,WAAW,IAC3Bs2B,GAAiBr9B,GAAK,KACtBs9B,GAAiBt9B,GAAK,KACtBu9B,GAAiBv9B,GAAK,KACtBw9B,GAAiBx9B,GAAK,KACtBy9B,GAAiBz9B,GAAK,KACtB09B,GAAiB19B,GAAK,KAEtB29B,GAAe,IAAInzB,IAAI,iBAAiB5G,MAAM,IAAI0C,IAAItG,KACtD49B,IAAa,IAAIzyB,KACrBC,IAAIiyB,GAAgBC,IACpBlyB,IAAImyB,GAAgBC,IACpBpyB,IAAIqyB,GAAgBC,IAEhB3+B,IACLsb,OAAQ,SACRwjB,UAAW,KACXttB,OAAQ,IA0BT,SAASutB,GAAoBppB,EAAMlV,EAAKJ,GAcvCwB,IAAIopB,EAZJxqB,EAAMma,KAAK+e,IAAIhkB,EAAKvR,OAAQwW,KAAKC,IAAI,EAAU,MAAPpa,EAAckV,EAAKvR,OAAS3D,IAQ3C,OALxBJ,EADsB,kBAAZA,EACAC,OAAOC,UAAWP,IAAkB8+B,UAAWz+B,IAE/CC,OAAOC,UAAWP,GAAgBK,IAGjCy+B,YAA2C,IAAtBz+B,EAAQy+B,YACxCr+B,EAwDF,SAA8BkV,EAAMlV,EAAKJ,GAEpCQ,GAAQ8U,EAAK3N,WAAWvH,KAC3BA,IAID,KAAOu+B,GAAarpB,EAAK3N,WAAWvH,GAAMJ,EAAQib,SACjD7a,IAGD,OAAOA,EAnEAw+B,CAAqBtpB,EAAMlV,EAAKJ,IAIvCR,IAAMW,EA0EP,SAAwBmV,EAAMlV,EAAK+Q,GAClC,IAAKA,EACJ,OAAO,EAGR3R,IAGIsJ,EAHE/I,EAAS,IAAIuH,GAAagO,GAC1BupB,EAAiBl9B,OAAOwP,GAAQ3M,MAAM,IAAI0C,IAAItG,IACpDb,EAAOK,IAAMA,EAGb,MAAQL,EAAOy9B,OACd,IAAIsB,GAAY/+B,EAAQm+B,GAAgBD,MAAmBa,GAAY/+B,EAAQu+B,GAAeD,IAA9F,CAKA,GADAv1B,EAAS/I,EAAOK,IACZ2+B,GAAah/B,EAAQ8+B,GACxB,OAAO/1B,EAGR/I,EAAOK,MAGR,OAAQ,EAjGM4+B,CAAe1pB,EAAMlV,EAAKJ,EAAQmR,QAChD,IAAe,IAAXhR,EACH,OAAO,KAGRX,IAAMO,EAAS,IAAIuH,GAAagO,EAAMnV,GACtCJ,EAAOK,IAAMA,EAGb,IAFAZ,IAAMkC,MAEE3B,EAAOy9B,OAAO,CAGrB,GAAImB,GAFJ/T,EAAI7qB,EAAOO,OAESN,EAAQib,QAC3BvZ,EAAMmD,KAAK+lB,QACL,GAAIqU,GAAYrU,EAAG5qB,EAAQib,SACjC,GAAIvZ,EAAMsJ,QAAUwzB,GAAWtyB,IAAI0e,GAElC,UAEK,CAAA,GAAIrf,GAAI7J,EAAOw8B,KAAmB3yB,GAAI7J,EAAO48B,IAAgB,CAEnEv+B,EAAOK,MACP,SACM,GAAIu9B,GAAY59B,KAAYm/B,GAAetU,GACjD,MAGD7qB,EAAOK,MAGR,IAAKsB,EAAMqC,QAAUhE,EAAOK,MAAQA,EAAK,CAGxCZ,IAAM2/B,EAAe7pB,EAAKnN,MAAMpI,EAAOK,IAAKA,GAAKkR,QAAQ,WAAY,IACrE,oBACC6tB,EACAlsB,SAAU7S,EAAM++B,EAAap7B,OAC7B5D,MAAOH,EAAQmR,OACZhR,EAAQH,EAAQmR,OAAOpN,OACvB3D,EAAM++B,EAAap7B,OACtByD,IAAKpH,IAmER,SAAS0+B,GAAY/+B,EAAQwB,EAAOD,GACnC9B,IAAMW,EAAQJ,EAAOK,IACrB,GAAIL,EAAOQ,IAAIgB,GACd,MAAQxB,EAAOy9B,OAAO,CACrB,GAAIz9B,EAAOQ,IAAIe,GACd,OAAO,EAGRvB,EAAOK,MAKT,OADAL,EAAOK,IAAMD,GACN,EAQR,SAAS4+B,GAAah/B,EAAQwD,GAI7B,IAHA/D,IAAMW,EAAQJ,EAAOK,IACjBg/B,GAAW,EAEN97B,EAAIC,EAAIQ,OAAS,EAAGT,GAAK,IAAMvD,EAAOy9B,OACzCz9B,EAAOQ,IAAIgD,EAAID,IADiCA,IAKrD87B,EAAiB,IAAN97B,EAOZ,OAJK87B,IACJr/B,EAAOK,IAAMD,GAGPi/B,EAGR,SAAS7zB,GAAIhI,EAAKxB,GACjB,OAA+B,IAAxBwB,EAAIC,QAAQzB,GAGpB,SAASm9B,GAAetU,GACvB,OAAQA,EAAI,IAAMA,EAAI,IACjBA,EAAI,IAAMA,EAAI,KACdA,EAAI,IAAMA,EAAI,IACf2T,GAAahzB,IAAIqf,GAGtB,SAASqU,GAAYrU,EAAG3P,GACvB,OAAO2P,IAAMuT,IAA6B,WAAXljB,IAAwB2P,IAAMqT,IAAkBrT,IAAMyT,IAGtF,SAASM,GAAa/T,EAAG3P,GACxB,OAAO2P,IAAMwT,IAA6B,WAAXnjB,IAAwB2P,IAAMsT,IAAkBtT,IAAM0T,ICldtF,IAAIe,IACHC,OAAQ,OACRC,WAAY,OAGTC,IACHF,QAAS,OAAQ,MAAO,MAAO,MAAO,KAAM,MAAO,OAAQ,QAC3DC,YAAa,MAAO,OAAQ,OAAQ,OAAQ,MAAO,WAWpD,SAASE,GAAc9D,EAAQ+D,GAG9B,IAAIC,EAmBL,SAAuBhE,EAAQiE,GAC9B,IAAIxkB,EAAOwkB,EAAIxkB,KACXH,EAAS2kB,EAAI3kB,OACb4kB,EAAUD,EAAIC,QAElB,OACC5kB,OAAQA,EACRG,KAAMA,EACNykB,QAASA,EACTtmB,OAASumB,GAAYnE,EAAQ,SAAUvgB,EAAMH,EAAQ4kB,GACrDtoB,QAASuoB,GAAYnE,EAAQ,UAAWvgB,EAAMH,EAAQ4kB,GACtD7/B,QAAS8/B,GAAYnE,EAAQ,UAAWvgB,EAAMH,EAAQ4kB,GACtDrtB,UAAWstB,GAAYnE,EAAQ,YAAavgB,EAAMH,EAAQ4kB,GAC1D1gB,SAAU4gB,GAAUpE,EAAQ,WAAYvgB,EAAMH,EAAQ4kB,GAASp7B,OAAOwN,UAhCxD+tB,CAAcrE,EAF7B+D,EA2CD,SAAsB/D,EAAQ+D,GAC7B,IAAItkB,EAAOskB,EAAOtkB,KACdH,EAASykB,EAAOzkB,OAEfG,GAASH,GAGFG,GAAQH,EAElBG,GAD6C,IAA1CokB,GAAcF,OAAO97B,QAAQyX,GACzB,UACiD,IAA9CukB,GAAcD,WAAW/7B,QAAQyX,GACpC,aAEA/O,GAAIyvB,GAAS,SAAU1gB,EAAQ,UAClC/O,GAAIyvB,GAAS,UAAW+D,EAAOG,QAAS,SAAU5kB,EAAQ,SAEpDA,IACXA,EAASokB,GAAgBjkB,IAXzBH,EAASokB,GADTjkB,EAAO,UAeR,OAAOnb,OAAOC,UAAWw/B,GAAStkB,KAAMA,EAAMH,OAAQA,IA/D7CglB,CAAatE,EAAQ+D,QAK1BQ,GAAe,UAAW,SAAU,WACxC,IAAK,IAAIxzB,KAAKivB,GACmB,IAA5BuE,EAAY18B,QAAQkJ,KACvBizB,EAASjzB,GAAKivB,EAAOjvB,IAIvB,OAAOizB,EAsDR,SAASG,GAAYnE,EAAQvpB,EAAKgJ,EAAMH,EAAQ4kB,GAC/C,OAAOE,GAAUpE,EAAQvpB,EAAKgJ,EAAMH,EAAQ4kB,GAC1Cl8B,OAAO,SAAUC,EAAKklB,GAAO,OAAQ7oB,OAAOC,UAAW0D,EAAKklB,QAG/D,SAASiX,GAAUpE,EAAQvpB,EAAKgJ,EAAMH,EAAQ4kB,GAC7C,OACC3zB,GAAIyvB,GAAS,UAAWvgB,EAAMhJ,IAC9BlG,GAAIyvB,GAAS,UAAWkE,EAAS,UAAWzkB,EAAMhJ,IAClDlG,GAAIyvB,GAAS,SAAU1gB,EAAQ7I,IAC/BlG,GAAIyvB,GAAS,UAAWkE,EAAS,SAAU5kB,EAAQ7I,KAClD3N,OAAOwN,SAWV,SAAS/F,GAAI4c,EAAK1W,EAAKyN,GAGtB,IAFA,IAAI/W,EAASggB,EAEJxlB,EAAI,EAAGA,EAAI8O,EAAIrO,QACT,MAAV+E,EAD2BxF,IAK/BwF,EAASA,EAAOsJ,EAAI9O,IAGrB,OAAiB,MAAVwF,EAAiBA,EAAS+W,EClHlCrgB,IAAM2gC,YAAez1B,EAAO6E,yBAAc,SAAa7E,GAAQ6E,EAAc,IAAMA,EAAc,SAUlF,SAAS6wB,GAAaC,EAAQjgC,EAAKJ,GAEjDR,IAAMyb,EA0BA,SAAmBolB,EAAQjgC,GACjCZ,IAAM8gC,EAAWD,EAAOE,UACxB,GAAsB,QAAlBD,EAASx+B,MAAoC,eAAlBw+B,EAASx+B,KACvC,OAAOw+B,EAASx+B,KAGjBtC,IAAMghC,EAAOH,EAAOI,UAAUrgC,GAC9B,MAAqB,QAAdogC,EAAK1+B,KAAiB,OAAS0+B,EAAK1+B,KAjC5B4+B,CAAUL,EADzBjgC,EAAMA,GAAOigC,EAAOM,aAIdhF,EAASqE,GAAc//B,OAAOC,QACjCsT,MAAO2sB,IACTE,EAAOO,UAAU,SACjB5gC,WACIib,IAECulB,EAAOH,EAAOI,UAAUrgC,GAQ9B,MAPe,QAAX6a,GACH0gB,EAAOpkB,QAAUtX,OAAOC,QAASq7B,iBAAkB,OAASI,EAAOpkB,SACnEokB,EAAO37B,QAAUC,OAAOC,QAAS2gC,KAAK,GAAQlF,EAAO37B,UAC7B,QAAdwgC,EAAK1+B,OACf65B,EAAOpkB,QAAUtX,OAAOC,QAASq7B,iBAAkBiF,EAAKM,eAAiBnF,EAAOpkB,UAG1EokB,EC7BRn8B,IAKqBuhC,eAMpB,WAAYV,EAAQjgC,EAAKqH,GACxBu5B,aACAxhC,IAAMyhC,EAAaZ,EAAO34B,YAC1B1F,KAAKq+B,OAASA,EACdr+B,KAAK7B,MAAQ6B,KAAK5B,IAAMA,GAAO6gC,EAAWC,IAAI,EAAG,GAEjD1hC,IAAM2hC,EAAWd,EAAOc,WACxBn/B,KAAKo/B,KAAO35B,EAAQA,EAAMzG,GAAOigC,EAAWC,IAAIC,EAAUn/B,KAAKq/B,YAAYF,IAC3En/B,KAAKs/B,KAAO75B,EAAQA,EAAM1G,KAAOkgC,EAAWC,IAAI,EAAG,6GAOpDK,eACC,OAAOC,GAAWx/B,KAAK5B,IAAK4B,KAAKs/B,OAAS,eAO3C7gC,eACC,OAAO+gC,GAAWx/B,KAAK5B,IAAK4B,KAAKo/B,OAAS,eAU3C35B,eAAM1G,EAAMC,GACX,OAAO,IAAIgB,KAAK0F,YAAY1F,KAAKq+B,OAAQt/B,QAAQA,KAAMC,iBAQxDV,gBACC,MAAqB0B,KAAK5B,oBACpBqhC,EAAUz/B,KAAKq+B,OAAOqB,QAAQpsB,GACpC,OAAO7T,EAAKggC,EAAQ19B,OAAS09B,EAAQ95B,WAAWlG,GAzDjC,gBAiEhBf,gBACC,IAAKsB,KAAKvB,MAAO,CAChBjB,IAAMoB,EAAOoB,KAAK1B,OAclB,OAbA0B,KAAK5B,IAAMH,OAAOC,UAAW8B,KAAK5B,KAAOqB,GAAIO,KAAK5B,IAAIqB,GAAK,IAEvDO,KAAK5B,IAAIqB,IAAMO,KAAKq/B,YAAYr/B,KAAK5B,IAAIkV,QAC5CtT,KAAK5B,IAAIkV,OACTtT,KAAK5B,IAAIqB,GAAK,GAGXO,KAAKvB,QAGRuB,KAAK5B,IAAMH,OAAOC,UAAW8B,KAAKo/B,OAG5BxgC,EAGR,OAAO+gC,iBAQR55B,gBAAOC,OACAi5B,EAAaj/B,KAAKq+B,OAAO34B,cAEZ1F,KAAK5B,oBAGxB,IAFAqB,GAAOuG,GAAK,EAELsN,GAAQ,GAAK7T,EAAK,GACxB6T,IACA7T,QAAW4/B,YAAY/rB,GAOxB,OAJAtT,KAAK5B,IAAMkV,EAAO,GAAK7T,EAAK,EACzBw/B,EAAWC,IAAI,EAAG,GAClBD,EAAWC,IAAI5rB,EAAM7T,GAEjBO,KAAK1B,oBAQb2H,mBACC,OAAOjG,KAAKkG,UAAUlG,KAAK7B,MAAO6B,KAAK5B,kBASxC8H,mBAAUnH,EAAMC,GACf,OAAOgB,KAAKq+B,OAAOuB,SAAS7gC,EAAMC,gBAQnCL,eAAMyH,GACL5I,IAAM6I,EAAM,IAAInC,MAASkC,cAAmBpG,KAAK5B,qBAAoB4B,KAAK5B,IAAM,IAIhF,OAHAiI,EAAIC,gBAAkBF,EACtBC,EAAIjI,IAAM4B,KAAK5B,IACfiI,EAAId,OAASvF,KAAKuF,OACXc,eAQRg5B,qBAAY/rB,GACX9V,IAAMqiC,EAASvsB,IAAStT,KAAKq+B,OAAOc,WACpC,OAAOn/B,KAAKq+B,OAAOqB,QAAQpsB,GAAMvR,QAAU89B,EAAS,EAAI,OAhJNv6B,GAoJpD,SAASk6B,GAAWv1B,EAAGmI,GACtB,OAAOnI,EAAEqJ,KAAOlB,EAAEkB,MAAQrJ,EAAExK,GAAK2S,EAAE3S,GCnI7B,SAASqgC,GAAczB,EAAQ/rB,EAAMytB,GAC3CvgC,IAAI2T,EAgCE,SAAsBb,GAC5B,OAAO3R,MAAMC,QAAQ0R,GAAQA,EAAOA,EAAK9P,MAAM,eAjCnC4Q,CAAad,GACnBU,EAlBA,SAAwBqrB,GAC9B,OAAKA,EAAOO,UAAU,kBAIf,KAHCoB,GAAa,IAAK3B,EAAOO,UAAU,eAgB5BqB,CAAe5B,GAW9B,MATe,OAAXrrB,IACHG,EAAQA,EAAMjO,aAAIoO,UAAQA,EAAKhE,QAAQ,gBACtC4wB,UAAQF,GAAahtB,EAAQktB,EAAKn+B,aAGhCg+B,IACH5sB,EAAQA,EAAMjO,aAAKoO,EAAMhS,UAAMA,EAAIy+B,EAAczsB,EAAOA,KAGlDH,EAAMzP,KAAK,MAwBZ,SAASs8B,GAAa9+B,EAAKmE,GAEjC,IADA7F,IAAIsH,EAAS,GACN,EAAIzB,KACVyB,GAAU5F,EAGX,OAAO4F,EAQD,SAASq5B,GAAaj/B,GAC5B,OAAO8S,GAAY9S,GAAKqE,OAUlB,SAAS66B,GAAYC,EAAOjiC,EAAKkiC,GACvC,OAAOA,EACJd,GAAWphC,EAAKiiC,EAAMthC,MAAQ,GAAKygC,GAAWphC,EAAKiiC,EAAMrhC,IAAM,EAC/DwgC,GAAWphC,EAAKiiC,EAAMthC,OAAS,GAAKygC,GAAWphC,EAAKiiC,EAAMrhC,KAAO,EAG9D,SAASwgC,GAAWv1B,EAAGmI,GAC7B,OAAOnI,EAAEqJ,KAAOlB,EAAEkB,MAAQrJ,EAAExK,GAAK2S,EAAE3S,GAG7B,SAAS8gC,GAAc18B,GAC7B,OACC9E,KAAM8E,EAAK1F,MACXa,GAAI6E,EAAK2B,KAiEJ,SAASg7B,GAAmBnC,EAAQjgC,GAC1CZ,IAAMghC,EAAOH,EAAOI,UAAUrgC,GAC9B,GAAIogC,GAAsB,QAAdA,EAAK1+B,KAAgB,CAChCtC,IAAM+F,EAAQ86B,EAAOoC,WAAWriC,GAC1BkQ,EAAQ/K,EAAM+K,OAAS/K,EAAM+K,MAAMoyB,YAAcn9B,EAAM+K,MAC7D,OAAOA,GAASA,EAAMqyB,SAAkC,SAAvBryB,EAAMqyB,QAAQvnB,KAGhD,OAAO,ECjKO,SAASwnB,GAAcvC,EAAQgC,EAAO/tB,GACpD9U,IACMqjC,EADOxC,EAAOqB,QAAQW,EAAMthC,KAAKuU,MACd1N,MAAM,QAEzBk7B,EAAa9sB,GADL8rB,GAAczB,EAAQ/rB,EAAMuuB,GAAeA,EAAY,KAGrE,OAAOxC,EAAO0C,qBACb1C,EAAO2C,aAAaF,EAAWv7B,OAAQ86B,EAAMthC,KAAMshC,EAAMrhC,IAGzDxB,IAAMyjC,EAAU5C,EAAO6C,aAAab,EAAMthC,MAC1C,GAAI+hC,EAAWrvB,OAAO1P,OAAQ,CAC7BvE,IAAMgU,EAAQsvB,EAAWrvB,OAAO,GAC1B1S,EAAOs/B,EAAO8C,aAAa3vB,EAAMP,SAAWgwB,GAC5CjiC,EAAKq/B,EAAO8C,aAAa3vB,EAAMP,SAAWO,EAAMzP,OAASk/B,GAC/D5C,EAAO+C,aAAariC,EAAMC,QAE1Bq/B,EAAOgD,UAAUhD,EAAO8C,aAAaF,EAAUH,EAAWv7B,OAAOxD,SAGlE,OAAO,IC3BTvE,IAAM8jC,GAAmB,qBASV,SAASC,GAAyBlD,EAAQjgC,EAAKojC,GAE7DhkC,IAAMikC,EAASC,GAAWrD,EAAQjgC,GAClC,GAAIqjC,GAAUA,EAAO9wB,MACpB,OAAO8wB,EAAO9wB,MAIfnT,IAAMmkC,ECVQ,SAA6BtD,EAAQjgC,EAAKojC,GACxDhkC,IAAMm8B,EAASyE,GAAaC,EAAQjgC,GAEpC,GAAIojC,IA2CL,SAAoBnD,EAAQjgC,EAAKu7B,GAChCn8B,IAAMokC,EAAYvD,EAAOwD,eAAezjC,GAExC,MAAoB,eAAhBu7B,EAAOvgB,KACW,YAAdwoB,GAAyC,WAAdA,EAGb,SAAlBjI,EAAO1gB,OACW,OAAd2oB,EAGc,SAAlBjI,EAAO1gB,QAAuC,QAAlB0gB,EAAO1gB,OACjB,OAAd2oB,GAAoC,QAAdA,GACxBA,GAAa,YAAYp6B,KAAKo6B,GAGd,SAAlBjI,EAAO1gB,OACW,OAAd2oB,GAAoC,cAAdA,EAGR,QAAlBjI,EAAO1gB,OA/DU6oB,CAAWzD,EAAQjgC,EAAKu7B,GAC5C,OAAO,KAGRn8B,IAAMmkC,EAAYI,GAAQ1D,EAAOqB,QAAQthC,EAAIkV,MAAOlV,EAAIqB,IACvDg9B,WAAW,EACXxjB,OAAQ0gB,EAAOvgB,KACfjK,OAA0B,QAAlBwqB,EAAO1gB,QAAoBolB,EAAOO,UAAU,cAAgB,IAAM,KAG3E,GAAI+C,EAAW,CACdnkC,IAAMuB,GACLuU,KAAMlV,EAAIkV,KACV7T,GAAIkiC,EAAUxjC,OAETa,GACLsU,KAAMlV,EAAIkV,KACV7T,GAAIkiC,EAAUn8B,KAWf,MARoB,eAAhBm0B,EAAOvgB,MAAyBooB,GAG/BhB,GAAmBnC,EAAQjgC,KAC9Bu7B,EAAO37B,QAAUC,OAAOC,QAASof,SHsG9B,SAA4B+gB,EAAQjgC,GAI1C,IAHAZ,IACiB+F,EADX+P,EAAOlV,EAAIkV,KACb7T,EAAKrB,EAAIqB,GAENA,GAAM,GAAG,CAEf,GAAmB,cADnB8D,EAAQ86B,EAAOoC,iBAAantB,KAAM7T,KACxB2Z,KACT,OAAO7V,EAAMgC,OAGd,GAAIhC,EAAMpF,QAAUsB,EAGnB,MAFAA,EAAK8D,EAAMpF,OGjHiC6jC,CAAmB3D,EAAQjgC,IAAQu7B,EAAO37B,WAKtFm/B,aAAcwE,EAAUxE,aACxBkD,YAASthC,KAAMC,UACf26B,IDxBgBoI,CAAQ1D,EAAQjgC,EAAKojC,GACvC,GAAIG,EACH,IACCnkC,IAAMmL,EAAO,IAAIs5B,GAAaN,EAAUxE,aAAcwE,EAAUtB,MAAOsB,EAAUhI,QACjF,OAAOhxB,EAAKu5B,MAAM7D,EAAQmD,GAAgB74B,EAAO,KAChD,MAAOtC,KAaJ,SAASq7B,GAAWrD,EAAQjgC,GAElC,IADAZ,IAAM2kC,EAAU9D,EAAO+D,YAAYhkC,GAC1BkD,EAAI,EAAGmgC,SAAQngC,EAAI6gC,EAAQpgC,OAAQT,IAE3C,IADAmgC,EAASU,EAAQ7gC,IACNyN,YAAcuyB,GAAkB,CAC1C,GAAIe,GAAchE,EAAQoD,GACzB,OAAOA,EAGRA,EAAOhJ,SASH,SAAS6J,GAAajE,GAE5B,IADA7gC,IAAM2kC,EAAU9D,EAAOkE,cACdjhC,EAAI,EAAGA,EAAI6gC,EAAQpgC,OAAQT,IAC/B6gC,EAAQ7gC,GAAGyN,YAAcuyB,IAC5Ba,EAAQ7gC,GAAGm3B,QAWP,SAAS+J,GAAanE,EAAQ1tB,GACpC,MAAqBA,EAAM0vB,sBACrBoB,EAASpD,EAAOoE,SAAS1jC,EAAMC,GACpC0jC,eAAe,EACfC,gBAAgB,EAChBC,gBAAgB,EAChB7zB,UAAWuyB,KAGZ,OADAG,EAAO9wB,MAAQA,EACR8wB,EAUR,SAASY,GAAchE,EAAQoD,GAC9BjkC,IAAM6iC,EAAQoB,EAAOpyB,OAGrB,GAAIgxB,EAAMthC,KAAKuU,OAAS+sB,EAAMrhC,GAAGsU,KAChC,OAAO,EAIR9T,IAAI8S,EAAO+rB,EAAOuB,SAASS,EAAMthC,KAAMshC,EAAMrhC,IAC7C,IAAKsT,GAAQ,WAAW9K,KAAK8K,GAC5B,OAAO,EAOR,GAJImvB,EAAO9wB,OAAwC,QAA/B8wB,EAAO9wB,MAAMgpB,OAAO1gB,QAAgC,MAAZ3G,EAAK,KAChEA,EAAOA,EAAKnM,MAAM,KAGds7B,EAAO9wB,OAAS8wB,EAAO9wB,MAAMwsB,eAAiB7qB,EAElD,IACCmvB,EAAO9wB,MAAQ,IAAIsxB,GAAa3vB,EAAM+tB,EAAOoB,EAAO9wB,MAAMgpB,QACrD8H,EAAO9wB,MAAMuxB,MAAM7D,GAAQ,KAC/BoD,EAAO9wB,MAAQ,MAEf,MAAOtK,GACRw8B,QAAQC,KAAKz8B,GACbo7B,EAAO9wB,MAAQ,KAIjB,OAAOV,QAAQwxB,EAAO9wB,OAAS8wB,EAAO9wB,MAAMrH,SAGtC,IAAM24B,GAMZ,SAAY9E,EAAckD,EAAO1G,GPuHlC,IAAiBhxB,EAAM3K,EOtHtBgC,KAAMm9B,aAAeA,EACrBn9B,KAAMqgC,MAAQA,EACdrgC,KAAM25B,OAASA,EACf35B,KAAM+iC,KPmHUp6B,EOnHEw0B,EPsH+B,eAA1CvC,IAFP58B,EAAU68B,GADY78B,EOnHU27B,IPsHTvgB,KAAMpb,EAAQib,QAClC+gB,GAAQrxB,EAAM3K,GACdiL,GAAMN,EAAM3K,IOvHfgC,KAAMsJ,QAAU0xB,GAAOh7B,KAAK+iC,IAAKpJ,GACjC35B,KAAMgjC,QAAU7C,GAAangC,KAAKsJ,UEnIpB,YAAS+0B,EAAQmD,GAC/B,GAAInD,EAAO4E,oBACV,OAAO5E,EAAO34B,YAAYw9B,KAG3B1lC,IAAMmL,EAAOw6B,GAAgB9E,EAAQA,EAAOM,YAAa6C,GAEzD,OAAI74B,GACHA,EAAKoF,OAAOswB,GACZiE,GAAajE,IACN,GAKDA,EAAO34B,YAAYw9B,KCtBZ,YAAS7E,GACvB7gC,IAAMoiB,EAAUye,EAAO+E,iBAAiBl+B,aAAIm+B,UA+C7C,SAAqBhF,EAAQgC,GAC5B,GAoBuBp2B,EApBJo2B,EAAMiD,OAoBClxB,EApBOiuB,EAAMkD,KAqBhCt5B,EAAEu5B,SAAWpxB,EAAEoxB,QAAwB,IAL/C,SAAav5B,EAAGmI,GACf,OAAOnI,EAAEqJ,KAAOlB,EAAEkB,MAAQrJ,EAAExK,GAAK2S,EAAE3S,GAIHgkC,CAAIx5B,EAAGmI,GArBO,CAC7C5U,IAAMkmC,EAASrD,EAAMiD,OACf9E,EAAOH,EAAOI,UAAUiF,GAE9B,GAAkB,QAAdlF,EAAK1+B,KAAgB,CACxBtC,IAAMkX,EAAO2pB,EAAOoC,WAAWiD,GACzB/uB,EAAQ0pB,EAAOoC,WAAWxiC,OAAOC,UAAWwlC,GAAUjkC,GAAIikC,EAAOjkC,GAAK,KAE5E,MAAqB,gBAAdiV,EAAK0E,MAA0C,MAAhB1E,EAAKnP,QACxB,gBAAfoP,EAAMyE,MAA2C,OAAjBzE,EAAMpP,QAW7C,IAAwB0E,EAAGmI,EApEyBuxB,CAAYtF,EAAQgF,KAEvE,IAAKzjB,EAAQgkB,KAAK3zB,SACjB,OAAOouB,EAAO34B,YAAYw9B,KAG3B7E,EAAO0C,qBAMN,IALAvhC,IAAIqkC,EAAOxF,EAAO+E,iBACZU,EAAYzF,EAAO3V,IAAIqb,gBACvBC,EAAYF,EAAYA,EAGrBxiC,EAAIuiC,EAAK9hC,OAAS,EAAGT,GAAK,EAAGA,IACrC+8B,EAAO2C,aAAaphB,EAAQte,GAAK0iC,EAAYF,EAAWD,EAAKviC,GAAGgiC,OAAQO,EAAKviC,GAAGiiC,KAAM,YAIvFM,EAAOxF,EAAO+E,iBACd,IAAK5jC,IAAI8B,EAAI,EAAGA,EAAIuiC,EAAK9hC,OAAQT,IAChC+8B,EAAO4F,WAAWJ,EAAKviC,GAAGvC,OAAOuU,KAAM,MAAM,GAEzCsM,EAAQte,IACX+8B,EAAO4F,WAAWJ,EAAKviC,GAAGvC,OAAOuU,KAAO,EAAG,MAAM,GAKnD+qB,EAAO6F,cAAc7F,EAAO+E,iBAAiBl+B,aAAKm+B,EAAK/hC,GACtD,GAAIse,EAAQte,GAAI,CACf9D,IAAM8V,EAAO+vB,EAAItkC,OAAOuU,KAAO,EACzBowB,QACLpwB,EACA7T,GAAI4+B,EAAOqB,QAAQpsB,GAAMvR,QAE1B,OAASuhC,OAAQI,EAAQH,KAAMG,GAGhC,OAAOL,OC9BK,SAASc,GAAqB9F,GAC5C7gC,IAAM6iC,EAuBP,SAAiChC,GAChC,GAAIA,EAAO4E,oBAAqB,CAC/BzlC,IAAM6lC,EAAMhF,EAAO+E,iBAAiB3gC,gBAAO4gC,UAAOA,EAAIC,SAAWD,EAAIE,OAAM,GAC3E,GAAIF,EACH,OAAQ7D,GAAW6D,EAAIC,OAAQD,EAAIE,MAAQ,GACtCxkC,KAAMskC,EAAIC,OAAQtkC,GAAIqkC,EAAIE,OAC1BxkC,KAAMskC,EAAIE,KAAMvkC,GAAIqkC,EAAIC,QAK/B,OAUD,SAA2BjF,EAAQjgC,GAClCZ,IAAMmT,EAAQ0tB,EAAO+F,wBACfC,EAAM1zB,GAASA,EAAM2zB,aAAalmC,GAExC,IAAKimC,EACJ,OAAO,KAIR,GAAIE,GAAQF,EAAI/kC,KAAMlB,IAAQmmC,GAAQF,EAAI9kC,MAAOnB,GAEhD,OAAOmiC,GAAc8D,GAItB7mC,IAAMuB,EAAOslC,EAAI/kC,KAAKkG,IAChBxG,EAAKqlC,EAAI9kC,MAAQ8kC,EAAI9kC,MAAMpB,MAAQkmC,EAAI/kC,KAAKkG,IAElD,ONyCM,SAA0B64B,EAAQt/B,EAAMC,GAC9CxB,IAAMO,EAAS,IAAIghC,GAAuBV,EAAQt/B,GAKlD,GAHAhB,EAAO+H,SAAS3G,GAChBJ,EAAOhB,EAAOK,IAEVY,EAAI,CAIP,IAHAjB,EAAOK,IAAMY,EACbjB,EAAOgI,UAEChI,EAAOwhC,OAASpgC,EAAQpB,EAAOO,SACtCP,EAAOgI,SAGRhI,EAAOW,OACPM,EAAKjB,EAAOK,SAEZY,EAAKD,EAGN,YAASA,KAAMC,GM7DRwlC,CAAiBnG,EAAQt/B,EAAMC,GA5B/BylC,CAAkBpG,EAAQA,EAAOM,aAlC1B+F,CAAwBrG,GAEtC,GAAIgC,EAAO,CACV7iC,IAAMmnC,EAAStG,EAAOO,UAAU,gBAAkBgG,GAC5CtyB,EAAO+rB,EAAOuB,SAASS,EAAMthC,KAAMshC,EAAMrhC,GAAI,MACjDwD,MAAM,MACN0C,aAAIoO,UAAQA,EAAKnS,SAEnBwjC,EAAOtG,EAAQ,4CAAoC11B,GAC9CA,GACW,IAAIs5B,GAAat5B,EAAM03B,EAAOjC,GAAaC,EAAQgC,EAAMthC,WAAQuT,KACzEvE,OAAOswB,UAIfwE,QAAQC,KAAK,mBAkDf,SAASyB,GAAQF,EAAKjmC,GACrB,OAAOimC,GAAOjE,GAAYG,GAAc8D,GAAMjmC,GAG/C,SAASwmC,GAAcvG,EAAQj4B,EAASy+B,GACvCA,EAASC,OAAOH,OAAOv+B,IJoExB67B,aAACl0B,gBAAOswB,EAAQgC,GACf,OAAQO,GAAcvC,EAAQgC,GAASrgC,KAAKqgC,MAAOrgC,KAAKsJ,UAQzD24B,aAACC,eAAM7D,EAAQmD,GACd,SAAKxhC,KAAKgjC,SAAWhjC,KAAKm9B,eAAiBn9B,KAAKgjC,YACvCxB,GAAqC,eAArBxhC,KAAK25B,OAAOvgB,MAChCpZ,KAAK+kC,sBAAsB1G,KAOjC4D,aAAC8C,+BAAsB1G,GACtB,IAAOjgC,EAAM4B,KAAKqgC,MAAMthC,KACjBwE,EAAQ86B,EAAOoC,WAAWriC,GAEjC,GAAK,QAAQoJ,KAAKxH,KAAKm9B,cAEtB,OAAQqD,GAAmBnC,EAAQjgC,GAIpC,IAAO4mC,EAAahlC,KAAK+iC,IAAIxiC,SAAS0kC,eAAMphC,UAAQA,EAAK/D,OAClDwO,EAAQ/K,EAAM+K,OAAS/K,EAAM+K,MAAMoyB,YAAcn9B,EAAM+K,MAE9D,OAAK02B,IAI2B,SAAvBhlC,KAAK25B,OAAO1gB,QACd3K,GAASA,EAAMqyB,SAAkC,UAAvBryB,EAAMqyB,QAAQvnB,OKzHhD5b,IAAMyf,GAAa,qCACblC,GAAS,GAaf,SAASmC,GAAYC,GACpB,OAyED,SAAcA,GACbA,EAAWA,EAAShL,KAAKiL,IAMzB,IALA5f,IAAMkC,KAKG4B,EAAI,EAAG+b,SAAKlZ,SAAM7C,EAAI6b,EAASpb,OAAQT,IAG/C,IAFA+b,EAAMF,EAAS7b,IAENgc,SAAT,CAQA,KAAO5d,EAAMqC,QAAQ,CAGpB,GAFAoC,EAAOzE,EAAMA,EAAMqC,OAAS,GAEgB,IAAxCsb,EAAIC,SAAS9b,QAAQ2C,EAAKmZ,WACdD,EAAIC,SAAS3X,WAAWxB,EAAKmZ,SAASvb,UAAYgZ,GAAQ,CACzE5W,EAAKoZ,cAAcF,GACnB3d,EAAMmD,KAAKwa,GACX,MAGD3d,EAAMsJ,MAGFtJ,EAAMqC,QACVrC,EAAMmD,KAAKwa,GAIb,OAAOF,EA7GAK,CAAML,EAASjY,aAAIoE,UAAW,IAAImU,GAAWnU,EAAQ8G,IAAK9G,EAAQvJ,UAG1E,IAAM0d,GACL,SAAYrN,EAAKrQ,GACjBC,KAAMoQ,IAAMA,EACZpQ,KAAMD,MAAQA,EACdC,KAAMsd,SAAW,KAGjB,IAAOxN,EAAI/P,GAASA,EAAM6F,MAAMqX,IAC3BnN,IACJ9P,KAAMsd,SAAWxN,EAAE,GACnB9P,KAAMD,MAAQ+P,EAAE,IAGjB9P,KAAM0d,qDAsGP,SAASN,GAAanT,EAAGmI,GACxB,OAAInI,EAAEmG,MAAQgC,EAAEhC,IACR,EAGDnG,EAAEmG,IAAMgC,EAAEhC,KAAO,EAAI,EAQ7B,SAAS+K,GAAUja,GAClB,MAAO,aAAasG,KAAKtG,GAG1B,SAASyc,GAAW5d,GACnB,OAAOJ,OAAOI,GAAOyC,MAAM,KCtMb,YAAS67B,EAAQjgC,GAE/BoB,IAAI0lC,KAME/H,EAAegG,GAAgB9E,EAPrCjgC,EAAMA,GAAOigC,EAAOM,aAO8B,GAI9CxB,GAAgBA,EAAaA,eAAiBA,EAAa7zB,SAC9D47B,EAAYriC,KAkKd,SAAwCw7B,EAAQjgC,EAAK+mC,GACpD3lC,IAAIwjC,EAAUmC,EAAUnC,QACpBA,EAAQjhC,OAAS,MACpBihC,EAAUA,EAAQ78B,MAAM,EAAG,KAAO,OAGnC,OAAO,IAAIi/B,GAAgB,wBAAyB/G,EAAQ8G,EAAU9E,MACrE,sBAAuB2C,WAAU3E,EAAQgC,UAAU8E,EAAUp3B,OAAOswB,EAAQgC,KAzK3DgF,CAA+BhH,EAAQjgC,EAAK++B,IAG9D3/B,IAAMm8B,EAASwD,EAAeA,EAAaxD,OAASyE,GAAaC,EAAQjgC,GAQzE,OALC8mC,EADmB,eAAhBvL,EAAOvgB,KACI8rB,EAAYzhC,OA+C5B,SAAkC46B,EAAQjgC,EAAKu7B,GAC9Cn8B,IACM2R,EAASm2B,GADFjH,EAAOqB,QAAQthC,EAAIkV,MAAMnN,MAAM,EAAG/H,EAAIqB,IAChB,WAEnC,GAAI0P,EAAQ,CAGX3R,IAAM+nC,GACLxmC,MAAQuU,KAAMlV,EAAIkV,KAAM7T,GAAIrB,EAAIqB,GAAK0P,EAAOpN,QAC5C/C,GAAIZ,GAGL,IAAIu7B,EAAO37B,UAAW27B,EAAO37B,QAAQsf,SAYpC,OAAOkoB,GAAsBnH,EAAQjgC,EAAKu7B,GACxCl3B,gBAAOgjC,UAAcA,EAAWr1B,MAAQjB,GAA6C,IAAnCs2B,EAAWr1B,IAAI5O,QAAQ2N,KACzEjK,aAAIugC,UAAc,IAAIL,GAAgB,UAAW/G,EAAQkH,EAAaE,EAAWr1B,IAAKq1B,EAAWzC,QAASyC,EAAWn8B,WAbvH9L,IAAMkoC,EAAY/L,EAAO37B,QAAQsf,SAAS5R,cAEpC+5B,EAAaD,GAAsBnH,EAAQjgC,EAAKu7B,GACpDtqB,cAAKhO,UAAQA,EAAKic,UAAYjc,EAAKic,WAAaooB,IAElD,GAAID,GAAcA,EAAW3nB,SAAS/b,OACrC,OAAO0jC,EAAW3nB,SAAS5Y,aAAI4W,GAC9B,OAAkC,IAA3BA,EAAG1L,IAAI5O,QAAQ2N,IAAiB,IAAIi2B,GAAgB,QAAS/G,EAAQkH,EAAazpB,EAAG1L,IAAK0L,EAAGknB,QAASlnB,EAAGxS,WAC9G7G,OAAOwN,SASb,SA7EkC01B,CAAyBtH,EAAQjgC,EAAKu7B,IAEzDuL,EAAYzhC,OAkB5B,SAA8B46B,EAAQjgC,EAAKu7B,GAC1Cn8B,IACM2R,EAASm2B,GADFjH,EAAOqB,QAAQthC,EAAIkV,MAAMnN,MAAM,EAAG/H,EAAIqB,IAChB,aAInC,GAAI0P,EAAQ,CACX3R,IAAM+nC,GACLxmC,MAAQuU,KAAMlV,EAAIkV,KAAM7T,GAAIrB,EAAIqB,GAAK0P,EAAOpN,QAC5C/C,GAAIZ,GAGL,OAAOonC,GAAsBnH,EAAQjgC,EAAKu7B,GACxCl3B,gBAAOgjC,UAAcA,EAAWr1B,MAAQjB,GAA6C,IAAnCs2B,EAAWr1B,IAAI5O,QAAQ2N,KACzEjK,aAAIugC,UAAc,IAAIL,GAAgB,UAAW/G,EAAQkH,EAAaE,EAAWr1B,IAAKq1B,EAAWzC,QAASyC,EAAWn8B,WAGxH,SAnCkCs8B,CAAqBvH,EAAQjgC,EAAKu7B,KAInEvgB,KAAMugB,EAAOvgB,KACbH,OAAQ0gB,EAAO1gB,oBACfkkB,EACA+H,YAAaA,EAAYziC,OAAOwN,UA+ElC,SAASu1B,GAAsBnH,EAAQjgC,EAAKu7B,GAC3C,wBAEK0E,EAAO/vB,MAAMu3B,mBACjBxH,EAAO/vB,MAAMu3B,qBAGdroC,IAAMsoC,EAAQzH,EAAO/vB,MAAMu3B,iBAE3B,KAAM5sB,KAAU6sB,GAAQ,CACvBtoC,IAAM2L,EAAW8xB,GAAuB7hB,EAAMH,EAAQ0gB,EAAOxc,UAE7D2oB,EAAM7sB,GAAmB,eAATG,EAalB,SAA+BjQ,GAC9B,ODwGD,SAA8BA,GAC7B,OAAO+T,GAAY/T,EAASsV,KAAKrF,KAAM,YCzGhCsF,CAAqBvV,GAAUjE,aAAIoE,GACzC9J,IAAIwjC,EAAU15B,EAAQgU,SAChBQ,EAAWxU,EAAQwU,WAOzB,OANIA,EAAS/b,OACZihC,GAAW,KAAK7C,GAAariB,EAASpa,KAAK,QACjC4F,EAAQvJ,QAClBijC,GAAW,KAAK7C,GAAa72B,EAAQvJ,SAIrCqQ,IAAK9G,EAAQ8G,IACbrQ,MAAOuJ,EAAQvJ,MACfuJ,QAASA,EAAQ8G,IACjBkN,SAAUhU,EAAQgU,SAClBQ,SAAUA,EAAS5Y,aAAI4W,GACtBte,IAAMsS,EAAIgM,EAAGlW,MAAM,WACnB,OAAOkK,IACNM,IAAKN,EAAE,GACPkzB,QAAS7C,GAAarkB,GACtBxS,QAASwS,KAERrZ,OAAOwN,iBACV+yB,KAnCE+C,CAAsB58B,GA8C3B,SAA2BA,EAAUwwB,GACpC,OAAOxwB,EAASsV,KAAMrF,KAAM,WAAYlU,aAAIoE,UAC3C8G,IAAK9G,EAAQ8G,IACbrQ,MAAOuJ,EAAQvJ,MACfijC,QAAS7C,GAAanF,GAAO1xB,EAAQvJ,MAAO45B,IAC5CrwB,QAASA,EAAQ8G,OAlDd41B,CAAkB78B,EAAUwwB,GAGhC,OAAOmM,EAAM7sB,GAmEd,SAASqsB,GAAcpkC,EAAK0E,GAG3B,IAFApG,IAAIuH,EAAS7F,EAAIa,OAEVgF,EAAS,GACVnB,EAAM4B,KAAKtG,EAAI6F,EAAS,KAG7BA,IAGD,OAAO7F,EAAIiF,MAAMY,gBDxHjBwW,uBAAcK,GACd5d,KAAM0d,aAAa7a,KAAK+a,OAGpBC,4BACJ,OAAsB,MAAd7d,KAAKD,MAAgB4d,GAAW3d,KAAKD,OAAO,GAAK,mBAOzD+d,oBACA,IAEYzc,EAAM0c,EAFXre,KACAoe,EAAW,IAAI1U,IACjB9H,EAAI,EAOT,IALKtB,KAAKsd,UAET5d,EAAOmD,KAAK7C,MAGLsB,EAAI5B,EAAMqC,QAKjB,IAFAV,EAAQ3B,EAAM4B,MAEJvB,MAAO,CAChBge,EAAcJ,GAAWtc,EAAKtB,OAAO0C,OAAO0Y,IAG5C,IAAM3b,IAAIud,EAAI,EAAGA,EAAIgB,EAAWhc,OAAQgb,IACvCe,EAAUtU,IAAIuU,EAAWhB,GAAG5b,QAI7B,IAAM3B,IAAIud,EAAI,EAAGiB,EAAO3c,EAAKqc,aAAcX,EAAIiB,EAAKjc,OAAQgb,KAC1B,IAA5Brd,EAAM8B,QAAQwc,EAAKjB,KACvBrd,EAAOmD,KAAKmb,EAAKjB,IAMrB,OAAQpc,MAAM5B,KAAK+e,6CC+EpB,IAAMsnB,GASL,SAAYhsB,EAAMilB,EAAQgC,EAAOvgC,EAAMkjC,EAAS15B,GAChDtJ,KAAMoZ,KAAOA,EACbpZ,KAAMq+B,OAASA,EACfr+B,KAAMqgC,MAAQA,EACdrgC,KAAMF,KAAOA,EACbE,KAAMgjC,QAAUA,EAChBhjC,KAAMsJ,QAAUA,EAEhBtJ,KAAMimC,WAAY,GAGnBb,aAACr3B,kBACM/N,KAAKimC,YACVjmC,KAAMimC,WAAY,EACW,mBAAjBjmC,KAAKsJ,QAChBtJ,KAAMsJ,QAAQtJ,KAAKq+B,OAAQr+B,KAAKqgC,OAEhCO,GAAe5gC,KAAKq+B,OAAQr+B,KAAKqgC,MAAOrgC,KAAKsJ,SAE9Cg5B,GAActiC,KAAKq+B,UCvPrB,IAAMl+B,GACL,SAAYpC,EAAQqb,EAAM9Z,EAAMC,GAChCS,KAAMjC,OAASA,EACfiC,KAAMoZ,KAAOA,EACbpZ,KAAMV,KAAOA,EACbU,KAAMT,MAAQA,EAEdS,KAAMO,YACNP,KAAMQ,OAAS,6MAOXV,oBACJ,MAAmB,QAAdE,KAAKoZ,MAAkBpZ,KAAKV,KACxBU,KAAKV,MAAQU,KAAKV,KAAKQ,MAAQE,KAAKV,KAAKQ,KAAKC,MAG/C,IAAMC,KAAKoZ,SAOfhZ,0BACJ,OAAQJ,KAAKV,MAAQU,KAAKV,KAAKc,eAO3BjC,qBACJ,OAAQ6B,KAAKV,MAAQU,KAAKV,KAAKnB,UAO3BqH,mBACJ,OAAQxF,KAAKT,MAAQS,KAAKT,MAAMiG,IAAMxF,KAAKV,MAAQU,KAAKV,KAAKkG,QAGzDvD,0BACJ,OAAQjC,KAAKO,SAAS,OAGlB6B,2BACJ,IAAOc,EAAKlD,KAAKkmC,WACjB,OAAgB,IAARhjC,EAAYlD,KAAKQ,OAAOD,SAAS2C,EAAK,GAAK,SAG/Cb,+BACJ,IAAOa,EAAKlD,KAAKkmC,WACjB,OAAgB,IAARhjC,EAAYlD,KAAKQ,OAAOD,SAAS2C,EAAK,GAAK,mBAOnDgjC,oBACA,OAAQlmC,KAAKQ,OAASR,KAAKQ,OAAOD,SAASiB,QAAQxB,OAAS,gBAQ5DmmC,kBAAStiC,GAIT,OAHA7D,KAAMqE,YAAYR,GAClB7D,KAAMO,SAASsC,KAAKgB,GACpBA,EAAMrD,OAASR,KACPA,mBAQRqE,qBAAYR,GACZ,IAAOX,EAAKlD,KAAKO,SAASiB,QAAQqC,GAMlC,OALa,IAARX,IACJlD,KAAMO,SAAS4C,OAAOD,EAAI,GAC1BW,EAAMrD,OAAS,MAGRR,+CAWT,IAAIuD,GAAQ,SAASxF,EAAQI,EAAOqH,GACnC,MAAwB,mBAAVrH,EAYf,SAAkBJ,EAAQyJ,GACzBhK,IAAMW,EAAQJ,EAAOK,IACrB,GAAIL,EAAO+H,SAAS0B,GACnB,OAAO,IAAI4+B,GAAMroC,EAAQI,EAAOJ,EAAOK,KAGxCL,EAAOK,IAAMD,EAjBVkoC,CAAStoC,EAAQI,GACjB,IAAIioC,GAAMroC,EAAQI,EAAOqH,IAsB7B,IAAM4gC,GAML,SAAYroC,EAAQI,EAAOqH,GAC3BxF,KAAMjC,OAASA,EACfiC,KAAM7B,MAAiB,MAATA,EAAgBA,EAAQJ,EAAOI,MAC7C6B,KAAMwF,IAAiB,MAATA,EAAgBA,EAAQzH,EAAOK,IAC7C4B,KAAMkN,OAAS,sCASXnN,qBACJ,GAAqB,OAAhBC,KAAKkN,OAAiB,CAC1B,IAAO/O,EAAQ6B,KAAKjC,OAAOI,MACpBqH,EAAMxF,KAAKjC,OAAOK,IAEzB4B,KAAMjC,OAAOI,MAAQ6B,KAAK7B,MAC1B6B,KAAMjC,OAAOK,IAAM4B,KAAKwF,IACxBxF,KAAMkN,OAASlN,KAAKjC,OAAOkI,UAE3BjG,KAAMjC,OAAOI,MAAQA,EACrB6B,KAAMjC,OAAOK,IAAMoH,EAGpB,OAAQxF,KAAKkN,QAGdk5B,aAACphC,oBACA,OAAQhF,KAAKD,OAGdqmC,aAAClmC,mBACA,OAAWF,gBAAeA,gBAAeA,uDAI1CxC,IASM2H,IAAQtH,QAAQ,GAQlByoC,GAAY,SAASvoC,GACxBP,IAAMW,EAAQJ,EAAOK,IAMrB,GALiBiB,EAAQtB,EAnBV,GACA,GAkBkCoH,KAC7C9F,EAAQtB,EAlBG,GACA,GAiBuBoH,KAClC9F,EAAQtB,EAjBG,GACA,GAgBuBoH,KAClC9F,EAAQtB,EAhBG,IACA,IAeuBoH,IAGrC,OAAO5B,GAAMxF,EAAQI,IAIjBooC,GAAiB,GACjBr/B,GAAe,GACfs/B,GAAiB,GA6CvB,SAASC,GAAiB1oC,GACzB,OAAOuoC,GAAUvoC,IAAWwF,GAAMxF,EAAQ2oC,IAQ3C,SAASC,GAAkB5oC,GAC1BP,IAAMW,EAAQJ,EAAOK,IACrB,GAAIN,EAAUC,GAAS,CAItBP,IACIopC,EAAYC,EADV5gC,EAAUlI,EAAOK,IAGvBL,EAAOK,IAAMD,EACbJ,EAAOW,OACPkoC,EAAa7oC,EAAOI,MAAQJ,EAAOK,IAEnCL,EAAOK,IAAM6H,EACblI,EAAOgI,OAAO,GACd8gC,EAAW9oC,EAAOK,IAElBZ,IAAMsJ,EAASvD,GAAMxF,EAAQ6oC,EAAYC,GAEzC,OADA9oC,EAAOK,IAAM6H,EACNa,EAGR,OAAOw/B,GAAUvoC,IA2BlB,SAAqBA,GACpB,OAAOwF,GAAMxF,EAAQ8J,IA5BON,CAAYxJ,GASzC,SAAS2oC,GAAgB9nC,GACxB,OAAOA,IAASsI,KAAW4/B,GAAaloC,KAAUO,EAAQP,GAQ3D,SAASkoC,GAAaloC,GACrB,OAAOA,IAAS4nC,IAAiB5nC,IAAS2nC,GAiB3C,SAAS1+B,GAAWjJ,GACnB,QAAQmoC,MAAMnoC,IAAUJ,EAAQI,IAAUO,EAAQP,IAAUkoC,GAAaloC,IAG1EpB,IAAMgd,GAAc,GACdvT,GAAc,GAEdoK,GAAc,GAGd21B,GAAc,GAOhB3C,GAAM,SAAStmC,GAClBP,IAAMW,EAAQJ,EAAOK,IAErB,GAAIL,EAAOQ,IAZQ,IAYS,CAC3Bf,IAAMmT,GAAUyI,KAAMrb,EAAOQ,IAfX,IAewB,QAAU,QAEpD,IAAIoS,EAAM7Q,KAwBZ,SAAoB/B,GACnB,OAAOwF,GAAMxF,EAAQkpC,IAzBHC,CAAWnpC,MACR,UAAf4S,EAAMyI,OACTzI,EAAMvQ,WAlIU,SAASrC,GAI5B,IAHAP,IACiBsD,EADXgG,MAGE/I,EAAOU,OAOd,GANAV,EAAO+H,SAAS3G,IAChB2B,GAAS3C,MAAOJ,EAAOK,MAKd0B,KAAO2mC,GAAiB1oC,GAG5BA,EAAOQ,IAAI2I,IACdpG,EAAKf,MAAQ4mC,GAAkB5oC,GAE/B+C,EAAKe,SAAU,EAEhBf,EAAK0E,IAAMzH,EAAOK,IAClB0I,EAAOjE,KAAK/B,OACN,CAAA,GAAIgmC,GAAa/oC,EAAOO,QAG9B,MAEAP,EAAOW,OAIT,OAAOoI,EAoGeqgC,CAAcppC,GACjCA,EAAO+H,SAAS3G,GAChBwR,EAAMrQ,YAAcvC,EAAOQ,IArBX,KAwBbR,EAAOQ,IArBM,KAuBhB,OAAON,OAAOC,OAAOqF,GAAMxF,EAAQI,GAAQwS,GAO9C,OADA5S,EAAOK,IAAMD,EACN,MAiBR,SAAS8oC,GAAUroC,GAClB,OAAOK,EAAeL,IAClBA,IAASyS,IACTzS,IAASqI,IACTrI,IAAS4b,IACT5b,IAASooC,GASd,SAASI,GAASrpC,EAAQspC,GAGzB,IAFA7pC,IAAMW,EAAQJ,EAAOK,IAEZkD,EAAI,EAAGA,EAAI+lC,EAAMtlC,OAAQT,IACjC,IAAKvD,EAAOQ,IAAI8oC,EAAM/lC,IAErB,OADAvD,EAAOK,IAAMD,GACN,EAKT,OADAJ,EAAOI,MAAQA,GACR,EAWR,SAASmpC,GAAWvpC,EAAQuB,EAAMC,EAAOgoC,GACxC/pC,IAAMW,EAAQJ,EAAOK,IACrB,GAAIgpC,GAASrpC,EAAQuB,GAAO,CAE3B,MAAQvB,EAAOU,OAAO,CACrB,GAAI2oC,GAASrpC,EAAQwB,GACpB,OAAO,EAGRxB,EAAOW,OAIR,QAAI6oC,IAIJxpC,EAAOK,IAAMD,GACN,GAKR,OADAJ,EAAOK,IAAMD,EACN,KAQR,SAASqpC,GAAYtmC,GACpB,OAAOA,EAAIsB,MAAM,IAAI0C,aAAIzF,UAAMA,EAAGkG,WAAW,KAG9CnI,IAAM8B,GAAQkoC,GAAY,WACpBjoC,GAAQioC,GAAY,UAOtBhwB,GAAU,SAASzZ,GACtBP,IAAMW,EAAQJ,EAAOK,IACrB,GAAIkpC,GAAWvpC,EAAQuB,GAAMC,IAAO,GAAO,CAC1C/B,IAAMsJ,EAASvD,GAAMxF,EAAQI,GAE7B,OADA2I,EAAOsS,KAAO,UACPtS,EAGR,OAAO,MAGF2gC,GAAUD,GAAY,aACtBE,GAAUF,GAAY,OAOxBG,GAAQ,SAAS5pC,GACpBP,IAAMW,EAAQJ,EAAOK,IACrB,GAAIkpC,GAAWvpC,EAAQ0pC,GAAQC,IAAS,GAAO,CAC9ClqC,IAAMsJ,EAASvD,GAAMxF,EAAQI,GAE7B,OADA2I,EAAOsS,KAAO,QACPtS,EAGR,OAAO,MAGFnJ,IAOLiqC,KAAK,EAELC,SAAU,SAAU,SAOpBC,OAAQ,MAAO,OAAQ,OAAQ,KAAM,OAAQ,KAAM,OAAQ,MAAM,MAAO,QAAS,QAAS,QAAS,SAAU,UA8D9G,SAASliC,GAAM7H,GAEd,GAAsB,KAAlBA,EAAOO,OACV,OAAOkZ,GAAQzZ,IAAW4pC,GAAM5pC,IAAWsmC,GAAItmC,GASjD,SAASgqC,GAAehqC,EAAQspC,GAI/B,IAHA7pC,IAAMW,EAAQJ,EAAOK,KAGbL,EAAOU,OAAO,CACrB,GAAI2oC,GAASrpC,EAAQspC,GAEpB,OADAtpC,EAAOK,IAAML,EAAOI,MACbkmC,GAAItmC,GAEZA,EAAOW,OAIR,OADAX,EAAOK,IAAMD,EACN,KAYR,SAAS6pC,GAAKzmC,GACb,OAAOA,EAAIA,EAAIQ,OAAS,GChlBzB,IAAqBkmC,GAMpB,SAAYC,EAAK9uB,EAAMH,GACvBjZ,KAAMkoC,IAAMA,EACZloC,KAAMoZ,KAAOA,EACbpZ,KAAMiZ,OAASA,GCLD,SAASvW,GAAO27B,EAAQplB,GACtCzb,IAAMO,EAAS,IAAIuH,GAAa+4B,GAC1BuJ,EAAiB,QAAX3uB,EAEZ,IACC,OAAO,IAAIgvB,GF4eb,SAAej6B,EAAShQ,GACvBA,EAAUC,OAAOC,UAAWP,GAAgBK,GAc5C,IAbAR,IAWIsS,EAAGjM,EAAM/D,EAyEGqoC,EApFVpqC,EAA4B,iBAAZiQ,EACnB,IAAI1I,EAAa0I,GACjBA,EAEGnF,EAAO,IAAI1I,GAAKpC,EAAQ,QACxB+pC,EAAQ,IAAI1+B,IAAIpL,EAAQ8pC,OACxBD,EAAU7pC,EAAQ6pC,QAAQlmC,gBAC9BuD,EAAKpF,UAASoF,EAAI8E,IAAIlK,EAAM0nC,QAAiB1nC,SAAW,IAAIiK,KACxDq+B,WAAW7kC,EAAOzD,UACvByD,EAAMjD,cAAiBtC,EAAQ4pC,KAAOE,EAAMv+B,IAAIzJ,IAE9BJ,GAASmJ,IAEpB9K,EAAOU,OACd,GAAIqR,EAAIlK,GAAM7H,GAGb,GAFA+B,GAqEcqoC,EArECr4B,GAsEHhQ,KAAOqoC,EAAOroC,KAAKC,MAAM2L,kBAAoBy8B,EAAW,KApErD,SAAXr4B,EAAEsJ,KAELvV,EAAO,IAAI1D,GAAKpC,EAAQ,MAAO+R,GAC/Bk4B,GAAKtoC,GAAOymC,SAAStiC,GACjBgkC,EAAQt+B,IAAIzJ,GACf+D,EAAKtE,MAAQwoC,GAAehqC,EAAQ8pC,EAAQ39B,IAAIpK,IACrCsoC,EAAQt4B,EAAGhQ,IACtBJ,EAAMmD,KAAKgB,QAEN,GAAe,UAAXiM,EAAEsJ,MAEZ,IAAK5Z,IAAI8B,EAAI5B,EAAMqC,OAAS,EAAGT,EAAI,EAAGA,IACrC,GAAI5B,EAAM4B,GAAGxB,KAAK4L,gBAAkB5L,EAAM,CACzCJ,EAAM4B,GAAG/B,MAAQuQ,EACjBpQ,EAAQA,EAAMyG,MAAM,EAAG7E,GACvB,YAIF0mC,GAAKtoC,GAAOymC,SAAS,IAAIhmC,GAAKpC,EAAQ+R,EAAEsJ,KAAMtJ,SAG/C/R,EAAOW,OAIT,OAAOmK,EEzhBiBw/B,CAAUtqC,OAAU6pC,IAAQ,OAAQ3uB,GAAU,QACpE,MAAO5S,GACRw8B,QAAQC,KAAKz8B,ICfA,SAASiiC,GAASjK,GAEhC,OAAOgK,GAAUhK,EAqBlB,SAAmBA,GAClB7gC,IAAMghC,EAAOH,EAAOE,UAEpB,GAAkB,cAAdC,EAAK1+B,KACR,MAAO,OAGR,MAAqB,QAAd0+B,EAAK1+B,KAAiB0+B,EAAKM,cAAgBN,EAAK1+B,KA7BxC4+B,CAAUL,IAYnB,SAASkK,GAAiBlK,GAChCA,EAAO/vB,MAAMk6B,YAAc,KFS5BP,aAAC3D,sBAAalmC,EAAKkiC,GAIlB,IAHA,IAAK37B,EAAM3E,KAAKkoC,IAAIjmC,WACf0a,EAAQ,KAELhY,GACFy7B,GAAYG,GAAc57B,GAAMvG,EAAKkiC,IAEzC3jB,EAAShY,EACTA,EAAOA,EAAI1C,YAEX0C,EAAOA,EAAIvC,YAIb,OAAQua,GGrCTnf,IAAMirC,GAAc,iBACdC,GAAe,kBAQN,SAASC,GAAStK,EAAQjgC,GACxCA,EAAMA,GAAOigC,EAAOM,YAGpBnhC,IAAMorC,EAASC,GAAaxK,GAI5B,GAAIuK,EACH,GAAIxI,GAAYwI,EAAOtpC,KAAK+P,OAAQjR,IAGnC,IAAKwqC,EAAOrpC,OAAS+S,GAAK+rB,EAAQuK,EAAOtpC,QAAUgT,GAAK+rB,EAAQuK,EAAOrpC,OACtE,OAAOqpC,OAEF,GAAIA,EAAOrpC,OAGb6gC,GAAYwI,EAAOrpC,MAAM8P,OAAQjR,IAAQkU,GAAK+rB,EAAQuK,EAAOtpC,QAAUgT,GAAK+rB,EAAQuK,EAAOrpC,OAC9F,OAAOqpC,EAMVE,GAAczK,GAGd7gC,IAAMqG,EAwCA,SAAqBw6B,EAAQjgC,GACnCZ,IAAMmT,EAAQ0tB,EAAO+F,wBACrB,OAAOzzB,GAASA,EAAM2zB,aAAalmC,GAAOigC,EAAOM,aA1CpCoK,CAAY1K,EAAQjgC,GACjC,GAAIyF,GAAsB,QAAdA,EAAKuV,KAChB,OACC9Z,KAAM0pC,GAAc3K,EAAQx6B,EAAKvE,KAAKQ,KAAM2oC,IAC5ClpC,MAAOsE,EAAKtE,OAASypC,GAAc3K,EAAQx6B,EAAKtE,MAAMO,KAAM4oC,KAKxD,SAASG,GAAaxK,GAC5B7+B,IAAIF,EAAMC,EASV,OARA8+B,EAAOkE,cAAc1hC,iBAAQoR,GACxBA,EAAKlD,YAAc05B,GACtBnpC,EAAO2S,EACGA,EAAKlD,YAAc25B,KAC7BnpC,EAAQ0S,KAIH3S,QAASA,QAAMC,GAAU,KAO1B,SAASupC,GAAczK,GAC7BA,EAAOkE,cAAc1hC,iBAAQoR,GACxBA,EAAKlD,YAAc05B,IAAex2B,EAAKlD,YAAc25B,IACxDz2B,EAAKwmB,UAgBR,SAASuQ,GAAc3K,EAAQgG,EAAKt1B,GACnC,OAAOsvB,EAAOoE,SAAS4B,EAAIlmC,MAAOkmC,EAAI7+B,eACrCuJ,EACA2zB,eAAe,EACfC,gBAAgB,EAChBC,gBAAgB,IAIlB,SAAStwB,GAAK+rB,EAAQpsB,GACrBzU,IAAM6iC,EAAQpuB,EAAK5C,OACnB,OAAOgxB,EAAQhC,EAAOuB,SAASS,EAAMthC,KAAMshC,EAAMrhC,IAAM,GC5FzC,SAASiqC,GAAU5K,EAAQvX,GACzCtpB,IAAM6mC,EAAMwE,GAAaxK,GACnBjgC,EAAM0oB,EAAI/nB,KAEXslC,IAIDjE,GAAYiE,EAAI/kC,KAAK+P,OAAQjR,IAAQimC,EAAI9kC,MAE5C2pC,GAAU7K,EAAQgG,EAAI/kC,KAAM+kC,EAAI9kC,OACtB8kC,EAAI9kC,OAAS6gC,GAAYiE,EAAI9kC,MAAM8P,OAAQjR,IAErD8qC,GAAU7K,EAAQgG,EAAI9kC,MAAO8kC,EAAI/kC,OAI5B,SAAS4pC,GAAU7K,EAAQ8K,EAAQC,GACzC5rC,IAAMsC,EAeP,SAAcu+B,EAAQpsB,GACrBzU,IAAM6iC,EAAQpuB,EAAK5C,OACnB,OAAOgxB,EAAQhC,EAAOuB,SAASS,EAAMthC,KAAMshC,EAAMrhC,IAAM,GAjB1CsT,CAAK+rB,EAAQ8K,GACpB9I,EAAQ+I,EAAK/5B,OACbS,EAAIhQ,EAAK8F,MAAM,YACf5C,EAAWlD,EAAagQ,GAAKA,EAAE,GAAb,GAET,MAAX9M,EACCq7B,EAAOuB,SAASS,EAAMthC,KAAMshC,EAAMrhC,MAAQgE,GAC7Cq7B,EAAO2C,aAAah+B,EAASq9B,EAAMthC,KAAMshC,EAAMrhC,IAIhD8pC,GAAczK,GC9BU,oBAAfY,YCeI,SAAgCA,GAE9ChhC,OAAOC,OAAO+gC,EAAWoK,UACxBC,iCAAyBjL,UAAUkL,GAAmBlL,GAAQ,IAC9DmL,oCAA4BnL,UAAUkL,GAAmBlL,GAAQ,yBACjEoL,6BACAC,KAEDlsC,IAAMmsC,WAAqBtL,UChBb,SAA0BA,EAAQjgC,GAChDZ,IAAMikC,EAASC,GAAWrD,EAAQjgC,GAClC,GAAIqjC,EAEH,OAAOA,EAIRa,GAAajE,GAEb7gC,IAAMmT,EAAQwyB,GAAgB9E,EAAQjgC,GAAK,GAE3C,OAAIuS,EACI6xB,GAAanE,EAAQ1tB,QAD7B,EDIqCi5B,CAAiBvL,EAAQA,EAAOM,cAGrEM,EAAW4K,aAAa,yBAAyB,WAAOxL,EAAQt+B,GAC3DA,EACHs+B,EAAOyL,GAAG,SAAUH,IAEpBtL,EAAO0L,IAAI,SAAUJ,GACrBrH,GAAajE,MAIfY,EAAW4K,aAAa,kBAAkB,WAAOxL,EAAQt+B,GACxDA,EAAQs+B,EAAOyL,GAAG,SAAUb,IAAa5K,EAAO0L,IAAI,SAAUd,MAI/DhK,EAAW4K,aAAa,cAAc,GAEtC5K,EAAW4K,aAAa,gBAAgB,WAAQxL,EAAQt+B,GACnDA,GACHs+B,EAAOyL,GAAG,iBAAkBnB,IAC5BtK,EAAOyL,GAAG,SAAUvB,MAEpBlK,EAAO0L,IAAI,iBAAkBpB,IAC7BtK,EAAO0L,IAAI,SAAUxB,IACrBA,GAAiBlK,GACjByK,GAAczK,MAKhBY,EAAW4K,aAAa,YAWxB5K,EAAW+K,gBAAgB,sBAAuB,SAAS5rC,EAAK6rC,GAE5C,kBAAR7rC,IACV6rC,EAAQ7rC,EACRA,EAAM,MAKPZ,IAAM0sC,EAAeC,GARNnqC,KAMf5B,EAAMA,GANS4B,KAMK2+B,aAGpB,GAAIuL,GAAgBA,EAAahF,YAAYnjC,OAS5C,OAlBc/B,KAUH4+B,UAAU,2BAEf8C,GAZQ1hC,KAYW5B,IAAQ6rC,IAC/B3H,GAbYtiC,MAcZwiC,GAAa0H,EAAav5B,SAK3B5R,KAAMmrC,EAAa/M,aAAakD,MAAMthC,KACtCC,GAAIkrC,EAAa/M,aAAakD,MAAMrhC,GACpCsxB,KAAM4Z,EAAahF,eAYtBjG,EAAW+K,gBAAgB,uBAAwB,SAAS5rC,EAAKojC,GAChE,OAAO2B,GAAgBnjC,KAAM5B,GAAO4B,KAAK2+B,YAAa6C,KAGvDvC,EAAW+K,gBAAgB,kBAAmB,SAAS5rC,GACtD,OAAOsjC,GAAW1hC,KAAM5B,GAAO4B,KAAK2+B,eAGrCM,EAAW+K,gBAAgB,wBAAyB,WAEnD,OADehqC,KACD4+B,UAAU,gBJzGnB,SAAwBP,GAK9B,OAJKA,EAAO/vB,MAAMk6B,cACjBnK,EAAO/vB,MAAMk6B,YAAcF,GAASjK,IAG9BA,EAAO/vB,MAAMk6B,YIqGhB4B,CAFYpqC,MAGZsoC,GAHYtoC,QD5GhBqqC,CAAuBpL"}